diff --git a/CMakeLists.txt b/CMakeLists.txt
index e6435f5..30ba726 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -29,7 +29,7 @@ set(PACKAGE "condor")
 #   Condor and other systems parse this number. Keep it simple:
 #   Number.Number.Number. Do nothing else.  If you need to add
 #   more information, PRE_RELEASE is usually the right location.
-set(VERSION "7.6.0")
+set(VERSION "7.6.1")
 
 # Set PRE_RELEASE to either a string (i.e. "PRE-RELEASE-UWCS") or OFF
 #   This shuld be "PRE-RELEASE-UWCS most of the time, and OFF when
@@ -90,15 +90,16 @@ include (CondorStaticLib)
 include (CondorPlugin)
 include (CheckCXXCompilerFlag)
 include (CheckCXXSourceCompiles)
-include (CondorConfigure)     # will initiate the configure
 include (AddSubdirectories)
 include (CondorPLTest)
 include (CondorExeTest)
 include (CondorStdExeTest)
 include (SrcTargetRef)
 include (DumpLocalFlags)
+include (CondorConfigure)     # will initiate the configure
 include (TarGz) # Must be after include(CondorPackageConfig)
 
+
 if ( WINDOWS )
 	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
 endif ( WINDOWS )
diff --git a/build/cmake/CondorConfigure.cmake b/build/cmake/CondorConfigure.cmake
index ad69e0c..7cd2fcb 100644
--- a/build/cmake/CondorConfigure.cmake
+++ b/build/cmake/CondorConfigure.cmake
@@ -128,7 +128,15 @@ if( NOT WINDOWS)
 
 	set(HAVE_PTHREAD_H ${CMAKE_HAVE_PTHREAD_H})
 
-	find_library(HAVE_DMTCP dmtcpaware HINTS /usr/local/lib/dmtcp )
+	find_library( HAVE_DMTCP dmtcpaware HINTS /usr/local/lib/dmtcp )
+	find_library( LIBRESOLV_PATH resolv )
+    if( NOT "${LIBRESOLV_PATH}" MATCHES "-NOTFOUND" )
+      set(HAVE_LIBRESOLV ON)
+    endif()
+	find_library( LIBDL_PATH resolv )
+    if( NOT "${LIBDL_PATH}" MATCHES "-NOTFOUND" )
+      set(HAVE_LIBDL ON)
+    endif()
 	check_library_exists(dl dlopen "" HAVE_DLOPEN)
 	check_symbol_exists(res_init "sys/types.h;netinet/in.h;arpa/nameser.h;resolv.h" HAVE_DECL_RES_INIT)
 
@@ -198,7 +206,11 @@ if( NOT WINDOWS)
 
 	check_struct_has_member("struct statfs" f_fstyp "sys/statfs.h" HAVE_STRUCT_STATFS_F_FSTYP)
 	if (NOT ${OS_NAME} STREQUAL "DARWIN")
-		check_struct_has_member("struct statfs" f_fstypename "sys/statfs.h" HAVE_STRUCT_STATFS_F_FSTYPENAME)
+  	  if( HAVE_SYS_STATFS_H )
+		check_struct_has_member("struct statfs" f_fstypename "sys/statfs.h" HAVE_STRUCT_STATFS_F_FSTYPENAME )
+	  else()
+		check_struct_has_member("struct statfs" f_fstypename "sys/mount.h" HAVE_STRUCT_STATFS_F_FSTYPENAME )
+	  endif()
 	endif()
 	check_struct_has_member("struct statfs" f_type "sys/statfs.h" HAVE_STRUCT_STATFS_F_TYPE)
 	check_struct_has_member("struct statvfs" f_basetype "sys/types.h;sys/statvfs.h" HAVE_STRUCT_STATVFS_F_BASETYPE)
@@ -322,6 +334,10 @@ elseif(${OS_NAME} STREQUAL "HPUX")
 	set(HPUX ON)
 	set(DOES_SAVE_SIGSTATE ON)
 	set(NEEDS_64BIT_STRUCTS ON)
+elseif(${OS_NAME} STREQUAL "HPUX")
+	set(HPUX ON)
+	set(DOES_SAVE_SIGSTATE ON)
+	set(NEEDS_64BIT_STRUCTS ON)
 endif()
 
 ##################################################
@@ -338,6 +354,7 @@ option(BUILD_TESTS "Will build internal test applications" ON)
 option(WANT_CONTRIB "Enable quill functionality" OFF)
 option(WANT_FULL_DEPLOYMENT "Install condors deployment scripts, libs, and includes" ON)
 option(WANT_GLEXEC "Build and install condor glexec functionality" ON)
+option(ENABLE_JAVA_TESTS "Enable java tests" ON)
 
 if (UW_BUILD OR WINDOWS)
   option(PROPER "Try to build using native env" OFF)
@@ -466,6 +483,7 @@ if (NOT WINDOWS)
 	add_subdirectory(${CONDOR_EXTERNAL_DIR}/bundles/blahp/1.16.1)
 	add_subdirectory(${CONDOR_EXTERNAL_DIR}/bundles/voms/1.9.10_4)
 	add_subdirectory(${CONDOR_EXTERNAL_DIR}/bundles/cream/1.12.1_14)
+	add_subdirectory(${CONDOR_EXTERNAL_DIR}/bundles/wso2/2.1.0)
 
 	# the following logic if for standard universe *only*
 	if (LINUX AND NOT CLIPPED AND GLIBC_VERSION AND NOT PROPER)
@@ -669,7 +687,7 @@ else(MSVC)
 		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--warn-once -Wl,--warn-common")
 	endif(LINUX)
 
-	if(HAVE_DLOPEN AND NOT DARWIN)
+	if( HAVE_LIBDL AND NOT BSD_UNIX )
 		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -ldl")
 	endif()
 
@@ -678,7 +696,7 @@ else(MSVC)
 		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-berok -Wl,-bstatic -lstdc++ -Wl,-bdynamic -lcfg -lodm -static-libgcc")
 	endif(AIX)
 
-	if (NOT PROPER AND NOT AIX)
+	if ( NOT PROPER AND HAVE_LIBRESOLV )
 		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -lresolv")
 		if (NOT DARWIN)
 			set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -lcrypt")
@@ -818,9 +836,15 @@ dprint ( "CONDOR_PACKAGE_NAME: ${CONDOR_PACKAGE_NAME}" )
 # is TRUE on all UNIX-like OS's, including Apple OS X and CygWin
 dprint ( "UNIX: ${UNIX}" )
 
+# is TRUE on all BSD-derived UNIXen
+dprint ( "BSD_UNIX: ${BSD_UNIX}" )
+
 # is TRUE on all UNIX-like OS's, including Apple OS X and CygWin
 dprint ( "Linux: ${LINUX_NAME}" )
 
+# Print FreeBSD info
+dprint ( "FreeBSD: ${FREEBSD_MAJOR}.${FREEBSD_MINOR}" )
+
 # is TRUE on Windows, including CygWin
 dprint ( "WIN32: ${WIN32}" )
 
diff --git a/build/cmake/CondorPackageConfig.cmake b/build/cmake/CondorPackageConfig.cmake
index 57b2700..73f73a1 100644
--- a/build/cmake/CondorPackageConfig.cmake
+++ b/build/cmake/CondorPackageConfig.cmake
@@ -119,6 +119,7 @@ set( C_INCLUDE		include)
 set( C_MAN			man)
 set( C_SRC			src)
 set( C_SQL			sql)
+set( C_SERVICES     services)
 
 set( C_INIT			etc/init.d )
 set( C_ETC			etc/examples )
diff --git a/build/cmake/macros/SystemSpecificInformations.cmake b/build/cmake/macros/SystemSpecificInformations.cmake
index 125de4b..a694153 100644
--- a/build/cmake/macros/SystemSpecificInformations.cmake
+++ b/build/cmake/macros/SystemSpecificInformations.cmake
@@ -227,9 +227,41 @@ if(UNIX)
       else()
 	set(LINUX_NAME "NOT-FOUND")
       endif(LINUX_NAME)
+    endif(EXISTS "/etc/issue")
+
+  elseif(CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
+    string(REGEX MATCH "(([0-9]+)\\.([0-9]+))-RELEASE" FREEBSD "${CMAKE_SYSTEM_VERSION}")
+    set( FREEBSD_RELEASE "${CMAKE_MATCH_1}" )
+    set( FREEBSD_MAJOR "${CMAKE_MATCH_2}" )
+    set( FREEBSD_MINOR "${CMAKE_MATCH_3}" )
+    set( FREEBSD_VERSION "${CMAKE_SYSTEM_VERSION}" )
+    set( SYSTEM_NAME "freebsd_${FREEBSD_RELEASE}" )
+    set( CONDOR_FREEBSD ON )
+    set( BSD_UNIX ON )
+    if(FREEBSD_MAJOR MATCHES "4" )
+      set( CONDOR_FREEBSD4 ON )
+    elseif(FREEBSD_MAJOR MATCHES "5" )
+      set( CONDOR_FREEBSD5 ON )
+    elseif(FREEBSD_MAJOR MATCHES "6" ) 
+      set( CONDOR_FREEBSD6 ON )
+    elseif(FREEBSD_MAJOR MATCHES "7" )
+      set( CONDOR_FREEBSD7 ON )
+    elseif(FREEBSD_MAJOR MATCHES "8" )
+      set( CONDOR_FREEBSD8 ON )
+    endif()
+    if( CMAKE_SYSTEM_PROCESSOR MATCHES "amd64" )
+      set( SYS_ARCH "x86_64")
+    elseif( CMAKE_SYSTEM_PROCESSOR MATCHES "i386" )
+      set( SYS_ARCH "x86")
+    endif( )
+    set( PLATFORM "${SYS_ARCH}_freebsd_${FREEBSD_RELEASE}")
+
+  elseif(OS_NAME MATCHES "DARWIN")
+    set( BSD_UNIX ON )
 
-    endif(EXISTS "/etc/issue")      
   endif(CMAKE_SYSTEM_NAME MATCHES "Linux")
+
   set(SPECIFIC_SYSTEM_VERSION_NAME "${SPECIFIC_SYSTEM_VERSION_NAME}-${CMAKE_SYSTEM_PROCESSOR}")
   set(SPECIFIC_COMPILER_NAME "")
+
 endif(UNIX)
diff --git a/externals/bundles/blahp/1.16.1/classads.m4 b/externals/bundles/blahp/1.16.1/classads.m4
index 424536f..33608eb 100644
--- a/externals/bundles/blahp/1.16.1/classads.m4
+++ b/externals/bundles/blahp/1.16.1/classads.m4
@@ -16,7 +16,7 @@ AC_DEFUN(AC_CLASSADS,
     AC_MSG_CHECKING([for CLASSAD installation])
 
     CLASSAD_CFLAGS=""
-    CLASSAD_LIBS="-lclassad_ns -lpcre"
+    CLASSAD_LIBS="-lclassad -lpcre"
     CLASSAD_DL_LIBS="-lclassad_dl"
     if test -n "$with_classads_prefix" -a "$with_classads_prefix" != "/usr" ; then
             AC_MSG_RESULT([prefix: $with_classads_prefix])
@@ -24,7 +24,7 @@ AC_DEFUN(AC_CLASSADS,
             ac_classads_prefix=$with_classads_prefix
 
             CLASSAD_CFLAGS="-I$with_classads_prefix/include"
-            CLASSAD_LIBS="$with_classads_prefix/lib/libclassad_ns.a $with_classads_prefix/lib/libpcre.a"
+            CLASSAD_LIBS="$with_classads_prefix/lib/libclassad.a $with_classads_prefix/lib/libpcre.a"
 	    CLASSAD_DL_LIBS="-L$with_classads_prefix/lib $CLASSAD_DL_LIBS"
     fi
 
diff --git a/externals/bundles/cream/1.12.1_14/classads.m4 b/externals/bundles/cream/1.12.1_14/classads.m4
index 424536f..33608eb 100644
--- a/externals/bundles/cream/1.12.1_14/classads.m4
+++ b/externals/bundles/cream/1.12.1_14/classads.m4
@@ -16,7 +16,7 @@ AC_DEFUN(AC_CLASSADS,
     AC_MSG_CHECKING([for CLASSAD installation])
 
     CLASSAD_CFLAGS=""
-    CLASSAD_LIBS="-lclassad_ns -lpcre"
+    CLASSAD_LIBS="-lclassad -lpcre"
     CLASSAD_DL_LIBS="-lclassad_dl"
     if test -n "$with_classads_prefix" -a "$with_classads_prefix" != "/usr" ; then
             AC_MSG_RESULT([prefix: $with_classads_prefix])
@@ -24,7 +24,7 @@ AC_DEFUN(AC_CLASSADS,
             ac_classads_prefix=$with_classads_prefix
 
             CLASSAD_CFLAGS="-I$with_classads_prefix/include"
-            CLASSAD_LIBS="$with_classads_prefix/lib/libclassad_ns.a $with_classads_prefix/lib/libpcre.a"
+            CLASSAD_LIBS="$with_classads_prefix/lib/libclassad.a $with_classads_prefix/lib/libpcre.a"
 	    CLASSAD_DL_LIBS="-L$with_classads_prefix/lib $CLASSAD_DL_LIBS"
     fi
 
diff --git a/externals/bundles/wso2/2.1.0/CMakeLists.txt b/externals/bundles/wso2/2.1.0/CMakeLists.txt
new file mode 100644
index 0000000..305dfd7
--- /dev/null
+++ b/externals/bundles/wso2/2.1.0/CMakeLists.txt
@@ -0,0 +1,94 @@
+ ###############################################################
+ # 
+ # Copyright 2011 Red Hat, Inc. 
+ # 
+ # Licensed under the Apache License, Version 2.0 (the "License"); you 
+ # may not use this file except in compliance with the License.  You may 
+ # obtain a copy of the License at 
+ # 
+ #    http://www.apache.org/licenses/LICENSE-2.0 
+ # 
+ # Unless required by applicable law or agreed to in writing, software 
+ # distributed under the License is distributed on an "AS IS" BASIS, 
+ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ # See the License for the specific language governing permissions and 
+ # limitations under the License. 
+ # 
+ ############################################################### 
+if (WANT_CONTRIB AND LINUX AND PROPER)
+    option(WITH_WSO2 "Compiling with support for WITH_WSO2" ON)
+endif()
+
+if (WITH_WSO2)
+
+	# need to embed libDir in axis2.xml
+	if ( ${SYS_ARCH} STREQUAL "X86_64" )
+		set (WS02_LIB_ROOT "/usr/lib64")
+	else()
+		set (WS02_LIB_ROOT "/usr/lib")
+	endif ()
+
+	if ( NOT PROPER )
+
+		set ( WSO2_VER wso2-2.0.1 )
+
+		#ExternalProject_Add(zlib
+		#		    PREFIX ${EXTERNAL_BUILD_PREFIX}/${WSO2_VER}
+		#		    #-- Download Step ----------
+		#			DOWNLOAD_COMMAND wget -N http://parrot.cs.wisc.edu/externals/${WSO2_VER}.tar.gz ${CMD_TERM}
+		#		    DOWNLOAD_DIR ${EXTERNAL_DL}
+		#		    URL http://parrot.cs.wisc.edu/externals/${WSO2_VER}.tar.gz
+		#		    #--Configure step ----------
+		#		    CONFIGURE_COMMAND cd ${WSO2_VER} && ./configure --prefix=${EXTERNAL_STAGE}
+		#		    #--Build Step ----------
+		#		    BUILD_COMMAND cd ${WSO2_VER} && make
+		#		    #--install Step ----------
+		#		    INSTALL_DIR ${EXTERNAL_STAGE}
+		#		    INSTALL_COMMAND cd ${WSO2_VER} && make install )
+		#
+		# Set the target dependencies which the rest of condor depends on.
+		#set(WSO2_FOUND "${EXTERNAL_STAGE}/STUFF?")
+		#append_var(CONDOR_EXTERNALS zlib)
+		#
+		#install ( FILES ${EXTERNAL_STAGE}/lib/libz.a DESTINATION ${C_LIB} RENAME libcondor_z.a)
+
+		
+		#########################################################
+		#### import from pmackinn's stuff.
+		#if ( NOT DEFINED ENV{WSFCPP_HOME} )
+		#	message( FATAL_ERROR "WSFCPP_HOME not defined for non-proper build")
+		#endif ()
+		#
+		#set ( AXIS2_LIBS -L$ENV{WSFCPP_HOME}/lib
+		#	-libaxis2_engine
+		#	-laxutil -laxis2_axiom -laxis2_parser
+		#	-lneethi -lguththila
+		#	-laxis2_http_common -laxis2_http_receiver -laxis2_http_sender
+		#	-lwso2_wsf )
+		#
+		#include_directories(
+		#		$ENV{WSFCPP_HOME}/include/axis2-1.6.0
+		#		$ENV{WSFCPP_HOME}/include/wso2-wsf-cpp
+		#		$ENV{WSFCPP_HOME}/include/axis2-1.6.0/platforms )
+		#	set(axis2_repo_loc $ENV{WSFCPP_HOME})
+	else( )
+
+		find_multiple( "axis2_engine;axutil;axis2_axiom;axis2_parser;axis2_http_common;axis2_http_receiver;axis2_http_sender;neethi;guththila;wso2_wsf" WSO2_FOUND )
+		append_var (WSO2_INCLUDES "/usr/include/axis2-1.6.0;/usr/include/wso2-wsf-cpp;/usr/include/axis2-1.6.0/platforms")
+
+		install (CODE "execute_process(COMMAND echo Local testing instructions )" )
+		install (CODE "execute_process(COMMAND echo set WSFCPP_HOME to \$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${_INSTALL_LOC}axis2.xml)" )
+		install (CODE "execute_process(COMMAND echo change the servicesDir parameter in axis2.xml to \$ENV{DESTDIR}\${CMAKE_INSTALL_PREFIX}/${_INSTALL_LOC}services)" )
+
+	endif( NOT PROPER )
+
+endif(WITH_WSO2)
+
+if (WSO2_FOUND)
+	message (STATUS "external configured (WSO2_FOUND=${WSO2_FOUND})")
+	set( WSO2_FOUND ${WSO2_FOUND} PARENT_SCOPE )
+	set( HAVE_EXT_WSO2 ON PARENT_SCOPE )
+	set( WS02_LIB_ROOT ${WS02_LIB_ROOT} PARENT_SCOPE )
+else()
+	message (STATUS "external skipped (wso2)")
+endif()
diff --git a/nmi_tools/glue/SubmitInfo.pm b/nmi_tools/glue/SubmitInfo.pm
index 62a03f8..c510ea6 100755
--- a/nmi_tools/glue/SubmitInfo.pm
+++ b/nmi_tools/glue/SubmitInfo.pm
@@ -59,9 +59,10 @@ our %build_and_test_sets = (
 		'x86_64_rhap_5.3-updated',
 		'x86_64_opensuse_11.3-updated',
 		'x86_64_opensuse_11.4-updated',
-		'x86_64_sol_5.10',
-		'x86_64_sol_5.11',
 		'x86_64_fedora_12-updated',
+		'x86_freebsd_7.4',
+		'x86_64_freebsd_8.2',
+		'x86_64_sol_5.11',
 	],
 
         # This is a placeholder that is intended to remain empty in V7_6-branch.
@@ -311,6 +312,55 @@ our %submit_info = (
 		},
 	},
 
+	##########################################################################
+	# Platform RHEL 6 on x86
+	##########################################################################
+	'x86_rhap_6.0'	=> {
+		'build' => {
+			'configure_args' => { @default_build_configure_args,
+				# Turn this back on when ready
+				# '-DCLIPPED:BOOL=OFF' => undef,
+			 },
+			'prereqs'	=> [ @default_prereqs ],
+			'xtests'	=> undef,
+		},
+
+		'test' => {
+			'configure_args' => { @default_test_configure_args },
+			'prereqs'	=> [ @default_prereqs, 'java-1.4.2_05' ],
+			'testclass'	=> [ @default_testclass ],
+		},
+	},
+
+	##########################################################################
+	# Platform RHEL 6 on x86. This one is continuously updated by the batlab.
+	##########################################################################
+	'x86_rhap_6.0-updated'	=> 'x86_rhap_6.0',
+
+	##########################################################################
+	# Platform RHEL 6 on x86_64
+	##########################################################################
+	'x86_64_rhap_6.0'	=> {
+		'build' => {
+			'configure_args' => { @default_build_configure_args,
+				# Turn this back on when ready
+				# '-DCLIPPED:BOOL=OFF' => undef,
+			 },
+			'prereqs'	=> [ @default_prereqs ],
+			'xtests'	=> undef,
+		},
+
+		'test' => {
+			'configure_args' => { @default_test_configure_args },
+			'prereqs'	=> [ @default_prereqs, 'java-1.4.2_05' ],
+			'testclass'	=> [ @default_testclass ],
+		},
+	},
+
+	##########################################################################
+	# Platform RHEL 6 on x86_64. This one is continuously updated by the batlab.
+	##########################################################################
+	'x86_64_rhap_6.0-updated'	=> 'x86_64_rhap_6.0',
 
 	##########################################################################
 	# Platform RHEL 5 on x86_64
@@ -324,7 +374,8 @@ our %submit_info = (
 			'xtests'	=> [ 
 				'x86_64_fedora_13', 'x86_64_rhap_5.2',
 				'x86_64_fedora_12', 'x86_64_fedora_12-updated', 
-				'x86_64_fedora_13-updated' ],
+				'x86_64_fedora_13-updated',
+				'x86_64_rhap_6.0-updated' ],
 		},
 
 		'test' => {
@@ -866,6 +917,56 @@ our %submit_info = (
 	'x86_64_opensuse_11.3-updated'		=> 'x86_64_opensuse_11.3',
 	'x86_64_opensuse_11.4'				=> 'x86_64_opensuse_11.3',
 	'x86_64_opensuse_11.4-updated'		=> 'x86_64_opensuse_11.4',
+
+
+	##########################################################################
+	# Platform FreeBSD 7.4 on x86
+	##########################################################################
+	'x86_freebsd_7.4'		=> {
+		'build' => {
+			'configure_args' => { @minimal_build_configure_args,
+				'-DWITHOUT_SOAP_TEST:BOOL=ON' => undef,
+				'-DWITHOUT_AMAZON_TEST:BOOL=ON' => undef,
+				'-DENABLE_JAVA_TESTS:BOOL=OFF' => undef,
+				'-DWITH_CURL:BOOL=OFF' => undef,
+				'-DWITH_EXPAT:BOOL=ON' => undef,
+				'-DWITH_LIBVIRT:BOOL=OFF' => undef,
+				'-DWITH_LIBXML2:BOOL=ON' => undef,
+			},
+			'prereqs'	=> [ 'tar-1.14',
+							 'patch-2.6.1',
+							 'cmake-2.8.3',
+							 'flex-2.5.4a',
+							 'make-3.80',
+							 'byacc-1.9',
+							 'bison-1.25',
+							 'wget-1.9.1',
+							 'm4-1.4.1',
+				],
+			'xtests'	=> undef,
+		},
+
+		'test' => {
+			'configure_args' => {
+				@default_test_configure_args
+				
+			},
+			'prereqs'	=> [ 'tar-1.14',
+							 'patch-2.6.1',
+							 'cmake-2.8.3',
+							 'flex-2.5.4a',
+							 'make-3.80',
+							 'byacc-1.9',
+							 'bison-1.25',
+							 'wget-1.9.1',
+							 'm4-1.4.1',
+				],
+			'testclass'	=> [ @default_testclass ],
+		},
+	},
+	'x86_64_freebsd_7.4'		=> 'x86_freebsd_7.4',
+	'x86_freebsd_8.2'			=> 'x86_freebsd_7.4',
+	'x86_64_freebsd_8.2'		=> 'x86_freebsd_7.4',
 );
 
 while( 1 ) {
@@ -1132,3 +1233,8 @@ if (!defined($main::slaved_module)) {
 }
 
 1;
+
+### Local Variables: ***
+### mode:perl ***
+### tab-width: 4  ***
+### End: ***
diff --git a/src/classad/CHANGELOG b/src/classad/CHANGELOG
index e577a9e..f36b747 100644
--- a/src/classad/CHANGELOG
+++ b/src/classad/CHANGELOG
@@ -1,4 +1,4 @@
-Changes for version 1.0.10 (Released ????-??-??)
+Changes for version 1.0.10 (Released 2011-04-08)
 * Fix infinite loop and bad iterator comparison in FunctionCall::SameAs().
 * Fix memory leak in FunctionCall::eval().
 * Fix ClassAd::GetInternalReferences() and ClassAd::GetExternalReferences()
diff --git a/src/classad/CMakeLists.txt b/src/classad/CMakeLists.txt
index 293ecf4..daf0866 100644
--- a/src/classad/CMakeLists.txt
+++ b/src/classad/CMakeLists.txt
@@ -15,8 +15,9 @@
  # limitations under the License. 
  # 
  ############################################################### 
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
 
-add_definitions(-DCLASSAD_DISTRIBUTION -DWANT_CLASSAD_NAMESPACE=1 -DDISABLE_DLOPEN_CHECK )
+add_definitions(-DCLASSAD_DISTRIBUTION -DWANT_CLASSAD_NAMESPACE=1 )
 
 # disable PCRE build unless dep added to externals.
 if(PCRE_FOUND)
@@ -25,41 +26,70 @@ else()
 	add_definitions(-DUSE_POSIX_REGEX) 
 endif(PCRE_FOUND)
 
-# in order to update configure
+if (HAVE_DLOPEN)
+	add_definitions(-DHAVE_DLOPEN)
+endif()
+
+if (HAVE_DLFCN_H)
+	add_definitions(-DHAVE_DLFCN_H)
+endif(HAVE_DLFCN_H)
+
+if (HAVE_LIBDL)
+	set(DL_FOUND -ldl)
+endif(HAVE_LIBDL)
+
 if (NOT WINDOWS)
 
-  # because of the external dependencies on classads we need to be careful to make it look like a normal install
-  file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/classad DESTINATION ${EXTERNAL_STAGE}/include )
+  condor_selective_glob("attrrefs.*;classad.*;collection.*;collectionBase.*;debug.*;exprList.*;exprTree.*;fnCall.*;indexfile.*;lexer.*;lexerSource.*;literals.*;matchClassad.*;operators.*;query.*;sink.*;source.*;transaction.*;util.*;value.*;view.*;xmlLexer.*;xmlSink.*;xmlSource.*;cclassad.*;common.*" ClassadSrcs)
+  add_library( classads STATIC ${ClassadSrcs} )    # the one which all of condor depends upon
 
-  if (WANT_FULL_DEPLOYMENT)
-	install( DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/classad DESTINATION ${C_INCLUDE} )
+  if (LINUX)  
+  	add_library( classad SHARED ${ClassadSrcs} )   # for distribution at this point may swap to depend at a future date.
+	set_target_properties( classad PROPERTIES VERSION 1.1.0 SOVERSION 1 )
+	install( TARGETS classad DESTINATION ${C_LIB} )
   endif()
 
-  condor_selective_glob("attrrefs.*;classad.*;collection.*;collectionBase.*;debug.*;exprList.*;exprTree.*;fnCall.*;indexfile.*;lexer.*;lexerSource.*;literals.*;matchClassad.*;operators.*;query.*;sink.*;source.*;transaction.*;util.*;value.*;view.*;xmlLexer.*;xmlSink.*;xmlSource.*;cclassad.*;common.*" ClassadSrcs)
+  set (CLASSADS_FOUND classads)
 
-  add_library( classads STATIC ${ClassadSrcs} )
-  set_target_properties( classads
-	PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib 
-	LIBRARY_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib
-	RUNTIME_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib
-	OUTPUT_NAME classad_ns)
+  ###### Test executables
+  condor_exe_test( classad_unit_tester "classad_unit_tester.cpp" "${CLASSADS_FOUND};${PCRE_FOUND};${DL_FOUND}")
+  condor_exe( classad_functional_tester "classad_functional_tester.cpp" ${C_BIN} "${CLASSADS_FOUND};${PCRE_FOUND};${DL_FOUND}" OFF)
+  condor_exe( classad_version "classad_version.cpp" ${C_BIN} "${CLASSADS_FOUND};${PCRE_FOUND};${DL_FOUND}" OFF)
+  
+  ###### Install elements with our distribution
+  install( TARGETS classads DESTINATION ${C_LIB} )
+  install( DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/classad DESTINATION ${C_INCLUDE} )
 
 else()
 	
-	# I should probably just add all and subtract tests.
+	# windows specific configuration.
 	condor_selective_glob("attrrefs.cpp;common.cpp;collection*;fnCall.cpp;expr*;indexfile*;lexer*;literals.cpp;matchClassad.cpp;classad.cpp;debug.cpp;operators.cpp;util.cpp;value.cpp;query.cpp;sink.cpp;source.cpp;transaction.cpp;view.cpp;xml*" ClassadSrcs)
 	add_library( classads STATIC ${ClassadSrcs} )
 	set_property( TARGET classads PROPERTY FOLDER "libraries" )
+    set (CLASSADS_FOUND classads)
 
 endif()
 
-set( CLASSADS_FOUND classads )
+# standard output message used to slog users.  
+message (STATUS "configured (CLASSADS_FOUND= ${CLASSADS_FOUND})")
+append_var (CONDOR_EXTERNALS ${CLASSADS_FOUND})
+set( CLASSADS_FOUND ${CLASSADS_FOUND} PARENT_SCOPE )
+set( HAVE_EXT_CLASSADS ON PARENT_SCOPE )
 
+# finally add dependencies if there are any
 if (NOT PROPER)
-  add_dependencies( classads pcre )
+  add_dependencies( ${CLASSADS_FOUND} pcre )
+
+  if (NOT WINDOWS)
+  ############################################################################## 
+  # the only reason this exists is b/c our externals depend on it  
+  file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/classad DESTINATION ${EXTERNAL_STAGE}/include )
+  set_target_properties( classads
+	PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib 
+	LIBRARY_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib
+	RUNTIME_OUTPUT_DIRECTORY ${EXTERNAL_STAGE}/lib
+	OUTPUT_NAME classad)
+  endif()
+
 endif(NOT PROPER)
 
-message (STATUS "external configured (CLASSADS_FOUND=${CLASSADS_FOUND})")
-set( CLASSADS_FOUND ${CLASSADS_FOUND} PARENT_SCOPE )
-set( HAVE_EXT_CLASSADS ON PARENT_SCOPE )
-append_var (CONDOR_EXTERNALS classads)
diff --git a/src/classad/Doxyfile b/src/classad/Doxyfile
index 7d61a84..df632c4 100644
--- a/src/classad/Doxyfile
+++ b/src/classad/Doxyfile
@@ -31,7 +31,7 @@ PROJECT_NAME           = ClassAds
 # This could be handy for archiving the generated documentation or
 # if some version control system is used.
 
-PROJECT_NUMBER         = 1.0.9
+PROJECT_NUMBER         = 1.0.10
 
 # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
 # base path where the generated documentation will be put.
diff --git a/src/classad/Makefile.am.m4 b/src/classad/Makefile.am.m4
index 03121c8..b85cb17 100644
--- a/src/classad/Makefile.am.m4
+++ b/src/classad/Makefile.am.m4
@@ -152,8 +152,8 @@ libclassad_la_SOURCES = \
 	sink.cpp source.cpp transaction.cpp util.cpp value.cpp view.cpp xmlLexer.cpp	\
 	xmlSink.cpp xmlSource.cpp cclassad.cpp $(_libclassad_la_SOURCES)
 
-libclassad_la_LDFLAGS = -version-info 1:0:1
-libclassad_ns_la_LDFLAGS = -version-info 1:0:1
+libclassad_la_LDFLAGS = -version-info 1:2:0
+libclassad_ns_la_LDFLAGS = -version-info 1:2:0
 
 MF_IF_NAMESPACE([libclassad_ns_la_SOURCES = $(libclassad_la_SOURCES)
    libclassad_ns_la_CXXFLAGS = $(NAMESPACE)])
diff --git a/src/classad/README b/src/classad/README
index bce8cd7..0e81df6 100644
--- a/src/classad/README
+++ b/src/classad/README
@@ -1,4 +1,4 @@
-This is version 1.0.9 of the Condor Classad library, released on 2010-08-23.
+This is version 1.0.10 of the Condor Classad library, released on 2011-04-08.
 
 ===== What is it? =====
 
diff --git a/src/classad/README.packaging b/src/classad/README.packaging
index 7e107a7..9dd1c91 100644
--- a/src/classad/README.packaging
+++ b/src/classad/README.packaging
@@ -15,11 +15,15 @@ Update the shared library version number in src/classad/Makefile.am.m4.
 Look for these two lines:
     libclassad_la_LDFLAGS = -version-info 1:0:0
     libclassad_ns_la_LDFLAGS = -version-info 1:0:0
-If the ABI has changed, you should increment the first number and set the 
-second and third ones to zero. If the ABI hasn't changed, then increment 
-the second or third number. See 
+
+If the ABI has changed (such that programs linked against an older 
+version won't work with the new version), you should increment the first 
+number and set the second and third ones to zero. If the ABI has only been 
+expanded (new symbols added), increment the first and third numbers, and 
+set the second one to zero. If the ABI hasn't changed, then increment the 
+second number. See 
 http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html#AEN135  
-for examples of things that will change the ABI.
+for examples of things that will change the ABI incompatibly.
 This ABI compliance checker program may be useful: 
 http://ispras.linuxfoundation.org/index.php/ABI_compliance_checker
 
diff --git a/src/classad/TAGS b/src/classad/TAGS
index 659cb34..a0db662 100644
--- a/src/classad/TAGS
+++ b/src/classad/TAGS
@@ -14,3 +14,4 @@ classads_1_0_6
 classads_1_0_7
 classads_1_0_8
 classads_1_0_9
+classads_1_0_10
diff --git a/src/classad/classad.cpp b/src/classad/classad.cpp
index dfb0435..f78ecc7 100644
--- a/src/classad/classad.cpp
+++ b/src/classad/classad.cpp
@@ -44,13 +44,13 @@ void ClassAdLibraryVersion(int &major, int &minor, int &patch)
 {
     major = 1;
     minor = 0;
-    patch = 9;
+    patch = 10;
     return;
 }
 
 void ClassAdLibraryVersion(string &version_string)
 {
-    version_string = "1.0.9";
+    version_string = "1.0.10";
     return;
 }
 
@@ -968,7 +968,15 @@ _GetExternalReferences( const ExprTree *expr, ClassAd *ad,
                         refs.insert( fullName );
                         return true;
                     } else {
-                        return( _GetExternalReferences( tree, ad, state, refs, fullNames ));
+                        if( state.depth_remaining <= 0 ) {
+                            return false;
+                        }
+                        state.depth_remaining--;
+
+                        bool ret = _GetExternalReferences( tree, ad, state, refs, fullNames );
+
+                        state.depth_remaining++;
+                        return ret;
                     }
                 }
                     // otherwise, if the tree didn't evaluate to a classad,
@@ -992,7 +1000,15 @@ _GetExternalReferences( const ExprTree *expr, ClassAd *ad,
 
                 case EVAL_OK: {
                         // attr is internal; find external refs in result
-					bool rval=_GetExternalReferences(result,ad,state,refs,fullNames);
+                    if( state.depth_remaining <= 0 ) {
+                        state.curAd = curAd;
+                        return false;
+                    }
+                    state.depth_remaining--;
+
+                    bool rval=_GetExternalReferences(result,ad,state,refs,fullNames);
+
+                    state.depth_remaining++;
 					state.curAd = curAd;
 					return( rval );
 				}
@@ -1043,7 +1059,15 @@ _GetExternalReferences( const ExprTree *expr, ClassAd *ad,
 
             ((const ClassAd*)expr)->GetComponents( attrs );
             for( itr = attrs.begin( ); itr != attrs.end( ); itr++ ) {
-                if( !_GetExternalReferences( itr->second, ad, state, refs, fullNames )) {
+                if( state.depth_remaining <= 0 ) {
+                    return false;
+                }
+                state.depth_remaining--;
+
+                bool ret = _GetExternalReferences( itr->second, ad, state, refs, fullNames );
+
+                state.depth_remaining++;
+                if( !ret ) {
 					return( false );
 				}
             }
@@ -1058,7 +1082,15 @@ _GetExternalReferences( const ExprTree *expr, ClassAd *ad,
 
             ((const ExprList*)expr)->GetComponents( exprs );
             for( itr = exprs.begin( ); itr != exprs.end( ); itr++ ) {
-                if( !_GetExternalReferences( *itr, ad, state, refs, fullNames ) ) {
+                if( state.depth_remaining <= 0 ) {
+                    return false;
+                }
+                state.depth_remaining--;
+
+                bool ret = _GetExternalReferences( *itr, ad, state, refs, fullNames );
+
+                state.depth_remaining++;
+                if( !ret ) {
 					return( false );
 				}
             }
@@ -1342,7 +1374,15 @@ _GetInternalReferences( const ExprTree *expr, ClassAd *ad,
                 case EVAL_OK:   {
                     //whoo, it's internal.
                     refs.insert(attr);
+                    if( state.depth_remaining <= 0 ) {
+                        state.curAd = curAd;
+                        return false;
+                    }
+                    state.depth_remaining--;
+
                     bool rval =_GetInternalReferences(result, ad, state, refs, fullNames);
+
+                    state.depth_remaining++;
                     //TODO: Does this actually matter?
                     state.curAd = curAd;
                     return rval;
@@ -1405,7 +1445,15 @@ _GetInternalReferences( const ExprTree *expr, ClassAd *ad,
 
             ((const ClassAd*)expr)->GetComponents(attrs);
             for(itr = attrs.begin(); itr != attrs.end(); itr++){
-                if( !_GetInternalReferences(itr->second, ad, state, refs, fullNames)) {
+                if( state.depth_remaining <= 0 ) {
+                    return false;
+                }
+                state.depth_remaining--;
+
+                bool ret = _GetInternalReferences(itr->second, ad, state, refs, fullNames);
+
+                state.depth_remaining++;
+                if( !ret ) {
                     return false;
                 }
             }
@@ -1420,7 +1468,15 @@ _GetInternalReferences( const ExprTree *expr, ClassAd *ad,
 
             ((const ExprList*)expr)->GetComponents(exprs);
             for(itr = exprs.begin(); itr != exprs.end(); itr++){
-                if( !_GetInternalReferences(*itr, ad, state, refs, fullNames) ) {
+                if( state.depth_remaining <= 0 ) {
+                    return false;
+                }
+                state.depth_remaining--;
+
+                bool ret = _GetInternalReferences(*itr, ad, state, refs, fullNames);
+
+                state.depth_remaining++;
+                if( !ret ) {
                     return false;
                 }
             }
diff --git a/src/classad/classad/common.h b/src/classad/classad/common.h
index f62a65c..660558b 100644
--- a/src/classad/classad/common.h
+++ b/src/classad/classad/common.h
@@ -48,6 +48,10 @@
 #define _STLP_NEW_PLATFORM_SDK
 #define _STLP_NO_OWN_IOSTREAMS 1
 
+// Disable warnings about calling posix functions like open()
+// instead of _open()
+#define _CRT_NONSTDC_NO_WARNINGS
+
 // Disable warnings about possible loss of data, since "we know what
 // we are doing" and fixing them correctly would require too much 
 // time from one of us. (Maybe this should be a student exercise.)
@@ -71,6 +75,7 @@
 
 
 #ifdef WIN32
+
 	// special definitions we need for Windows
 #ifndef DLL_IMPORT_MAGIC
 #define DLL_IMPORT_MAGIC __declspec(dllimport)
@@ -79,9 +84,6 @@
 #include <float.h>
 #include <io.h>
 #define fsync _commit
-#ifndef open
-#define open _open
-#endif
 #define strcasecmp _stricmp
 #ifndef rint
 #define rint(num) floor(num + .5)
@@ -89,9 +91,7 @@
 #define isnan _isnan
 	// isinf() defined in util.h
 
-#ifdef WIN32
 #include <hash_map>
-#endif
 
 #define snprintf _snprintf
 
@@ -102,6 +102,7 @@
 #pragma warning( disable : 4800 )  
 	// Disable warnings about truncated debug identifiers
 #pragma warning( disable : 4786 )
+
 #endif // WIN32
 
 
diff --git a/src/classad/classad_functional_tester.cpp b/src/classad/classad_functional_tester.cpp
index 12305cf..84d7cb6 100644
--- a/src/classad/classad_functional_tester.cpp
+++ b/src/classad/classad_functional_tester.cpp
@@ -21,7 +21,6 @@
 #include "classad/classad_distribution.h"
 #include "classad/lexerSource.h"
 #include "classad/xmlSink.h"
-#undef open // we don't want the open method of basic_ofstream to end up being called _open...
 #include <fstream>
 #include <iostream>
 #include <ctype.h>
diff --git a/src/classad/do_packaging b/src/classad/do_packaging
index 197ec6b..531c7dd 100755
--- a/src/classad/do_packaging
+++ b/src/classad/do_packaging
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-DIST_VERSION=1.0.9
+DIST_VERSION=1.0.10
 DISTRIBUTION_DIR=classads-${DIST_VERSION}
 
 EXCLUDE_LIST="do_packaging CMakeLists.txt README.packaging TAGS TODO man_cache_test.cpp test_classads.cpp"
diff --git a/src/classad/lexerSource.cpp b/src/classad/lexerSource.cpp
index bb08f9e..1cbc450 100644
--- a/src/classad/lexerSource.cpp
+++ b/src/classad/lexerSource.cpp
@@ -112,7 +112,7 @@ InputStreamLexerSource::ReadCharacter(void)
 	char real_character;
 	int  character;
 
-	if (_stream != NULL && !_stream->eof()) {
+	if (_stream != NULL && _stream->good()) {
 		_stream->get(real_character);
 		character = (unsigned char)real_character;
 	} else {
diff --git a/src/classad/util.cpp b/src/classad/util.cpp
index 2e06049..7f1f981 100644
--- a/src/classad/util.cpp
+++ b/src/classad/util.cpp
@@ -200,7 +200,7 @@ void convert_escapes(string &text, bool &validStr)
 						sscanf(octal, "%o", &number);
 						new_char = number;
 					} else {
-						new_char = text[source];
+						number = new_char = text[source];
 					}
 					if(number == 0) { // "\\0" is an invalid substring within a string literal
 					  validStr = false;
diff --git a/src/classad_analysis/boolExpr.cpp b/src/classad_analysis/boolExpr.cpp
index e08ecb4..fc4332b 100644
--- a/src/classad_analysis/boolExpr.cpp
+++ b/src/classad_analysis/boolExpr.cpp
@@ -67,7 +67,9 @@ ExprToMultiProfile( classad::ExprTree *expr, MultiProfile *&mp )
 
 		kind = currentTree->GetKind( );
 			
-		if( kind == classad::ExprTree::ATTRREF_NODE ) {
+		if( kind == classad::ExprTree::ATTRREF_NODE ||
+			kind == classad::ExprTree::FN_CALL_NODE )
+		{
 			atLeftMostProfile = true;
 			continue;
 		}
@@ -172,7 +174,9 @@ ExprToProfile( classad::ExprTree *expr, Profile *&p )
 
 		kind = currentTree->GetKind( );
 
-		if( kind == classad::ExprTree::ATTRREF_NODE ) {
+		if( kind == classad::ExprTree::ATTRREF_NODE ||
+			kind == classad::ExprTree::FN_CALL_NODE )
+		{
 			atLeftMostCondition = true;
 			continue;
 		}
@@ -269,6 +273,14 @@ ExprToCondition( classad::ExprTree *expr, Condition *&c )
 		return true;
 	}
 
+	if( kind == classad::ExprTree::FN_CALL_NODE ) {
+		if( !c->InitComplex( expr->Copy( ) ) ) {
+  				cerr << "error: problem with Condition::InitComplex" << endl;
+  				return false;
+		}
+		return true;
+	}
+
 	if( kind != classad::ExprTree::OP_NODE ) {
 		cerr << "error: no operator/attribute found" << endl;
 			// error: no operator/attribute  found;
diff --git a/src/condor_c-gahp/cgahp_common.cpp b/src/condor_c-gahp/cgahp_common.cpp
index b9f9c46..a13430f 100644
--- a/src/condor_c-gahp/cgahp_common.cpp
+++ b/src/condor_c-gahp/cgahp_common.cpp
@@ -36,6 +36,8 @@ parse_gahp_command (const char* raw, Gahp_Args* args) {
 	int len=strlen(raw);
 
 	char * buff = (char*)malloc(len+1);
+    ASSERT(buff);
+
 	int buff_len = 0;
 
 	for (int i = 0; i<len; i++) {
diff --git a/src/condor_ckpt/CMakeLists.txt b/src/condor_ckpt/CMakeLists.txt
index 9aab726..2b2ef62 100644
--- a/src/condor_ckpt/CMakeLists.txt
+++ b/src/condor_ckpt/CMakeLists.txt
@@ -37,18 +37,19 @@ if( STD_UNIVERSE )
 	###########################################################################
 	add_definitions( ${STD_U_C_FLAGS} -DFILE_TABLE -DIN_CKPT_LIB)
 	include_directories(${CONDOR_SOURCE_DIR}/src/condor_ckpt)
-	condor_selective_glob("*file*;signals*;image*;machdep.LINUX.cpp;tmp_*;syscall_*;fake_*;condor_error*;eprintf*;shared_*;malloc-user*;gto*;maps*" CommonCkptSrcs )
-
-	# from what I can tell this doesn't even work.
-	#if (DOES_COMPRESS_CKPT)
-	#	add_definitions(-DCOMPRESS_CKPT -DMORECORE=condor_morecore -DHAVE_MMAP=0 -Dmalloc_getpagesize=8192)
-	#	condor_selective_glob("malloc-condor.cpp;malloc.cpp" CompressSrcs)
-	#endif(DOES_COMPRESS_CKPT)
+	condor_selective_glob("*file*;signals*;machdep.LINUX.cpp;tmp_*;syscall_*;fake_*;condor_error*;eprintf*;shared_*;malloc-user*;gto*;maps*" CommonCkptSrcs )
 
 	# we create a local lib, but it's never actually used
 	# instead condorsyscall will rip out the target refs.
 	#condor_static_lib( ckpt "${CommonCkptSrcs};${CompressSrcs}")
-	add_library(ckpt STATIC EXCLUDE_FROM_ALL ${CommonCkptSrcs};${CompressSrcs})
+	add_library(ckpt STATIC EXCLUDE_FROM_ALL ${CMAKE_CURRENT_SOURCE_DIR}/image.cpp;${CommonCkptSrcs})
 	add_dependencies( ckpt syscall_numbers )
 
+	if (DOES_COMPRESS_CKPT)
+
+		add_library(zckpt STATIC EXCLUDE_FROM_ALL ${CMAKE_CURRENT_SOURCE_DIR}/zimage.cpp;${CMAKE_CURRENT_SOURCE_DIR}/malloc-condor.c;${CommonCkptSrcs})
+
+		add_dependencies( zckpt syscall_numbers )
+	endif(DOES_COMPRESS_CKPT)
+
 endif(STD_UNIVERSE)
diff --git a/src/condor_ckpt/image.cpp b/src/condor_ckpt/image.cpp
index c7cc873..39817f4 100644
--- a/src/condor_ckpt/image.cpp
+++ b/src/condor_ckpt/image.cpp
@@ -32,6 +32,19 @@
 #include "subsystem_info.h"
 #include "gtodc.h"
 
+#if defined(COMPRESS_CKPT)
+/* This structure represents an alternate heap, controlled by a specially
+	created malloc, and used by zlib for the checkpoint compression feature.
+*/
+struct alternate_memory_heap {
+	void *begin;
+	void *corestart;
+	void **coreend;
+	void **segend;
+	int pagesize;
+};
+#endif
+
 extern int _condor_in_file_stream;
 
 const int KILO = 1024;
@@ -49,6 +62,8 @@ extern "C" void _condor_restore_sigstates();
 #if defined(COMPRESS_CKPT)
 #include "zlib.h"
 extern "C" {
+	void display_alternate_memory_heap(int dlevel);
+	int condor_malloc_getpagesize(void); // in malloc-condor.c
 	int condor_malloc_init_size();
 	void condor_malloc_init(void *start);
 	char *condor_malloc(size_t);
@@ -85,6 +100,7 @@ extern "C" void _install_signal_handler( int sig, SIG_HANDLER handler );
 extern "C" int open_ckpt_file( const char *name, int flags, size_t n_bytes );
 extern "C" int get_ckpt_mode( int sig );
 extern "C" int get_ckpt_speed( );
+static void sleep_syscall(int seconds);
 
 Image MyImage;
 static jmp_buf Env;
@@ -98,6 +114,13 @@ unsigned int _condor_numrestarts = 0;
 int condor_compress_ckpt = 1; // compression off(0) or on(1)
 int condor_slow_ckpt = 0;
 
+#if defined(COMPRESS_CKPT)
+// There is only ONE alternate heap. This global variable gets saved and
+// restored across checkpoints. This means that the mmap'ed heap during
+// checkpoint will be known to be put into the right place upon restore.
+static struct alternate_memory_heap amh = { NULL, NULL, NULL, NULL, -1 };
+#endif
+
 /* these are the remote system calls we use in this file */
 extern "C" int REMOTE_CONDOR_send_rusage(struct rusage *use_p);
 
@@ -148,71 +171,225 @@ void *condor_map_seg(void *base, size_t size)
 	return base;
 }
 
+void display_alternate_memory_heap(int dlevel)
+{
+	dprintf(dlevel,
+		"Alternate Memory Heap: {begin=%p, corestart=%p, coreend=%p, segend=%p, *coreend=%p, *segend=%p, pagesize=%d}\n",
+		amh.begin, amh.corestart, amh.coreend, amh.segend, 
+		amh.coreend!=NULL?*amh.coreend:NULL,
+		amh.segend!=NULL?*amh.segend:NULL,
+		amh.pagesize);
+}
+
 // TODO: deallocate segments on negative incr
 void *condor_morecore(int incr)
 {
-	// begin points to the start of our heap segment
-	// corestart points to the start of the allocated portion of the segment
-	// *coreend points to the end of the allocated portion of the segment
-	// *segend points to the end of our allocated segment
-	// coreend and segend are stored at the start of the segment because
+	// amh.begin points to the start of our heap segment
+	// amh.corestart points to the start of the allocated portion of the segment
+	// *amh.coreend points to the end of the allocated portion of the segment
+	// *amh.segend points to the end of our allocated segment
+	// amh.coreend and segend are stored at the start of the segment because
 	//   we don't want them to be overwritten on a restart
-	static void *begin = NULL, *corestart = NULL,
-		**coreend = NULL, **segend = NULL;
-	static int pagesize = -1;
 
-	if (pagesize == -1) {
-		pagesize = getpagesize();
+	if (amh.pagesize == -1) {
+		// This is the page size of the alternate heap allocator, NOT the
+		// regular allocator used by the application. The two allocators
+		// can sometimes have different sizes and we don't want to confuse
+		// the two.
+		amh.pagesize = condor_malloc_getpagesize();
 	}
-	
-	if (begin == NULL) {
-		begin = MyImage.FindAltHeap();
+
+	if (amh.begin == NULL) {
+		amh.begin = MyImage.FindAltHeap();
 		int malloc_static_data = condor_malloc_init_size();
 		int segincr =
 			(((incr+malloc_static_data+
-			   (2*sizeof(void *)))/pagesize)+1)*pagesize;
-		begin = condor_map_seg(begin, segincr);
-		corestart = (void *) (
-			(int)begin+(int)(2*sizeof(void *))+(int)malloc_static_data ); 
-		condor_malloc_init((void *)((int)begin+(int)(2*sizeof(void *))));
-		coreend = (void **)begin;
-		segend = (void **)((int)begin+(int)sizeof(void *));
-		*segend = (void *)((int)begin+(int)segincr);
-		*coreend = (void *)((int)corestart+(int)incr);
-		return corestart;
+			   (2*sizeof(void *)))/amh.pagesize)+1)*amh.pagesize;
+		amh.begin = condor_map_seg(amh.begin, segincr);
+		amh.corestart = (void *) (
+			(int)amh.begin+(int)(2*sizeof(void *))+(int)malloc_static_data ); 
+		condor_malloc_init((void *)((int)amh.begin+(int)(2*sizeof(void *))));
+		amh.coreend = (void **)amh.begin;
+		amh.segend = (void **)((int)amh.begin+(int)sizeof(void *));
+		*amh.segend = (void *)((int)amh.begin+(int)segincr);
+		*amh.coreend = (void *)((int)amh.corestart+(int)incr);
+		return amh.corestart;
 	} else if (incr == 0) {
-		return *coreend;
+		return *amh.coreend;
 	} else {
-		void *old_break = *coreend;
-		*coreend = (void *)((int)*coreend + (int)incr);
-		if (*coreend > *segend) {
-			int segincr = (int)((((int)*coreend-(int)*segend)/(int)pagesize)+1)*(int)pagesize;
-			if ((int)*coreend+(int)segincr-(int)begin > ALT_HEAP_SIZE) {
+		void *old_break = *amh.coreend;
+		*amh.coreend = (void *)((int)*amh.coreend + (int)incr);
+		if (*amh.coreend > *amh.segend) {
+			int segincr = (int)((((int)*amh.coreend-(int)*amh.segend)/(int)amh.pagesize)+1)*(int)amh.pagesize;
+			if ((int)*amh.coreend+(int)segincr-(int)amh.begin > ALT_HEAP_SIZE) {
 				dprintf(D_ALWAYS,
 						"fatal error: exceeded ALT_HEAP_SIZE of %d bytes!\n",
 						ALT_HEAP_SIZE);
 				Suicide();
 			}
-			if (condor_map_seg(*segend, segincr) != *segend) {
+			if (condor_map_seg(*amh.segend, segincr) != *amh.segend) {
 				dprintf(D_ALWAYS, "failed to allocate contiguous segments in "
 						"condor_morecore!\n");
 				Suicide();
 			}
-			*segend = (void *)((int)*segend + (int)segincr);
+			*amh.segend = (void *)((int)*amh.segend + (int)segincr);
 		}
 		return old_break;
 	}
 }
 
 void *
-zalloc(voidpf opaque, uInt items, uInt size)
+zalloc(voidpf /* opaque */, uInt items, uInt size)
 {
-	return condor_malloc(items*size);
+	uInt total_size = 0;
+	void *chunk = NULL;
+	void *chunk_start = NULL;
+	void *chunk_end = NULL;
+
+	// Get the requested memory from the alternate heap. This may initialize
+	// the alternate heap based upon condor_morecore(). 
+	total_size = items * size;
+	chunk = condor_malloc(total_size);
+
+	// some useful pointers for later checks and messages.
+	chunk_start = chunk;
+	chunk_end = (char*)chunk + total_size;
+
+	// Check to make sure alternate heap was and still is initialized.
+	if (amh.begin == NULL ||
+		amh.corestart == NULL ||
+		amh.coreend == NULL ||
+		*amh.coreend == NULL ||
+		amh.segend == NULL ||
+		*amh.segend == NULL ||
+		amh.pagesize != condor_malloc_getpagesize())
+	{
+		dprintf(D_ALWAYS, 
+			"ERROR: The alternate heap has not been initialized properly. "
+			"Please check to see that MORECORE had been defined properly "
+			"when compiling malloc-condor.c. Committing Suicide()!\n");
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check to see that the memory we got back from the allocator is
+	// _completely contained_ in the alternate heap. We do this because if
+	// somehow condor_malloc() actually called sbrk() instead of
+	// condor_morecore(), we'd silently corrupt the checkpoint image and
+	// subsequent checkpoint. We take great care to examine how it fails 
+	// since that can lead to insight into what is going wrong.
+
+	// Check if chunk starts before the alt heap and ends after the alt heap
+	if (chunk_start < amh.corestart && chunk_end >= *amh.coreend) 
+	{
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which _completely_ overlaps the alternate heap boundaries "
+			"of [%p, %p]. "
+			"Check to see if MORECORE is defined properly when "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check if the entire chunk is below the alternate heap.
+	if (chunk_end < amh.corestart) {
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which is below the valid alternate heap boundaries of [%p, %p]. "
+			"Check to see if MORECORE is defined properly when "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check if the entire chunk is above the alternate heap.
+	if (chunk_start > *amh.coreend) {
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which is above the valid alternate heap boundaries of [%p, %p]. "
+			"Check to see if MORECORE is defined properly when "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check if the chunk overlaps the lower boundary of the alt heap.
+	if (chunk_start < amh.corestart && chunk_end >= amh.corestart)
+	{
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which overlaps the start alternate heap boundaries of [%p, %p]. "
+			"Check to see if MORECORE is defined properly when "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// Check if the chunk overlaps the upper boundary of the alt heap.
+	if (chunk_start >= amh.corestart && 
+		chunk_start < *amh.coreend &&
+		chunk_end >= *amh.coreend)
+	{
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator allocated chunk "
+			"[start=%p, end=%p, size=%d bytes] "
+			"which overlaps the end alternate heap boundaries of [%p, %p]. "
+			"compiling malloc-condor.c! Commiting Suicide()!\n",
+			chunk_start, chunk_end, total_size,
+			amh.corestart, amh.coreend!=NULL?*amh.coreend:NULL);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	// If we passed the validation gauntlet, we're good to go!
+	return chunk;
 }
 
 void
-zfree(voidpf opaque, voidpf address)
+zfree(voidpf /* opaque */ , voidpf address)
 {
+	// Check to see that the pointer we are about to free actually exists IN
+	// the alternate heap. We do this because if somehow we pass pointers from
+	// the real malloc heap to here, we could silently corrupt or segfault in
+	// either heap.
+
+	if (address < amh.corestart) {
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator asked to free a pointer %p from "
+			"below the alternate heap! Check to see if MORECORE is defined "
+			"properly when compiling malloc-condor.c! Also check that a real "
+			"heap pointer isn't being passed to the alternate heap free "
+			"function! Commiting Suicide()!\n",
+			address);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
+	if (address >= *amh.coreend) {
+		dprintf(D_ALWAYS, 
+			"ERROR: Alternate heap allocator asked to free a pointer %p from "
+			"above the alternate heap! Check to see if MORECORE is defined "
+			"properly when compiling malloc-condor.c! Also check that a real "
+			"heap pointer isn't being passed to the alternate heap free "
+			"function! Commiting Suicide()!\n",
+			address);
+		display_alternate_memory_heap(D_ALWAYS);
+		Suicide();
+	}
+
 	condor_free(address);
 }
 #endif
@@ -1871,6 +2048,33 @@ void ckpt_and_exit__()
 
 }   /* end of extern "C" */
 
+/* this bypasses our need for libc */
+void sleep_syscall(int seconds)
+{
+
+#if defined(SYS_sleep)
+	SYSCALL(SYS_sleep, seconds);
+#elif defined(SYS__newselect)
+	struct timeval t;
+	t.tv_sec = seconds;
+	t.tv_usec = 0;
+	SYSCALL(SYS__newselect, 0, NULL, NULL, NULL, &t);
+#elif defined(SYS_select)
+	struct timeval t;
+	t.tv_sec = seconds;
+	t.tv_usec = 0;
+	SYSCALL(SYS_select, 0, NULL, NULL, NULL, &t);
+#elif defined(SYS_nanosleep)
+	struct timespec t;
+	t.tv_sec = seconds;
+	t.tv_nsec = 0;
+	SYSCALL(SYS_nanosleep, &t, NULL);
+#else
+#error "Please port me!  I need a sleep system call."
+#endif
+
+}
+
 /*
   Arrange to terminate abnormally with the given signal.  Note: the
   expectation is that the signal is one whose default action terminates
@@ -1918,26 +2122,7 @@ terminate_with_sig( int sig )
 	// our debug message doesn't arrive at the shadow, we won't know why
 	// the job died.  Note that we don't necessarily have access to any
 	// libc functions here, so we must use SYSCALL(SYS_something, ...).
-#if defined(SYS_sleep)
-	SYSCALL(SYS_sleep, 1);
-#elif defined(SYS__newselect)
-	struct timeval t;
-	t.tv_sec = 1;
-	t.tv_usec = 0;
-	SYSCALL(SYS__newselect, 0, NULL, NULL, NULL, &t);
-#elif defined(SYS_select)
-	struct timeval t;
-	t.tv_sec = 1;
-	t.tv_usec = 0;
-	SYSCALL(SYS_select, 0, NULL, NULL, NULL, &t);
-#elif defined(SYS_nanosleep)
-	struct timespec t;
-	t.tv_sec = 1;
-	t.tv_nsec = 0;
-	SYSCALL(SYS_nanosleep, &t, NULL);
-#else
-#error "Please port me!  I need a sleep system call."
-#endif
+	sleep_syscall(1);
 
 	if( SYSCALL(SYS_kill, my_pid, sig) < 0 ) {
 		EXCEPT( "kill" );
diff --git a/src/condor_ckpt/malloc-condor.c b/src/condor_ckpt/malloc-condor.c
index 946617c..973eac2 100644
--- a/src/condor_ckpt/malloc-condor.c
+++ b/src/condor_ckpt/malloc-condor.c
@@ -17,15 +17,47 @@
  *
  ***************************************************************/
 
+/* This file sets up some definitions in order to create a private malloc
+	implementation suitable for use by the checkpointing library to make a
+	private heap.  This is *not* the malloc called by ordinary user code.
+	Its use is primarily by zlib when it compressed/uncompresses checkpoints.
+	The privacy is enforced at the symbol namespace level via the
+	MALLOC_SYMBOL #define that is part of the malloc.c interface.
+*/
+
+
+/* First we check to make sure we're being compiled properly.
+	Traditionally, you can use the values:
+	-DMORECORE=condor_morecore
+	-DHAVE_MMAP=0
+	-Dmalloc_getpagesize=8192
+
+	The first states to use the function condor_morecore() instead of sbrk().
+	The second states that MORECORE should *always* be called instead of mmap().
+	The third dictates how big the pages are wrt to the allocator.
+*/
+#if !defined(MORECORE) || !defined(HAVE_MMAP) || !defined(malloc_getpagesize)
+#error You should be defining MORECORE, HAVE_MMAP, and malloc_getpagesize on the compilation line for this file!
+#endif
 
-/*
-This file sets up some definitions in order
-to create a private malloc implementation suitable
-for use by the checkpointing library to make 
-a private heap.  This is *not* the malloc called
-by ordinary user code.
+/* give a prototype of the morecore function for the allocator */
+extern void* MORECORE(int);
+
+/* We use this function to figure out whatever the pagesize was that we told
+	the allocator to use. This allows up to later compute the correct size
+	of our alternate heap. The prototype is in image.cpp.
 */
+int condor_malloc_getpagesize(void)
+{
+	return malloc_getpagesize;
+}
 
+/* Change all usual malloc calls to be prefixed with condor_. The ckpt
+	library uses this new interface when performing compressed checkpoints.
+*/
 #define MALLOC_SYMBOL(x) condor_##x
 
 #include "malloc.c"
+
+
+
diff --git a/src/condor_ckpt/zimage.cpp b/src/condor_ckpt/zimage.cpp
new file mode 100644
index 0000000..5dede3c
--- /dev/null
+++ b/src/condor_ckpt/zimage.cpp
@@ -0,0 +1,22 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#define COMPRESS_CKPT
+
+#include "image.cpp"
diff --git a/src/condor_contrib/aviary/CMakeLists.txt b/src/condor_contrib/aviary/CMakeLists.txt
new file mode 100644
index 0000000..71baf72
--- /dev/null
+++ b/src/condor_contrib/aviary/CMakeLists.txt
@@ -0,0 +1,28 @@
+ ###############################################################
+ # 
+ # Copyright (C) 2009-2011, Red Hat, Inc.
+ # 
+ # Licensed under the Apache License, Version 2.0 (the "License"); you 
+ # may not use this file except in compliance with the License.  You may 
+ # obtain a copy of the License at 
+ # 
+ #    http://www.apache.org/licenses/LICENSE-2.0 
+ # 
+ # Unless required by applicable law or agreed to in writing, software 
+ # distributed under the License is distributed on an "AS IS" BASIS, 
+ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ # See the License for the specific language governing permissions and 
+ # limitations under the License. 
+ # 
+ ############################################################### 
+
+if (LINUX)
+	option(WITH_AVIARY "Support for aviary SOAP plugins" ON)
+endif()
+
+if ( WITH_AVIARY AND HAVE_EXT_WSO2 )
+ 
+ include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/src ${CMAKE_CURRENT_BINARY_DIR}/src ${CMAKE_CURRENT_SOURCE_DIR}/include ${WSO2_INCLUDES})
+ add_subdirectory( ${CMAKE_CURRENT_SOURCE_DIR}/src )
+
+endif()
\ No newline at end of file
diff --git a/src/condor_contrib/aviary/README b/src/condor_contrib/aviary/README
new file mode 100644
index 0000000..400943b
--- /dev/null
+++ b/src/condor_contrib/aviary/README
@@ -0,0 +1,2 @@
+Aviary - Simplified RPC Interface for Condor
+--------------------------------------------
diff --git a/src/condor_contrib/aviary/author.txt b/src/condor_contrib/aviary/author.txt
new file mode 100644
index 0000000..7b62f15
--- /dev/null
+++ b/src/condor_contrib/aviary/author.txt
@@ -0,0 +1,3 @@
+author: Peter MacKinnon
+organization: Red Hat Inc.
+e-mail: pmackinn@redhat.com
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ArchType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ArchType.cpp
new file mode 100644
index 0000000..deb2802
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ArchType.cpp
@@ -0,0 +1,354 @@
+
+
+        /**
+         * ArchType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ArchType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the ArchType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::ArchType::ArchType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_ArchType;
+                
+            isValidArchType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ArchType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::ArchType::ArchType(std::string arg_ArchType)
+        {
+             
+                   qname = NULL;
+             
+                 property_ArchType;
+             
+            isValidArchType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ArchType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ArchType = arg_ArchType;
+            
+        }
+        AviaryCommon::ArchType::~ArchType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            ArchType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setArchType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::ArchType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element ArchType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ArchType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ArchType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::ArchType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_ArchType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_ArchType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ArchType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ArchType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::ArchType::getProperty1()
+            {
+                return getArchType();
+            }
+
+            /**
+             * getter for ArchType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ArchType::getArchType()
+             {
+                return property_ArchType;
+             }
+
+            /**
+             * setter for ArchType
+             */
+            bool WSF_CALL
+            AviaryCommon::ArchType::setArchType(
+                    const std::string  arg_ArchType)
+             {
+                
+
+                if(isValidArchType &&
+                        arg_ArchType == property_ArchType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_ArchType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ArchType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetArchType();
+
+                
+                        property_ArchType = std::string(arg_ArchType.c_str());
+                        isValidArchType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for ArchType.
+             */
+             ADBArchTypeEnum WSF_CALL
+             AviaryCommon::ArchType::getArchTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_ArchType.c_str(), "INTEL") == 0)
+                    return ArchType_INTEL;
+             
+                 if (axutil_strcmp(property_ArchType.c_str(), "X86_64") == 0)
+                    return ArchType_X86_64;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBArchTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for ArchType.
+             */
+             bool WSF_CALL
+            AviaryCommon::ArchType::setArchTypeEnum(const ADBArchTypeEnum  arg_ArchType)
+             {
+                
+
+                
+                resetArchType();
+
+                   
+                   switch (arg_ArchType)
+                   {
+                     
+                       case ArchType_INTEL :
+                            property_ArchType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "INTEL");
+                          break;
+                     
+                       case ArchType_X86_64 :
+                            property_ArchType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "X86_64");
+                          break;
+                     
+                     
+                       default:
+                          isValidArchType = false;
+                          property_ArchType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting ArchType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_ArchType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidArchType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for ArchType
+            */
+           bool WSF_CALL
+           AviaryCommon::ArchType::resetArchType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidArchType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ArchType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ArchType::isArchTypeNil()
+           {
+               return !isValidArchType;
+           }
+
+           /**
+            * Set ArchType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ArchType::setArchTypeNil()
+           {
+               return resetArchType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attribute.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attribute.cpp
new file mode 100644
index 0000000..1047122
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attribute.cpp
@@ -0,0 +1,1022 @@
+
+
+        /**
+         * Attribute.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_Attribute.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = Attribute
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::Attribute::Attribute()
+        {
+
+        
+                    property_Name;
+                
+            isValidName  = false;
+        
+                property_Type  = NULL;
+              
+            isValidType  = false;
+        
+                    property_Value;
+                
+            isValidValue  = false;
+        
+        }
+
+       AviaryCommon::Attribute::Attribute(std::string arg_Name,AviaryCommon::AttributeType* arg_Type,std::string arg_Value)
+        {
+             
+                 property_Name;
+             
+            isValidName  = true;
+            
+               property_Type  = NULL;
+             
+            isValidType  = true;
+            
+                 property_Value;
+             
+            isValidValue  = true;
+            
+                    property_Name = arg_Name;
+            
+                    property_Type = arg_Type;
+            
+                    property_Value = arg_Value;
+            
+        }
+        AviaryCommon::Attribute::~Attribute()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::Attribute::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building name element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setName(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setName("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element name missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building type element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::AttributeType* element = new AviaryCommon::AttributeType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element type");
+                                      }
+                                      else
+                                      {
+                                          status = setType(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building value element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "value", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setValue(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element value");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setValue("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for value ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element value missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::Attribute::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::Attribute::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::Attribute::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t *text_value_1;
+                    axis2_char_t *text_value_1_temp;
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidName)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property name");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_1 = (axis2_char_t*)property_Name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_1_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_1, true);
+                           if (text_value_1_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1_temp, axutil_strlen(text_value_1_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_1_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1, axutil_strlen(text_value_1));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidType)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stype",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stype>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Type->serialize(current_node, parent_element,
+                                                                                 property_Type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidValue)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property value");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("value"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("value")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing value element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_Value.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for name by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::Attribute::getProperty1()
+            {
+                return getName();
+            }
+
+            /**
+             * getter for name.
+             */
+            std::string WSF_CALL
+            AviaryCommon::Attribute::getName()
+             {
+                return property_Name;
+             }
+
+            /**
+             * setter for name
+             */
+            bool WSF_CALL
+            AviaryCommon::Attribute::setName(
+                    const std::string  arg_Name)
+             {
+                
+
+                if(isValidName &&
+                        arg_Name == property_Name)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Name.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"name is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetName();
+
+                
+                        property_Name = std::string(arg_Name.c_str());
+                        isValidName = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for name
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::resetName()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidName = false; 
+               return true;
+           }
+
+           /**
+            * Check whether name is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::isNameNil()
+           {
+               return !isValidName;
+           }
+
+           /**
+            * Set name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::setNameNil()
+           {
+               return resetName();
+           }
+
+           
+
+            /**
+             * Getter for type by  Property Number 2
+             */
+            AviaryCommon::AttributeType* WSF_CALL
+            AviaryCommon::Attribute::getProperty2()
+            {
+                return getType();
+            }
+
+            /**
+             * getter for type.
+             */
+            AviaryCommon::AttributeType* WSF_CALL
+            AviaryCommon::Attribute::getType()
+             {
+                return property_Type;
+             }
+
+            /**
+             * setter for type
+             */
+            bool WSF_CALL
+            AviaryCommon::Attribute::setType(
+                    AviaryCommon::AttributeType*  arg_Type)
+             {
+                
+
+                if(isValidType &&
+                        arg_Type == property_Type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetType();
+
+                
+                    if(NULL == arg_Type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Type = arg_Type;
+                        isValidType = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for type
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::resetType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Type != NULL)
+                {
+                   
+                   
+                         delete  property_Type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::isTypeNil()
+           {
+               return !isValidType;
+           }
+
+           /**
+            * Set type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::setTypeNil()
+           {
+               return resetType();
+           }
+
+           
+
+            /**
+             * Getter for value by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryCommon::Attribute::getProperty3()
+            {
+                return getValue();
+            }
+
+            /**
+             * getter for value.
+             */
+            std::string WSF_CALL
+            AviaryCommon::Attribute::getValue()
+             {
+                return property_Value;
+             }
+
+            /**
+             * setter for value
+             */
+            bool WSF_CALL
+            AviaryCommon::Attribute::setValue(
+                    const std::string  arg_Value)
+             {
+                
+
+                if(isValidValue &&
+                        arg_Value == property_Value)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Value.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"value is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetValue();
+
+                
+                        property_Value = std::string(arg_Value.c_str());
+                        isValidValue = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for value
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::resetValue()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidValue = false; 
+               return true;
+           }
+
+           /**
+            * Check whether value is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::isValueNil()
+           {
+               return !isValidValue;
+           }
+
+           /**
+            * Set value to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Attribute::setValueNil()
+           {
+               return resetValue();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_AttributeType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_AttributeType.cpp
new file mode 100644
index 0000000..7495e14
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_AttributeType.cpp
@@ -0,0 +1,389 @@
+
+
+        /**
+         * AttributeType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_AttributeType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the AttributeType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::AttributeType::AttributeType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_AttributeType;
+                
+            isValidAttributeType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "AttributeType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::AttributeType::AttributeType(std::string arg_AttributeType)
+        {
+             
+                   qname = NULL;
+             
+                 property_AttributeType;
+             
+            isValidAttributeType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "AttributeType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_AttributeType = arg_AttributeType;
+            
+        }
+        AviaryCommon::AttributeType::~AttributeType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            AttributeType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setAttributeType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::AttributeType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element AttributeType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::AttributeType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::AttributeType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::AttributeType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_AttributeType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_AttributeType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::AttributeType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for AttributeType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::AttributeType::getProperty1()
+            {
+                return getAttributeType();
+            }
+
+            /**
+             * getter for AttributeType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::AttributeType::getAttributeType()
+             {
+                return property_AttributeType;
+             }
+
+            /**
+             * setter for AttributeType
+             */
+            bool WSF_CALL
+            AviaryCommon::AttributeType::setAttributeType(
+                    const std::string  arg_AttributeType)
+             {
+                
+
+                if(isValidAttributeType &&
+                        arg_AttributeType == property_AttributeType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_AttributeType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"AttributeType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetAttributeType();
+
+                
+                        property_AttributeType = std::string(arg_AttributeType.c_str());
+                        isValidAttributeType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for AttributeType.
+             */
+             ADBAttributeTypeEnum WSF_CALL
+             AviaryCommon::AttributeType::getAttributeTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_AttributeType.c_str(), "INTEGER") == 0)
+                    return AttributeType_INTEGER;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "FLOAT") == 0)
+                    return AttributeType_FLOAT;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "STRING") == 0)
+                    return AttributeType_STRING;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "EXPRESSION") == 0)
+                    return AttributeType_EXPRESSION;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "BOOLEAN") == 0)
+                    return AttributeType_BOOLEAN;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "UNDEFINED") == 0)
+                    return AttributeType_UNDEFINED;
+             
+                 if (axutil_strcmp(property_AttributeType.c_str(), "ERROR") == 0)
+                    return AttributeType_ERROR;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBAttributeTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for AttributeType.
+             */
+             bool WSF_CALL
+            AviaryCommon::AttributeType::setAttributeTypeEnum(const ADBAttributeTypeEnum  arg_AttributeType)
+             {
+                
+
+                
+                resetAttributeType();
+
+                   
+                   switch (arg_AttributeType)
+                   {
+                     
+                       case AttributeType_INTEGER :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "INTEGER");
+                          break;
+                     
+                       case AttributeType_FLOAT :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "FLOAT");
+                          break;
+                     
+                       case AttributeType_STRING :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "STRING");
+                          break;
+                     
+                       case AttributeType_EXPRESSION :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "EXPRESSION");
+                          break;
+                     
+                       case AttributeType_BOOLEAN :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "BOOLEAN");
+                          break;
+                     
+                       case AttributeType_UNDEFINED :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "UNDEFINED");
+                          break;
+                     
+                       case AttributeType_ERROR :
+                            property_AttributeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "ERROR");
+                          break;
+                     
+                     
+                       default:
+                          isValidAttributeType = false;
+                          property_AttributeType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting AttributeType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_AttributeType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidAttributeType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for AttributeType
+            */
+           bool WSF_CALL
+           AviaryCommon::AttributeType::resetAttributeType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidAttributeType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether AttributeType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::AttributeType::isAttributeTypeNil()
+           {
+               return !isValidAttributeType;
+           }
+
+           /**
+            * Set AttributeType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::AttributeType::setAttributeTypeNil()
+           {
+               return resetAttributeType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attributes.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attributes.cpp
new file mode 100644
index 0000000..f2dc649
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Attributes.cpp
@@ -0,0 +1,735 @@
+
+
+        /**
+         * Attributes.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_Attributes.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = Attributes
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::Attributes::Attributes()
+        {
+
+        
+                property_Attrs  = NULL;
+              
+            isValidAttrs  = false;
+        
+        }
+
+       AviaryCommon::Attributes::Attributes(std::vector<AviaryCommon::Attribute*>* arg_Attrs)
+        {
+             
+               property_Attrs  = NULL;
+             
+            isValidAttrs  = true;
+            
+                    property_Attrs = arg_Attrs;
+            
+        }
+        AviaryCommon::Attributes::~Attributes()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::Attributes::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+                       { 
+                    /*
+                     * building Attrs array
+                     */
+                       std::vector<AviaryCommon::Attribute*>* arr_list =new std::vector<AviaryCommon::Attribute*>();
+                   
+
+                     
+                     /*
+                      * building attrs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "attrs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("attrs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::Attribute* element = new AviaryCommon::Attribute();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element attrs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for attrs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"attrs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setAttrs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::Attributes::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::Attributes::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::Attributes::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidAttrs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("attrs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("attrs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Attrs array
+                      */
+                     if (property_Attrs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sattrs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sattrs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Attrs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::Attribute* element = (*property_Attrs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing attrs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for attrs by  Property Number 1
+             */
+            std::vector<AviaryCommon::Attribute*>* WSF_CALL
+            AviaryCommon::Attributes::getProperty1()
+            {
+                return getAttrs();
+            }
+
+            /**
+             * getter for attrs.
+             */
+            std::vector<AviaryCommon::Attribute*>* WSF_CALL
+            AviaryCommon::Attributes::getAttrs()
+             {
+                return property_Attrs;
+             }
+
+            /**
+             * setter for attrs
+             */
+            bool WSF_CALL
+            AviaryCommon::Attributes::setAttrs(
+                    std::vector<AviaryCommon::Attribute*>*  arg_Attrs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidAttrs &&
+                        arg_Attrs == property_Attrs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Attrs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"attrs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Attrs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetAttrs();
+
+                
+                    if(NULL == arg_Attrs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Attrs = arg_Attrs;
+                        if(non_nil_exists)
+                        {
+                            isValidAttrs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of attrs.
+             */
+            AviaryCommon::Attribute* WSF_CALL
+            AviaryCommon::Attributes::getAttrsAt(int i)
+            {
+                AviaryCommon::Attribute* ret_val;
+                if(property_Attrs == NULL)
+                {
+                    return (AviaryCommon::Attribute*)0;
+                }
+                ret_val =   (*property_Attrs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of attrs.
+             */
+           bool WSF_CALL
+            AviaryCommon::Attributes::setAttrsAt(int i,
+                    AviaryCommon::Attribute* arg_Attrs)
+            {
+                 AviaryCommon::Attribute* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidAttrs &&
+                    property_Attrs &&
+                  
+                    arg_Attrs == (*property_Attrs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Attrs == NULL)
+                {
+                    property_Attrs = new std::vector<AviaryCommon::Attribute*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Attrs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidAttrs = true;
+                        (*property_Attrs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Attrs)[i] = arg_Attrs;
+                  
+
+               isValidAttrs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to attrs.
+             */
+            bool WSF_CALL
+            AviaryCommon::Attributes::addAttrs(
+                    AviaryCommon::Attribute* arg_Attrs)
+             {
+
+                
+                    if( NULL == arg_Attrs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Attrs == NULL)
+                {
+                    property_Attrs = new std::vector<AviaryCommon::Attribute*>();
+                }
+              
+               property_Attrs->push_back(arg_Attrs);
+              
+                isValidAttrs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the attrs array.
+             */
+            int WSF_CALL
+            AviaryCommon::Attributes::sizeofAttrs()
+            {
+
+                if(property_Attrs == NULL)
+                {
+                    return 0;
+                }
+                return property_Attrs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryCommon::Attributes::removeAttrsAt(int i)
+            {
+                return setAttrsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for attrs
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::resetAttrs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Attrs != NULL)
+                {
+                  std::vector<AviaryCommon::Attribute*>::iterator it =  property_Attrs->begin();
+                  for( ; it <  property_Attrs->end() ; ++it)
+                  {
+                     AviaryCommon::Attribute* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Attrs)
+                 delete property_Attrs;
+                
+               isValidAttrs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether attrs is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::isAttrsNil()
+           {
+               return !isValidAttrs;
+           }
+
+           /**
+            * Set attrs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::setAttrsNil()
+           {
+               return resetAttrs();
+           }
+
+           
+           /**
+            * Check whether attrs is nill at i
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::isAttrsNilAt(int i)
+           {
+               return (isValidAttrs == false ||
+                       NULL == property_Attrs ||
+                     NULL == (*property_Attrs)[i]);
+            }
+
+           /**
+            * Set attrs to nil at i
+            */
+           bool WSF_CALL
+           AviaryCommon::Attributes::setAttrsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Attrs == NULL ||
+                            isValidAttrs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Attrs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Attrs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of attrs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Attrs == NULL)
+                {
+                    isValidAttrs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::Attribute* element = (*property_Attrs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidAttrs = false;
+                        (*property_Attrs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Attrs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraint.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraint.cpp
new file mode 100644
index 0000000..f17f65c
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraint.cpp
@@ -0,0 +1,717 @@
+
+
+        /**
+         * JobConstraint.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobConstraint.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobConstraint
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobConstraint::JobConstraint()
+        {
+
+        
+                property_Type  = NULL;
+              
+            isValidType  = false;
+        
+                    property_Value;
+                
+            isValidValue  = false;
+        
+        }
+
+       AviaryCommon::JobConstraint::JobConstraint(AviaryCommon::JobConstraintType* arg_Type,std::string arg_Value)
+        {
+             
+               property_Type  = NULL;
+             
+            isValidType  = true;
+            
+                 property_Value;
+             
+            isValidValue  = true;
+            
+                    property_Type = arg_Type;
+            
+                    property_Value = arg_Value;
+            
+        }
+        AviaryCommon::JobConstraint::~JobConstraint()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobConstraint::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building type element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobConstraintType* element = new AviaryCommon::JobConstraintType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element type");
+                                      }
+                                      else
+                                      {
+                                          status = setType(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building value element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "value", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setValue(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element value");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setValue("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for value ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element value missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobConstraint::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobConstraint::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobConstraint::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidType)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stype",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stype>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Type->serialize(current_node, parent_element,
+                                                                                 property_Type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidValue)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property value");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("value"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("value")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing value element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Value.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for type by  Property Number 1
+             */
+            AviaryCommon::JobConstraintType* WSF_CALL
+            AviaryCommon::JobConstraint::getProperty1()
+            {
+                return getType();
+            }
+
+            /**
+             * getter for type.
+             */
+            AviaryCommon::JobConstraintType* WSF_CALL
+            AviaryCommon::JobConstraint::getType()
+             {
+                return property_Type;
+             }
+
+            /**
+             * setter for type
+             */
+            bool WSF_CALL
+            AviaryCommon::JobConstraint::setType(
+                    AviaryCommon::JobConstraintType*  arg_Type)
+             {
+                
+
+                if(isValidType &&
+                        arg_Type == property_Type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetType();
+
+                
+                    if(NULL == arg_Type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Type = arg_Type;
+                        isValidType = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for type
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::resetType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Type != NULL)
+                {
+                   
+                   
+                         delete  property_Type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::isTypeNil()
+           {
+               return !isValidType;
+           }
+
+           /**
+            * Set type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::setTypeNil()
+           {
+               return resetType();
+           }
+
+           
+
+            /**
+             * Getter for value by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobConstraint::getProperty2()
+            {
+                return getValue();
+            }
+
+            /**
+             * getter for value.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobConstraint::getValue()
+             {
+                return property_Value;
+             }
+
+            /**
+             * setter for value
+             */
+            bool WSF_CALL
+            AviaryCommon::JobConstraint::setValue(
+                    const std::string  arg_Value)
+             {
+                
+
+                if(isValidValue &&
+                        arg_Value == property_Value)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Value.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"value is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetValue();
+
+                
+                        property_Value = std::string(arg_Value.c_str());
+                        isValidValue = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for value
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::resetValue()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidValue = false; 
+               return true;
+           }
+
+           /**
+            * Check whether value is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::isValueNil()
+           {
+               return !isValidValue;
+           }
+
+           /**
+            * Set value to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraint::setValueNil()
+           {
+               return resetValue();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraintType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraintType.cpp
new file mode 100644
index 0000000..b5c7161
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobConstraintType.cpp
@@ -0,0 +1,361 @@
+
+
+        /**
+         * JobConstraintType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobConstraintType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the JobConstraintType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::JobConstraintType::JobConstraintType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_JobConstraintType;
+                
+            isValidJobConstraintType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "JobConstraintType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::JobConstraintType::JobConstraintType(std::string arg_JobConstraintType)
+        {
+             
+                   qname = NULL;
+             
+                 property_JobConstraintType;
+             
+            isValidJobConstraintType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "JobConstraintType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_JobConstraintType = arg_JobConstraintType;
+            
+        }
+        AviaryCommon::JobConstraintType::~JobConstraintType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            JobConstraintType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setJobConstraintType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobConstraintType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element JobConstraintType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobConstraintType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobConstraintType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::JobConstraintType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_JobConstraintType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_JobConstraintType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobConstraintType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for JobConstraintType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobConstraintType::getProperty1()
+            {
+                return getJobConstraintType();
+            }
+
+            /**
+             * getter for JobConstraintType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobConstraintType::getJobConstraintType()
+             {
+                return property_JobConstraintType;
+             }
+
+            /**
+             * setter for JobConstraintType
+             */
+            bool WSF_CALL
+            AviaryCommon::JobConstraintType::setJobConstraintType(
+                    const std::string  arg_JobConstraintType)
+             {
+                
+
+                if(isValidJobConstraintType &&
+                        arg_JobConstraintType == property_JobConstraintType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_JobConstraintType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"JobConstraintType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJobConstraintType();
+
+                
+                        property_JobConstraintType = std::string(arg_JobConstraintType.c_str());
+                        isValidJobConstraintType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for JobConstraintType.
+             */
+             ADBJobConstraintTypeEnum WSF_CALL
+             AviaryCommon::JobConstraintType::getJobConstraintTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_JobConstraintType.c_str(), "CMD") == 0)
+                    return JobConstraintType_CMD;
+             
+                 if (axutil_strcmp(property_JobConstraintType.c_str(), "ARGS") == 0)
+                    return JobConstraintType_ARGS;
+             
+                 if (axutil_strcmp(property_JobConstraintType.c_str(), "OWNER") == 0)
+                    return JobConstraintType_OWNER;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBJobConstraintTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for JobConstraintType.
+             */
+             bool WSF_CALL
+            AviaryCommon::JobConstraintType::setJobConstraintTypeEnum(const ADBJobConstraintTypeEnum  arg_JobConstraintType)
+             {
+                
+
+                
+                resetJobConstraintType();
+
+                   
+                   switch (arg_JobConstraintType)
+                   {
+                     
+                       case JobConstraintType_CMD :
+                            property_JobConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "CMD");
+                          break;
+                     
+                       case JobConstraintType_ARGS :
+                            property_JobConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "ARGS");
+                          break;
+                     
+                       case JobConstraintType_OWNER :
+                            property_JobConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "OWNER");
+                          break;
+                     
+                     
+                       default:
+                          isValidJobConstraintType = false;
+                          property_JobConstraintType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting JobConstraintType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_JobConstraintType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidJobConstraintType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for JobConstraintType
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraintType::resetJobConstraintType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidJobConstraintType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether JobConstraintType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraintType::isJobConstraintTypeNil()
+           {
+               return !isValidJobConstraintType;
+           }
+
+           /**
+            * Set JobConstraintType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobConstraintType::setJobConstraintTypeNil()
+           {
+               return resetJobConstraintType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobData.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobData.cpp
new file mode 100644
index 0000000..fd24b98
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobData.cpp
@@ -0,0 +1,679 @@
+
+
+        /**
+         * JobData.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobData.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobData
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobData::JobData()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Type  = NULL;
+              
+            isValidType  = false;
+        
+        }
+
+       AviaryCommon::JobData::JobData(AviaryCommon::JobID* arg_Id,AviaryCommon::JobDataType* arg_Type)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Type  = NULL;
+             
+            isValidType  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Type = arg_Type;
+            
+        }
+        AviaryCommon::JobData::~JobData()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobData::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building type element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobDataType* element = new AviaryCommon::JobDataType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element type");
+                                      }
+                                      else
+                                      {
+                                          status = setType(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobData::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobData::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobData::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidType)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stype",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stype>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Type->serialize(current_node, parent_element,
+                                                                                 property_Type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobData::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobData::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::JobData::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for type by  Property Number 2
+             */
+            AviaryCommon::JobDataType* WSF_CALL
+            AviaryCommon::JobData::getProperty2()
+            {
+                return getType();
+            }
+
+            /**
+             * getter for type.
+             */
+            AviaryCommon::JobDataType* WSF_CALL
+            AviaryCommon::JobData::getType()
+             {
+                return property_Type;
+             }
+
+            /**
+             * setter for type
+             */
+            bool WSF_CALL
+            AviaryCommon::JobData::setType(
+                    AviaryCommon::JobDataType*  arg_Type)
+             {
+                
+
+                if(isValidType &&
+                        arg_Type == property_Type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetType();
+
+                
+                    if(NULL == arg_Type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Type = arg_Type;
+                        isValidType = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for type
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::resetType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Type != NULL)
+                {
+                   
+                   
+                         delete  property_Type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::isTypeNil()
+           {
+               return !isValidType;
+           }
+
+           /**
+            * Set type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobData::setTypeNil()
+           {
+               return resetType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDataType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDataType.cpp
new file mode 100644
index 0000000..6c259b7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDataType.cpp
@@ -0,0 +1,361 @@
+
+
+        /**
+         * JobDataType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobDataType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the JobDataType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::JobDataType::JobDataType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_JobDataType;
+                
+            isValidJobDataType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "JobDataType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::JobDataType::JobDataType(std::string arg_JobDataType)
+        {
+             
+                   qname = NULL;
+             
+                 property_JobDataType;
+             
+            isValidJobDataType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "JobDataType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_JobDataType = arg_JobDataType;
+            
+        }
+        AviaryCommon::JobDataType::~JobDataType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            JobDataType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setJobDataType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobDataType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element JobDataType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobDataType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobDataType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::JobDataType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_JobDataType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_JobDataType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobDataType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for JobDataType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobDataType::getProperty1()
+            {
+                return getJobDataType();
+            }
+
+            /**
+             * getter for JobDataType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobDataType::getJobDataType()
+             {
+                return property_JobDataType;
+             }
+
+            /**
+             * setter for JobDataType
+             */
+            bool WSF_CALL
+            AviaryCommon::JobDataType::setJobDataType(
+                    const std::string  arg_JobDataType)
+             {
+                
+
+                if(isValidJobDataType &&
+                        arg_JobDataType == property_JobDataType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_JobDataType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"JobDataType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJobDataType();
+
+                
+                        property_JobDataType = std::string(arg_JobDataType.c_str());
+                        isValidJobDataType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for JobDataType.
+             */
+             ADBJobDataTypeEnum WSF_CALL
+             AviaryCommon::JobDataType::getJobDataTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_JobDataType.c_str(), "ERR") == 0)
+                    return JobDataType_ERR;
+             
+                 if (axutil_strcmp(property_JobDataType.c_str(), "LOG") == 0)
+                    return JobDataType_LOG;
+             
+                 if (axutil_strcmp(property_JobDataType.c_str(), "OUT") == 0)
+                    return JobDataType_OUT;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBJobDataTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for JobDataType.
+             */
+             bool WSF_CALL
+            AviaryCommon::JobDataType::setJobDataTypeEnum(const ADBJobDataTypeEnum  arg_JobDataType)
+             {
+                
+
+                
+                resetJobDataType();
+
+                   
+                   switch (arg_JobDataType)
+                   {
+                     
+                       case JobDataType_ERR :
+                            property_JobDataType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "ERR");
+                          break;
+                     
+                       case JobDataType_LOG :
+                            property_JobDataType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "LOG");
+                          break;
+                     
+                       case JobDataType_OUT :
+                            property_JobDataType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "OUT");
+                          break;
+                     
+                     
+                       default:
+                          isValidJobDataType = false;
+                          property_JobDataType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting JobDataType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_JobDataType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidJobDataType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for JobDataType
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDataType::resetJobDataType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidJobDataType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether JobDataType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDataType::isJobDataTypeNil()
+           {
+               return !isValidJobDataType;
+           }
+
+           /**
+            * Set JobDataType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDataType::setJobDataTypeNil()
+           {
+               return resetJobDataType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDetails.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDetails.cpp
new file mode 100644
index 0000000..0848d89
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobDetails.cpp
@@ -0,0 +1,927 @@
+
+
+        /**
+         * JobDetails.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobDetails.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobDetails
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobDetails::JobDetails()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                property_Details  = NULL;
+              
+            isValidDetails  = false;
+        
+        }
+
+       AviaryCommon::JobDetails::JobDetails(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,AviaryCommon::Attributes* arg_Details)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+               property_Details  = NULL;
+             
+            isValidDetails  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+                    property_Details = arg_Details;
+            
+        }
+        AviaryCommon::JobDetails::~JobDetails()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobDetails::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building details element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "details", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("details", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("details", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Attributes* element = new AviaryCommon::Attributes();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element details");
+                                      }
+                                      else
+                                      {
+                                          status = setDetails(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for details ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobDetails::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobDetails::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobDetails::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidDetails)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("details"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("details")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing details element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sdetails",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sdetails>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Details->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Details->serialize(current_node, parent_element,
+                                                                                 property_Details->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Details->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobDetails::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobDetails::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::JobDetails::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobDetails::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobDetails::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobDetails::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for details by  Property Number 3
+             */
+            AviaryCommon::Attributes* WSF_CALL
+            AviaryCommon::JobDetails::getProperty3()
+            {
+                return getDetails();
+            }
+
+            /**
+             * getter for details.
+             */
+            AviaryCommon::Attributes* WSF_CALL
+            AviaryCommon::JobDetails::getDetails()
+             {
+                return property_Details;
+             }
+
+            /**
+             * setter for details
+             */
+            bool WSF_CALL
+            AviaryCommon::JobDetails::setDetails(
+                    AviaryCommon::Attributes*  arg_Details)
+             {
+                
+
+                if(isValidDetails &&
+                        arg_Details == property_Details)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetDetails();
+
+                
+                    if(NULL == arg_Details)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Details = arg_Details;
+                        isValidDetails = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for details
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::resetDetails()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Details != NULL)
+                {
+                   
+                   
+                         delete  property_Details;
+                     
+
+                   }
+
+                
+                
+                
+               isValidDetails = false; 
+               return true;
+           }
+
+           /**
+            * Check whether details is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::isDetailsNil()
+           {
+               return !isValidDetails;
+           }
+
+           /**
+            * Set details to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobDetails::setDetailsNil()
+           {
+               return resetDetails();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobID.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobID.cpp
new file mode 100644
index 0000000..249a55b
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobID.cpp
@@ -0,0 +1,1270 @@
+
+
+        /**
+         * JobID.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobID.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobID
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobID::JobID()
+        {
+
+        
+                    property_Job;
+                
+            isValidJob  = false;
+        
+                    property_Pool;
+                
+            isValidPool  = false;
+        
+                    property_Scheduler;
+                
+            isValidScheduler  = false;
+        
+                property_Submission  = NULL;
+              
+            isValidSubmission  = false;
+        
+        }
+
+       AviaryCommon::JobID::JobID(std::string arg_Job,std::string arg_Pool,std::string arg_Scheduler,AviaryCommon::SubmissionID* arg_Submission)
+        {
+             
+                 property_Job;
+             
+            isValidJob  = true;
+            
+                 property_Pool;
+             
+            isValidPool  = true;
+            
+                 property_Scheduler;
+             
+            isValidScheduler  = true;
+            
+               property_Submission  = NULL;
+             
+            isValidSubmission  = true;
+            
+                    property_Job = arg_Job;
+            
+                    property_Pool = arg_Pool;
+            
+                    property_Scheduler = arg_Scheduler;
+            
+                    property_Submission = arg_Submission;
+            
+        }
+        AviaryCommon::JobID::~JobID()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobID::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building job element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "job", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setJob(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element job");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setJob("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for job ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element job missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building pool element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "pool", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("pool", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("pool", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setPool(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element pool");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setPool("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for pool ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building scheduler element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "scheduler", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("scheduler", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("scheduler", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setScheduler(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element scheduler");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setScheduler("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for scheduler ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building submission element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "submission", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submission", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submission", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::SubmissionID* element = new AviaryCommon::SubmissionID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element submission");
+                                      }
+                                      else
+                                      {
+                                          status = setSubmission(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for submission ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobID::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobID::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobID::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t *text_value_1;
+                    axis2_char_t *text_value_1_temp;
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t text_value_4[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJob)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property job");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("job"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("job")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing job element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sjob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sjob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_1 = (axis2_char_t*)property_Job.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_1_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_1, true);
+                           if (text_value_1_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1_temp, axutil_strlen(text_value_1_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_1_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1, axutil_strlen(text_value_1));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidPool)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("pool"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("pool")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing pool element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%spool>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%spool>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Pool.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidScheduler)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("scheduler"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("scheduler")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing scheduler element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sscheduler>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sscheduler>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_Scheduler.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidSubmission)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("submission"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("submission")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing submission element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%ssubmission",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%ssubmission>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Submission->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Submission->serialize(current_node, parent_element,
+                                                                                 property_Submission->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Submission->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for job by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getProperty1()
+            {
+                return getJob();
+            }
+
+            /**
+             * getter for job.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getJob()
+             {
+                return property_Job;
+             }
+
+            /**
+             * setter for job
+             */
+            bool WSF_CALL
+            AviaryCommon::JobID::setJob(
+                    const std::string  arg_Job)
+             {
+                
+
+                if(isValidJob &&
+                        arg_Job == property_Job)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Job.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"job is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJob();
+
+                
+                        property_Job = std::string(arg_Job.c_str());
+                        isValidJob = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for job
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::resetJob()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidJob = false; 
+               return true;
+           }
+
+           /**
+            * Check whether job is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::isJobNil()
+           {
+               return !isValidJob;
+           }
+
+           /**
+            * Set job to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::setJobNil()
+           {
+               return resetJob();
+           }
+
+           
+
+            /**
+             * Getter for pool by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getProperty2()
+            {
+                return getPool();
+            }
+
+            /**
+             * getter for pool.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getPool()
+             {
+                return property_Pool;
+             }
+
+            /**
+             * setter for pool
+             */
+            bool WSF_CALL
+            AviaryCommon::JobID::setPool(
+                    const std::string  arg_Pool)
+             {
+                
+
+                if(isValidPool &&
+                        arg_Pool == property_Pool)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPool();
+
+                
+                        property_Pool = std::string(arg_Pool.c_str());
+                        isValidPool = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for pool
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::resetPool()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPool = false; 
+               return true;
+           }
+
+           /**
+            * Check whether pool is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::isPoolNil()
+           {
+               return !isValidPool;
+           }
+
+           /**
+            * Set pool to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::setPoolNil()
+           {
+               return resetPool();
+           }
+
+           
+
+            /**
+             * Getter for scheduler by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getProperty3()
+            {
+                return getScheduler();
+            }
+
+            /**
+             * getter for scheduler.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobID::getScheduler()
+             {
+                return property_Scheduler;
+             }
+
+            /**
+             * setter for scheduler
+             */
+            bool WSF_CALL
+            AviaryCommon::JobID::setScheduler(
+                    const std::string  arg_Scheduler)
+             {
+                
+
+                if(isValidScheduler &&
+                        arg_Scheduler == property_Scheduler)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetScheduler();
+
+                
+                        property_Scheduler = std::string(arg_Scheduler.c_str());
+                        isValidScheduler = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for scheduler
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::resetScheduler()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidScheduler = false; 
+               return true;
+           }
+
+           /**
+            * Check whether scheduler is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::isSchedulerNil()
+           {
+               return !isValidScheduler;
+           }
+
+           /**
+            * Set scheduler to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::setSchedulerNil()
+           {
+               return resetScheduler();
+           }
+
+           
+
+            /**
+             * Getter for submission by  Property Number 4
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryCommon::JobID::getProperty4()
+            {
+                return getSubmission();
+            }
+
+            /**
+             * getter for submission.
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryCommon::JobID::getSubmission()
+             {
+                return property_Submission;
+             }
+
+            /**
+             * setter for submission
+             */
+            bool WSF_CALL
+            AviaryCommon::JobID::setSubmission(
+                    AviaryCommon::SubmissionID*  arg_Submission)
+             {
+                
+
+                if(isValidSubmission &&
+                        arg_Submission == property_Submission)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetSubmission();
+
+                
+                    if(NULL == arg_Submission)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Submission = arg_Submission;
+                        isValidSubmission = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for submission
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::resetSubmission()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Submission != NULL)
+                {
+                   
+                   
+                         delete  property_Submission;
+                     
+
+                   }
+
+                
+                
+                
+               isValidSubmission = false; 
+               return true;
+           }
+
+           /**
+            * Check whether submission is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::isSubmissionNil()
+           {
+               return !isValidSubmission;
+           }
+
+           /**
+            * Set submission to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobID::setSubmissionNil()
+           {
+               return resetSubmission();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatus.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatus.cpp
new file mode 100644
index 0000000..bf70be7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatus.cpp
@@ -0,0 +1,927 @@
+
+
+        /**
+         * JobStatus.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobStatus.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobStatus
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobStatus::JobStatus()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                property_Job_status  = NULL;
+              
+            isValidJob_status  = false;
+        
+        }
+
+       AviaryCommon::JobStatus::JobStatus(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,AviaryCommon::JobStatusType* arg_Job_status)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+               property_Job_status  = NULL;
+             
+            isValidJob_status  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+                    property_Job_status = arg_Job_status;
+            
+        }
+        AviaryCommon::JobStatus::~JobStatus()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobStatus::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building job_status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "job_status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job_status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job_status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobStatusType* element = new AviaryCommon::JobStatusType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element job_status");
+                                      }
+                                      else
+                                      {
+                                          status = setJob_status(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for job_status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobStatus::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobStatus::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobStatus::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJob_status)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("job_status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("job_status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing job_status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sjob_status",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sjob_status>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Job_status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Job_status->serialize(current_node, parent_element,
+                                                                                 property_Job_status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Job_status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobStatus::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobStatus::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::JobStatus::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobStatus::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobStatus::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobStatus::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for job_status by  Property Number 3
+             */
+            AviaryCommon::JobStatusType* WSF_CALL
+            AviaryCommon::JobStatus::getProperty3()
+            {
+                return getJob_status();
+            }
+
+            /**
+             * getter for job_status.
+             */
+            AviaryCommon::JobStatusType* WSF_CALL
+            AviaryCommon::JobStatus::getJob_status()
+             {
+                return property_Job_status;
+             }
+
+            /**
+             * setter for job_status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobStatus::setJob_status(
+                    AviaryCommon::JobStatusType*  arg_Job_status)
+             {
+                
+
+                if(isValidJob_status &&
+                        arg_Job_status == property_Job_status)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetJob_status();
+
+                
+                    if(NULL == arg_Job_status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Job_status = arg_Job_status;
+                        isValidJob_status = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for job_status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::resetJob_status()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Job_status != NULL)
+                {
+                   
+                   
+                         delete  property_Job_status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidJob_status = false; 
+               return true;
+           }
+
+           /**
+            * Check whether job_status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::isJob_statusNil()
+           {
+               return !isValidJob_status;
+           }
+
+           /**
+            * Set job_status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatus::setJob_statusNil()
+           {
+               return resetJob_status();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatusType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatusType.cpp
new file mode 100644
index 0000000..278c54a
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobStatusType.cpp
@@ -0,0 +1,375 @@
+
+
+        /**
+         * JobStatusType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobStatusType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the JobStatusType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::JobStatusType::JobStatusType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_JobStatusType;
+                
+            isValidJobStatusType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "JobStatusType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::JobStatusType::JobStatusType(std::string arg_JobStatusType)
+        {
+             
+                   qname = NULL;
+             
+                 property_JobStatusType;
+             
+            isValidJobStatusType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "JobStatusType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_JobStatusType = arg_JobStatusType;
+            
+        }
+        AviaryCommon::JobStatusType::~JobStatusType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            JobStatusType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setJobStatusType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobStatusType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element JobStatusType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobStatusType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobStatusType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::JobStatusType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_JobStatusType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_JobStatusType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobStatusType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for JobStatusType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobStatusType::getProperty1()
+            {
+                return getJobStatusType();
+            }
+
+            /**
+             * getter for JobStatusType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobStatusType::getJobStatusType()
+             {
+                return property_JobStatusType;
+             }
+
+            /**
+             * setter for JobStatusType
+             */
+            bool WSF_CALL
+            AviaryCommon::JobStatusType::setJobStatusType(
+                    const std::string  arg_JobStatusType)
+             {
+                
+
+                if(isValidJobStatusType &&
+                        arg_JobStatusType == property_JobStatusType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_JobStatusType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"JobStatusType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJobStatusType();
+
+                
+                        property_JobStatusType = std::string(arg_JobStatusType.c_str());
+                        isValidJobStatusType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for JobStatusType.
+             */
+             ADBJobStatusTypeEnum WSF_CALL
+             AviaryCommon::JobStatusType::getJobStatusTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "IDLE") == 0)
+                    return JobStatusType_IDLE;
+             
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "RUNNING") == 0)
+                    return JobStatusType_RUNNING;
+             
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "REMOVED") == 0)
+                    return JobStatusType_REMOVED;
+             
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "COMPLETED") == 0)
+                    return JobStatusType_COMPLETED;
+             
+                 if (axutil_strcmp(property_JobStatusType.c_str(), "HELD") == 0)
+                    return JobStatusType_HELD;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBJobStatusTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for JobStatusType.
+             */
+             bool WSF_CALL
+            AviaryCommon::JobStatusType::setJobStatusTypeEnum(const ADBJobStatusTypeEnum  arg_JobStatusType)
+             {
+                
+
+                
+                resetJobStatusType();
+
+                   
+                   switch (arg_JobStatusType)
+                   {
+                     
+                       case JobStatusType_IDLE :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "IDLE");
+                          break;
+                     
+                       case JobStatusType_RUNNING :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "RUNNING");
+                          break;
+                     
+                       case JobStatusType_REMOVED :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "REMOVED");
+                          break;
+                     
+                       case JobStatusType_COMPLETED :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "COMPLETED");
+                          break;
+                     
+                       case JobStatusType_HELD :
+                            property_JobStatusType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "HELD");
+                          break;
+                     
+                     
+                       default:
+                          isValidJobStatusType = false;
+                          property_JobStatusType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting JobStatusType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_JobStatusType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidJobStatusType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for JobStatusType
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatusType::resetJobStatusType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidJobStatusType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether JobStatusType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatusType::isJobStatusTypeNil()
+           {
+               return !isValidJobStatusType;
+           }
+
+           /**
+            * Set JobStatusType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobStatusType::setJobStatusTypeNil()
+           {
+               return resetJobStatusType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobSummary.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobSummary.cpp
new file mode 100644
index 0000000..9fe45ed
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_JobSummary.cpp
@@ -0,0 +1,3241 @@
+
+
+        /**
+         * JobSummary.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_JobSummary.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = JobSummary
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::JobSummary::JobSummary()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                property_Queued  = NULL;
+              
+            isValidQueued  = false;
+        
+                property_Last_update  = NULL;
+              
+            isValidLast_update  = false;
+        
+                property_Job_status  = NULL;
+              
+            isValidJob_status  = false;
+        
+                    property_Cmd;
+                
+            isValidCmd  = false;
+        
+                    property_Args1;
+                
+            isValidArgs1  = false;
+        
+                    property_Args2;
+                
+            isValidArgs2  = false;
+        
+                    property_Held;
+                
+            isValidHeld  = false;
+        
+                    property_Released;
+                
+            isValidReleased  = false;
+        
+                    property_Removed;
+                
+            isValidRemoved  = false;
+        
+        }
+
+       AviaryCommon::JobSummary::JobSummary(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,axutil_date_time_t* arg_Queued,axutil_date_time_t* arg_Last_update,AviaryCommon::JobStatusType* arg_Job_status,std::string arg_Cmd,std::string arg_Args1,std::string arg_Args2,std::string arg_Held,std::string arg_Released,std::string arg_Removed)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+               property_Queued  = NULL;
+             
+            isValidQueued  = true;
+            
+               property_Last_update  = NULL;
+             
+            isValidLast_update  = true;
+            
+               property_Job_status  = NULL;
+             
+            isValidJob_status  = true;
+            
+                 property_Cmd;
+             
+            isValidCmd  = true;
+            
+                 property_Args1;
+             
+            isValidArgs1  = true;
+            
+                 property_Args2;
+             
+            isValidArgs2  = true;
+            
+                 property_Held;
+             
+            isValidHeld  = true;
+            
+                 property_Released;
+             
+            isValidReleased  = true;
+            
+                 property_Removed;
+             
+            isValidRemoved  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+                    property_Queued = arg_Queued;
+            
+                    property_Last_update = arg_Last_update;
+            
+                    property_Job_status = arg_Job_status;
+            
+                    property_Cmd = arg_Cmd;
+            
+                    property_Args1 = arg_Args1;
+            
+                    property_Args2 = arg_Args2;
+            
+                    property_Held = arg_Held;
+            
+                    property_Released = arg_Released;
+            
+                    property_Removed = arg_Removed;
+            
+        }
+        AviaryCommon::JobSummary::~JobSummary()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::JobSummary::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building queued element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "queued", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("queued", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("queued", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                          axutil_date_time_t* element = axutil_date_time_create(Environment::getEnv());
+                                          status = axutil_date_time_deserialize_date_time((axutil_date_time_t*)element, Environment::getEnv(),
+                                                                          text_value);
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+                                              if(element != NULL)
+                                              {
+                                                  axutil_date_time_free(element, Environment::getEnv());
+                                              }
+					                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI ,"failed in building element queued ");
+                                          }
+                                          else
+                                          {
+                                            status = setQueued(element);
+                                          }
+                                      }
+                                      
+                                      else
+                                      {
+				                            WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "NULL value is set to a non nillable element queued");
+                                            status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for queued ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element queued missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building last_update element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "last_update", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("last_update", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("last_update", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                          axutil_date_time_t* element = axutil_date_time_create(Environment::getEnv());
+                                          status = axutil_date_time_deserialize_date_time((axutil_date_time_t*)element, Environment::getEnv(),
+                                                                          text_value);
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+                                              if(element != NULL)
+                                              {
+                                                  axutil_date_time_free(element, Environment::getEnv());
+                                              }
+					                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI ,"failed in building element last_update ");
+                                          }
+                                          else
+                                          {
+                                            status = setLast_update(element);
+                                          }
+                                      }
+                                      
+                                      else
+                                      {
+				                            WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "NULL value is set to a non nillable element last_update");
+                                            status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for last_update ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element last_update missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building job_status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "job_status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job_status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("job_status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobStatusType* element = new AviaryCommon::JobStatusType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element job_status");
+                                      }
+                                      else
+                                      {
+                                          status = setJob_status(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for job_status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element job_status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building cmd element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "cmd", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("cmd", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("cmd", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setCmd(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element cmd");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setCmd("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for cmd ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element cmd missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building args1 element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "args1", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args1", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args1", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setArgs1(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element args1");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setArgs1("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for args1 ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building args2 element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "args2", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args2", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args2", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setArgs2(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element args2");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setArgs2("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for args2 ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building held element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "held", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("held", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("held", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setHeld(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element held");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setHeld("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for held ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building released element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "released", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("released", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("released", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setReleased(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element released");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setReleased("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for released ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building removed element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "removed", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("removed", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("removed", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setRemoved(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element removed");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setRemoved("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for removed ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::JobSummary::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::JobSummary::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::JobSummary::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t *text_value_4;
+                    axis2_char_t *text_value_4_temp;
+                    
+                    axis2_char_t text_value_5[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_6;
+                    axis2_char_t *text_value_6_temp;
+                    
+                    axis2_char_t *text_value_7;
+                    axis2_char_t *text_value_7_temp;
+                    
+                    axis2_char_t *text_value_8;
+                    axis2_char_t *text_value_8_temp;
+                    
+                    axis2_char_t *text_value_9;
+                    axis2_char_t *text_value_9_temp;
+                    
+                    axis2_char_t *text_value_10;
+                    axis2_char_t *text_value_10_temp;
+                    
+                    axis2_char_t *text_value_11;
+                    axis2_char_t *text_value_11_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidQueued)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property queued");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("queued"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("queued")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing queued element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%squeued>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%squeued>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                          text_value_3 = axutil_date_time_serialize_date_time(property_Queued, Environment::getEnv());
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidLast_update)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property last_update");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("last_update"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("last_update")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing last_update element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%slast_update>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%slast_update>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                          text_value_4 = axutil_date_time_serialize_date_time(property_Last_update, Environment::getEnv());
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJob_status)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property job_status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("job_status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("job_status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing job_status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sjob_status",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sjob_status>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Job_status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Job_status->serialize(current_node, parent_element,
+                                                                                 property_Job_status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Job_status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCmd)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property cmd");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("cmd"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("cmd")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing cmd element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scmd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scmd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_6 = (axis2_char_t*)property_Cmd.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_6_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_6, true);
+                           if (text_value_6_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_6_temp, axutil_strlen(text_value_6_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_6_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_6, axutil_strlen(text_value_6));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidArgs1)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("args1"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("args1")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing args1 element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sargs1>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sargs1>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_7 = (axis2_char_t*)property_Args1.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_7_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_7, true);
+                           if (text_value_7_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_7_temp, axutil_strlen(text_value_7_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_7_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_7, axutil_strlen(text_value_7));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidArgs2)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("args2"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("args2")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing args2 element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sargs2>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sargs2>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_8 = (axis2_char_t*)property_Args2.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_8_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_8, true);
+                           if (text_value_8_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_8_temp, axutil_strlen(text_value_8_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_8_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_8, axutil_strlen(text_value_8));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidHeld)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("held"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("held")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing held element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sheld>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sheld>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_9 = (axis2_char_t*)property_Held.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_9_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_9, true);
+                           if (text_value_9_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_9_temp, axutil_strlen(text_value_9_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_9_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_9, axutil_strlen(text_value_9));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidReleased)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("released"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("released")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing released element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sreleased>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sreleased>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_10 = (axis2_char_t*)property_Released.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_10_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_10, true);
+                           if (text_value_10_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_10_temp, axutil_strlen(text_value_10_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_10_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_10, axutil_strlen(text_value_10));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidRemoved)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("removed"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("removed")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing removed element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sremoved>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sremoved>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_11 = (axis2_char_t*)property_Removed.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_11_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_11, true);
+                           if (text_value_11_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_11_temp, axutil_strlen(text_value_11_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_11_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_11, axutil_strlen(text_value_11));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobSummary::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryCommon::JobSummary::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobSummary::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::JobSummary::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for queued by  Property Number 3
+             */
+            axutil_date_time_t* WSF_CALL
+            AviaryCommon::JobSummary::getProperty3()
+            {
+                return getQueued();
+            }
+
+            /**
+             * getter for queued.
+             */
+            axutil_date_time_t* WSF_CALL
+            AviaryCommon::JobSummary::getQueued()
+             {
+                return property_Queued;
+             }
+
+            /**
+             * setter for queued
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setQueued(
+                    axutil_date_time_t*  arg_Queued)
+             {
+                
+
+                if(isValidQueued &&
+                        arg_Queued == property_Queued)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Queued)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"queued is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetQueued();
+
+                
+                    if(NULL == arg_Queued)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Queued = arg_Queued;
+                        isValidQueued = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for queued
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetQueued()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Queued != NULL)
+                {
+                   
+                   
+                      axutil_date_time_free(property_Queued, Environment::getEnv());
+                         property_Queued = NULL;
+                     
+
+                   }
+
+                
+                
+                
+               isValidQueued = false; 
+               return true;
+           }
+
+           /**
+            * Check whether queued is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isQueuedNil()
+           {
+               return !isValidQueued;
+           }
+
+           /**
+            * Set queued to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setQueuedNil()
+           {
+               return resetQueued();
+           }
+
+           
+
+            /**
+             * Getter for last_update by  Property Number 4
+             */
+            axutil_date_time_t* WSF_CALL
+            AviaryCommon::JobSummary::getProperty4()
+            {
+                return getLast_update();
+            }
+
+            /**
+             * getter for last_update.
+             */
+            axutil_date_time_t* WSF_CALL
+            AviaryCommon::JobSummary::getLast_update()
+             {
+                return property_Last_update;
+             }
+
+            /**
+             * setter for last_update
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setLast_update(
+                    axutil_date_time_t*  arg_Last_update)
+             {
+                
+
+                if(isValidLast_update &&
+                        arg_Last_update == property_Last_update)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Last_update)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"last_update is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetLast_update();
+
+                
+                    if(NULL == arg_Last_update)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Last_update = arg_Last_update;
+                        isValidLast_update = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for last_update
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetLast_update()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Last_update != NULL)
+                {
+                   
+                   
+                      axutil_date_time_free(property_Last_update, Environment::getEnv());
+                         property_Last_update = NULL;
+                     
+
+                   }
+
+                
+                
+                
+               isValidLast_update = false; 
+               return true;
+           }
+
+           /**
+            * Check whether last_update is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isLast_updateNil()
+           {
+               return !isValidLast_update;
+           }
+
+           /**
+            * Set last_update to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setLast_updateNil()
+           {
+               return resetLast_update();
+           }
+
+           
+
+            /**
+             * Getter for job_status by  Property Number 5
+             */
+            AviaryCommon::JobStatusType* WSF_CALL
+            AviaryCommon::JobSummary::getProperty5()
+            {
+                return getJob_status();
+            }
+
+            /**
+             * getter for job_status.
+             */
+            AviaryCommon::JobStatusType* WSF_CALL
+            AviaryCommon::JobSummary::getJob_status()
+             {
+                return property_Job_status;
+             }
+
+            /**
+             * setter for job_status
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setJob_status(
+                    AviaryCommon::JobStatusType*  arg_Job_status)
+             {
+                
+
+                if(isValidJob_status &&
+                        arg_Job_status == property_Job_status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Job_status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"job_status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetJob_status();
+
+                
+                    if(NULL == arg_Job_status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Job_status = arg_Job_status;
+                        isValidJob_status = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for job_status
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetJob_status()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Job_status != NULL)
+                {
+                   
+                   
+                         delete  property_Job_status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidJob_status = false; 
+               return true;
+           }
+
+           /**
+            * Check whether job_status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isJob_statusNil()
+           {
+               return !isValidJob_status;
+           }
+
+           /**
+            * Set job_status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setJob_statusNil()
+           {
+               return resetJob_status();
+           }
+
+           
+
+            /**
+             * Getter for cmd by  Property Number 6
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty6()
+            {
+                return getCmd();
+            }
+
+            /**
+             * getter for cmd.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getCmd()
+             {
+                return property_Cmd;
+             }
+
+            /**
+             * setter for cmd
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setCmd(
+                    const std::string  arg_Cmd)
+             {
+                
+
+                if(isValidCmd &&
+                        arg_Cmd == property_Cmd)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Cmd.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"cmd is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetCmd();
+
+                
+                        property_Cmd = std::string(arg_Cmd.c_str());
+                        isValidCmd = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for cmd
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetCmd()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidCmd = false; 
+               return true;
+           }
+
+           /**
+            * Check whether cmd is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isCmdNil()
+           {
+               return !isValidCmd;
+           }
+
+           /**
+            * Set cmd to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setCmdNil()
+           {
+               return resetCmd();
+           }
+
+           
+
+            /**
+             * Getter for args1 by  Property Number 7
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty7()
+            {
+                return getArgs1();
+            }
+
+            /**
+             * getter for args1.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getArgs1()
+             {
+                return property_Args1;
+             }
+
+            /**
+             * setter for args1
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setArgs1(
+                    const std::string  arg_Args1)
+             {
+                
+
+                if(isValidArgs1 &&
+                        arg_Args1 == property_Args1)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetArgs1();
+
+                
+                        property_Args1 = std::string(arg_Args1.c_str());
+                        isValidArgs1 = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for args1
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetArgs1()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidArgs1 = false; 
+               return true;
+           }
+
+           /**
+            * Check whether args1 is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isArgs1Nil()
+           {
+               return !isValidArgs1;
+           }
+
+           /**
+            * Set args1 to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setArgs1Nil()
+           {
+               return resetArgs1();
+           }
+
+           
+
+            /**
+             * Getter for args2 by  Property Number 8
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty8()
+            {
+                return getArgs2();
+            }
+
+            /**
+             * getter for args2.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getArgs2()
+             {
+                return property_Args2;
+             }
+
+            /**
+             * setter for args2
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setArgs2(
+                    const std::string  arg_Args2)
+             {
+                
+
+                if(isValidArgs2 &&
+                        arg_Args2 == property_Args2)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetArgs2();
+
+                
+                        property_Args2 = std::string(arg_Args2.c_str());
+                        isValidArgs2 = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for args2
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetArgs2()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidArgs2 = false; 
+               return true;
+           }
+
+           /**
+            * Check whether args2 is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isArgs2Nil()
+           {
+               return !isValidArgs2;
+           }
+
+           /**
+            * Set args2 to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setArgs2Nil()
+           {
+               return resetArgs2();
+           }
+
+           
+
+            /**
+             * Getter for held by  Property Number 9
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty9()
+            {
+                return getHeld();
+            }
+
+            /**
+             * getter for held.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getHeld()
+             {
+                return property_Held;
+             }
+
+            /**
+             * setter for held
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setHeld(
+                    const std::string  arg_Held)
+             {
+                
+
+                if(isValidHeld &&
+                        arg_Held == property_Held)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetHeld();
+
+                
+                        property_Held = std::string(arg_Held.c_str());
+                        isValidHeld = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for held
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetHeld()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidHeld = false; 
+               return true;
+           }
+
+           /**
+            * Check whether held is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isHeldNil()
+           {
+               return !isValidHeld;
+           }
+
+           /**
+            * Set held to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setHeldNil()
+           {
+               return resetHeld();
+           }
+
+           
+
+            /**
+             * Getter for released by  Property Number 10
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty10()
+            {
+                return getReleased();
+            }
+
+            /**
+             * getter for released.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getReleased()
+             {
+                return property_Released;
+             }
+
+            /**
+             * setter for released
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setReleased(
+                    const std::string  arg_Released)
+             {
+                
+
+                if(isValidReleased &&
+                        arg_Released == property_Released)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetReleased();
+
+                
+                        property_Released = std::string(arg_Released.c_str());
+                        isValidReleased = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for released
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetReleased()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidReleased = false; 
+               return true;
+           }
+
+           /**
+            * Check whether released is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isReleasedNil()
+           {
+               return !isValidReleased;
+           }
+
+           /**
+            * Set released to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setReleasedNil()
+           {
+               return resetReleased();
+           }
+
+           
+
+            /**
+             * Getter for removed by  Property Number 11
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getProperty11()
+            {
+                return getRemoved();
+            }
+
+            /**
+             * getter for removed.
+             */
+            std::string WSF_CALL
+            AviaryCommon::JobSummary::getRemoved()
+             {
+                return property_Removed;
+             }
+
+            /**
+             * setter for removed
+             */
+            bool WSF_CALL
+            AviaryCommon::JobSummary::setRemoved(
+                    const std::string  arg_Removed)
+             {
+                
+
+                if(isValidRemoved &&
+                        arg_Removed == property_Removed)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetRemoved();
+
+                
+                        property_Removed = std::string(arg_Removed.c_str());
+                        isValidRemoved = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for removed
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::resetRemoved()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidRemoved = false; 
+               return true;
+           }
+
+           /**
+            * Check whether removed is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::isRemovedNil()
+           {
+               return !isValidRemoved;
+           }
+
+           /**
+            * Set removed to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::JobSummary::setRemovedNil()
+           {
+               return resetRemoved();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_OSType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_OSType.cpp
new file mode 100644
index 0000000..75c1fe0
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_OSType.cpp
@@ -0,0 +1,354 @@
+
+
+        /**
+         * OSType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_OSType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the OSType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::OSType::OSType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_OSType;
+                
+            isValidOSType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "OSType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::OSType::OSType(std::string arg_OSType)
+        {
+             
+                   qname = NULL;
+             
+                 property_OSType;
+             
+            isValidOSType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "OSType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_OSType = arg_OSType;
+            
+        }
+        AviaryCommon::OSType::~OSType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            OSType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setOSType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::OSType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element OSType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::OSType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::OSType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::OSType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_OSType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_OSType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::OSType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for OSType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::OSType::getProperty1()
+            {
+                return getOSType();
+            }
+
+            /**
+             * getter for OSType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::OSType::getOSType()
+             {
+                return property_OSType;
+             }
+
+            /**
+             * setter for OSType
+             */
+            bool WSF_CALL
+            AviaryCommon::OSType::setOSType(
+                    const std::string  arg_OSType)
+             {
+                
+
+                if(isValidOSType &&
+                        arg_OSType == property_OSType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_OSType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"OSType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetOSType();
+
+                
+                        property_OSType = std::string(arg_OSType.c_str());
+                        isValidOSType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for OSType.
+             */
+             ADBOSTypeEnum WSF_CALL
+             AviaryCommon::OSType::getOSTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_OSType.c_str(), "LINUX") == 0)
+                    return OSType_LINUX;
+             
+                 if (axutil_strcmp(property_OSType.c_str(), "WINDOWS") == 0)
+                    return OSType_WINDOWS;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBOSTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for OSType.
+             */
+             bool WSF_CALL
+            AviaryCommon::OSType::setOSTypeEnum(const ADBOSTypeEnum  arg_OSType)
+             {
+                
+
+                
+                resetOSType();
+
+                   
+                   switch (arg_OSType)
+                   {
+                     
+                       case OSType_LINUX :
+                            property_OSType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "LINUX");
+                          break;
+                     
+                       case OSType_WINDOWS :
+                            property_OSType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "WINDOWS");
+                          break;
+                     
+                     
+                       default:
+                          isValidOSType = false;
+                          property_OSType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting OSType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_OSType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidOSType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for OSType
+            */
+           bool WSF_CALL
+           AviaryCommon::OSType::resetOSType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidOSType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether OSType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::OSType::isOSTypeNil()
+           {
+               return !isValidOSType;
+           }
+
+           /**
+            * Set OSType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::OSType::setOSTypeNil()
+           {
+               return resetOSType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraint.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraint.cpp
new file mode 100644
index 0000000..ed3dd61
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraint.cpp
@@ -0,0 +1,717 @@
+
+
+        /**
+         * ResourceConstraint.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ResourceConstraint.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = ResourceConstraint
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::ResourceConstraint::ResourceConstraint()
+        {
+
+        
+                property_Type  = NULL;
+              
+            isValidType  = false;
+        
+                    property_Value;
+                
+            isValidValue  = false;
+        
+        }
+
+       AviaryCommon::ResourceConstraint::ResourceConstraint(AviaryCommon::ResourceConstraintType* arg_Type,std::string arg_Value)
+        {
+             
+               property_Type  = NULL;
+             
+            isValidType  = true;
+            
+                 property_Value;
+             
+            isValidValue  = true;
+            
+                    property_Type = arg_Type;
+            
+                    property_Value = arg_Value;
+            
+        }
+        AviaryCommon::ResourceConstraint::~ResourceConstraint()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::ResourceConstraint::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building type element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::ResourceConstraintType* element = new AviaryCommon::ResourceConstraintType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element type");
+                                      }
+                                      else
+                                      {
+                                          status = setType(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building value element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "value", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("value", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setValue(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element value");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setValue("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for value ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element value missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ResourceConstraint::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ResourceConstraint::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ResourceConstraint::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidType)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stype",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stype>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Type->serialize(current_node, parent_element,
+                                                                                 property_Type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidValue)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property value");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("value"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("value")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing value element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%svalue>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Value.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for type by  Property Number 1
+             */
+            AviaryCommon::ResourceConstraintType* WSF_CALL
+            AviaryCommon::ResourceConstraint::getProperty1()
+            {
+                return getType();
+            }
+
+            /**
+             * getter for type.
+             */
+            AviaryCommon::ResourceConstraintType* WSF_CALL
+            AviaryCommon::ResourceConstraint::getType()
+             {
+                return property_Type;
+             }
+
+            /**
+             * setter for type
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceConstraint::setType(
+                    AviaryCommon::ResourceConstraintType*  arg_Type)
+             {
+                
+
+                if(isValidType &&
+                        arg_Type == property_Type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetType();
+
+                
+                    if(NULL == arg_Type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Type = arg_Type;
+                        isValidType = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for type
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::resetType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Type != NULL)
+                {
+                   
+                   
+                         delete  property_Type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::isTypeNil()
+           {
+               return !isValidType;
+           }
+
+           /**
+            * Set type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::setTypeNil()
+           {
+               return resetType();
+           }
+
+           
+
+            /**
+             * Getter for value by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceConstraint::getProperty2()
+            {
+                return getValue();
+            }
+
+            /**
+             * getter for value.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceConstraint::getValue()
+             {
+                return property_Value;
+             }
+
+            /**
+             * setter for value
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceConstraint::setValue(
+                    const std::string  arg_Value)
+             {
+                
+
+                if(isValidValue &&
+                        arg_Value == property_Value)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Value.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"value is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetValue();
+
+                
+                        property_Value = std::string(arg_Value.c_str());
+                        isValidValue = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for value
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::resetValue()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidValue = false; 
+               return true;
+           }
+
+           /**
+            * Check whether value is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::isValueNil()
+           {
+               return !isValidValue;
+           }
+
+           /**
+            * Set value to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraint::setValueNil()
+           {
+               return resetValue();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraintType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraintType.cpp
new file mode 100644
index 0000000..a216860
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceConstraintType.cpp
@@ -0,0 +1,375 @@
+
+
+        /**
+         * ResourceConstraintType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ResourceConstraintType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the ResourceConstraintType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::ResourceConstraintType::ResourceConstraintType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_ResourceConstraintType;
+                
+            isValidResourceConstraintType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ResourceConstraintType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::ResourceConstraintType::ResourceConstraintType(std::string arg_ResourceConstraintType)
+        {
+             
+                   qname = NULL;
+             
+                 property_ResourceConstraintType;
+             
+            isValidResourceConstraintType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ResourceConstraintType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ResourceConstraintType = arg_ResourceConstraintType;
+            
+        }
+        AviaryCommon::ResourceConstraintType::~ResourceConstraintType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            ResourceConstraintType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setResourceConstraintType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::ResourceConstraintType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element ResourceConstraintType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ResourceConstraintType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ResourceConstraintType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::ResourceConstraintType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_ResourceConstraintType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_ResourceConstraintType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ResourceConstraintType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ResourceConstraintType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceConstraintType::getProperty1()
+            {
+                return getResourceConstraintType();
+            }
+
+            /**
+             * getter for ResourceConstraintType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceConstraintType::getResourceConstraintType()
+             {
+                return property_ResourceConstraintType;
+             }
+
+            /**
+             * setter for ResourceConstraintType
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceConstraintType::setResourceConstraintType(
+                    const std::string  arg_ResourceConstraintType)
+             {
+                
+
+                if(isValidResourceConstraintType &&
+                        arg_ResourceConstraintType == property_ResourceConstraintType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_ResourceConstraintType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ResourceConstraintType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetResourceConstraintType();
+
+                
+                        property_ResourceConstraintType = std::string(arg_ResourceConstraintType.c_str());
+                        isValidResourceConstraintType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for ResourceConstraintType.
+             */
+             ADBResourceConstraintTypeEnum WSF_CALL
+             AviaryCommon::ResourceConstraintType::getResourceConstraintTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "OS") == 0)
+                    return ResourceConstraintType_OS;
+             
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "ARCH") == 0)
+                    return ResourceConstraintType_ARCH;
+             
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "MEMORY") == 0)
+                    return ResourceConstraintType_MEMORY;
+             
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "DISK") == 0)
+                    return ResourceConstraintType_DISK;
+             
+                 if (axutil_strcmp(property_ResourceConstraintType.c_str(), "FILESYSTEM") == 0)
+                    return ResourceConstraintType_FILESYSTEM;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBResourceConstraintTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for ResourceConstraintType.
+             */
+             bool WSF_CALL
+            AviaryCommon::ResourceConstraintType::setResourceConstraintTypeEnum(const ADBResourceConstraintTypeEnum  arg_ResourceConstraintType)
+             {
+                
+
+                
+                resetResourceConstraintType();
+
+                   
+                   switch (arg_ResourceConstraintType)
+                   {
+                     
+                       case ResourceConstraintType_OS :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "OS");
+                          break;
+                     
+                       case ResourceConstraintType_ARCH :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "ARCH");
+                          break;
+                     
+                       case ResourceConstraintType_MEMORY :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "MEMORY");
+                          break;
+                     
+                       case ResourceConstraintType_DISK :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "DISK");
+                          break;
+                     
+                       case ResourceConstraintType_FILESYSTEM :
+                            property_ResourceConstraintType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "FILESYSTEM");
+                          break;
+                     
+                     
+                       default:
+                          isValidResourceConstraintType = false;
+                          property_ResourceConstraintType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting ResourceConstraintType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_ResourceConstraintType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidResourceConstraintType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for ResourceConstraintType
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraintType::resetResourceConstraintType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidResourceConstraintType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ResourceConstraintType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraintType::isResourceConstraintTypeNil()
+           {
+               return !isValidResourceConstraintType;
+           }
+
+           /**
+            * Set ResourceConstraintType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceConstraintType::setResourceConstraintTypeNil()
+           {
+               return resetResourceConstraintType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceID.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceID.cpp
new file mode 100644
index 0000000..e38ce4f
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceID.cpp
@@ -0,0 +1,1308 @@
+
+
+        /**
+         * ResourceID.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ResourceID.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = ResourceID
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::ResourceID::ResourceID()
+        {
+
+        
+                property_Subsystem_type  = NULL;
+              
+            isValidSubsystem_type  = false;
+        
+                    property_Pool;
+                
+            isValidPool  = false;
+        
+                    property_Name;
+                
+            isValidName  = false;
+        
+                    property_Custom_name;
+                
+            isValidCustom_name  = false;
+        
+        }
+
+       AviaryCommon::ResourceID::ResourceID(AviaryCommon::ResourceType* arg_Subsystem_type,std::string arg_Pool,std::string arg_Name,std::string arg_Custom_name)
+        {
+             
+               property_Subsystem_type  = NULL;
+             
+            isValidSubsystem_type  = true;
+            
+                 property_Pool;
+             
+            isValidPool  = true;
+            
+                 property_Name;
+             
+            isValidName  = true;
+            
+                 property_Custom_name;
+             
+            isValidCustom_name  = true;
+            
+                    property_Subsystem_type = arg_Subsystem_type;
+            
+                    property_Pool = arg_Pool;
+            
+                    property_Name = arg_Name;
+            
+                    property_Custom_name = arg_Custom_name;
+            
+        }
+        AviaryCommon::ResourceID::~ResourceID()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::ResourceID::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building subsystem_type element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "subsystem_type", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("subsystem_type", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("subsystem_type", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::ResourceType* element = new AviaryCommon::ResourceType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element subsystem_type");
+                                      }
+                                      else
+                                      {
+                                          status = setSubsystem_type(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for subsystem_type ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element subsystem_type missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building pool element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "pool", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("pool", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("pool", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setPool(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element pool");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setPool("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for pool ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element pool missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building name element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setName(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setName("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element name missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building custom_name element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "custom_name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("custom_name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("custom_name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setCustom_name(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element custom_name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setCustom_name("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for custom_name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ResourceID::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ResourceID::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ResourceID::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t *text_value_4;
+                    axis2_char_t *text_value_4_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidSubsystem_type)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property subsystem_type");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("subsystem_type"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("subsystem_type")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing subsystem_type element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%ssubsystem_type",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%ssubsystem_type>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Subsystem_type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Subsystem_type->serialize(current_node, parent_element,
+                                                                                 property_Subsystem_type->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Subsystem_type->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidPool)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property pool");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("pool"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("pool")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing pool element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%spool>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%spool>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Pool.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidName)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property name");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_Name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCustom_name)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("custom_name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("custom_name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing custom_name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scustom_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scustom_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_4 = (axis2_char_t*)property_Custom_name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_4_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_4, true);
+                           if (text_value_4_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_4_temp, axutil_strlen(text_value_4_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_4_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for subsystem_type by  Property Number 1
+             */
+            AviaryCommon::ResourceType* WSF_CALL
+            AviaryCommon::ResourceID::getProperty1()
+            {
+                return getSubsystem_type();
+            }
+
+            /**
+             * getter for subsystem_type.
+             */
+            AviaryCommon::ResourceType* WSF_CALL
+            AviaryCommon::ResourceID::getSubsystem_type()
+             {
+                return property_Subsystem_type;
+             }
+
+            /**
+             * setter for subsystem_type
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceID::setSubsystem_type(
+                    AviaryCommon::ResourceType*  arg_Subsystem_type)
+             {
+                
+
+                if(isValidSubsystem_type &&
+                        arg_Subsystem_type == property_Subsystem_type)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Subsystem_type)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"subsystem_type is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetSubsystem_type();
+
+                
+                    if(NULL == arg_Subsystem_type)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Subsystem_type = arg_Subsystem_type;
+                        isValidSubsystem_type = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for subsystem_type
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::resetSubsystem_type()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Subsystem_type != NULL)
+                {
+                   
+                   
+                         delete  property_Subsystem_type;
+                     
+
+                   }
+
+                
+                
+                
+               isValidSubsystem_type = false; 
+               return true;
+           }
+
+           /**
+            * Check whether subsystem_type is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::isSubsystem_typeNil()
+           {
+               return !isValidSubsystem_type;
+           }
+
+           /**
+            * Set subsystem_type to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::setSubsystem_typeNil()
+           {
+               return resetSubsystem_type();
+           }
+
+           
+
+            /**
+             * Getter for pool by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getProperty2()
+            {
+                return getPool();
+            }
+
+            /**
+             * getter for pool.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getPool()
+             {
+                return property_Pool;
+             }
+
+            /**
+             * setter for pool
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceID::setPool(
+                    const std::string  arg_Pool)
+             {
+                
+
+                if(isValidPool &&
+                        arg_Pool == property_Pool)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Pool.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"pool is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetPool();
+
+                
+                        property_Pool = std::string(arg_Pool.c_str());
+                        isValidPool = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for pool
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::resetPool()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPool = false; 
+               return true;
+           }
+
+           /**
+            * Check whether pool is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::isPoolNil()
+           {
+               return !isValidPool;
+           }
+
+           /**
+            * Set pool to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::setPoolNil()
+           {
+               return resetPool();
+           }
+
+           
+
+            /**
+             * Getter for name by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getProperty3()
+            {
+                return getName();
+            }
+
+            /**
+             * getter for name.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getName()
+             {
+                return property_Name;
+             }
+
+            /**
+             * setter for name
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceID::setName(
+                    const std::string  arg_Name)
+             {
+                
+
+                if(isValidName &&
+                        arg_Name == property_Name)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Name.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"name is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetName();
+
+                
+                        property_Name = std::string(arg_Name.c_str());
+                        isValidName = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for name
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::resetName()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidName = false; 
+               return true;
+           }
+
+           /**
+            * Check whether name is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::isNameNil()
+           {
+               return !isValidName;
+           }
+
+           /**
+            * Set name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::setNameNil()
+           {
+               return resetName();
+           }
+
+           
+
+            /**
+             * Getter for custom_name by  Property Number 4
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getProperty4()
+            {
+                return getCustom_name();
+            }
+
+            /**
+             * getter for custom_name.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceID::getCustom_name()
+             {
+                return property_Custom_name;
+             }
+
+            /**
+             * setter for custom_name
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceID::setCustom_name(
+                    const std::string  arg_Custom_name)
+             {
+                
+
+                if(isValidCustom_name &&
+                        arg_Custom_name == property_Custom_name)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetCustom_name();
+
+                
+                        property_Custom_name = std::string(arg_Custom_name.c_str());
+                        isValidCustom_name = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for custom_name
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::resetCustom_name()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidCustom_name = false; 
+               return true;
+           }
+
+           /**
+            * Check whether custom_name is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::isCustom_nameNil()
+           {
+               return !isValidCustom_name;
+           }
+
+           /**
+            * Set custom_name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceID::setCustom_nameNil()
+           {
+               return resetCustom_name();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceType.cpp
new file mode 100644
index 0000000..04c6865
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_ResourceType.cpp
@@ -0,0 +1,403 @@
+
+
+        /**
+         * ResourceType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_ResourceType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the ResourceType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::ResourceType::ResourceType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_ResourceType;
+                
+            isValidResourceType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ResourceType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::ResourceType::ResourceType(std::string arg_ResourceType)
+        {
+             
+                   qname = NULL;
+             
+                 property_ResourceType;
+             
+            isValidResourceType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ResourceType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ResourceType = arg_ResourceType;
+            
+        }
+        AviaryCommon::ResourceType::~ResourceType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            ResourceType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setResourceType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::ResourceType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element ResourceType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::ResourceType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::ResourceType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::ResourceType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_ResourceType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_ResourceType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::ResourceType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ResourceType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceType::getProperty1()
+            {
+                return getResourceType();
+            }
+
+            /**
+             * getter for ResourceType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::ResourceType::getResourceType()
+             {
+                return property_ResourceType;
+             }
+
+            /**
+             * setter for ResourceType
+             */
+            bool WSF_CALL
+            AviaryCommon::ResourceType::setResourceType(
+                    const std::string  arg_ResourceType)
+             {
+                
+
+                if(isValidResourceType &&
+                        arg_ResourceType == property_ResourceType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_ResourceType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ResourceType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetResourceType();
+
+                
+                        property_ResourceType = std::string(arg_ResourceType.c_str());
+                        isValidResourceType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for ResourceType.
+             */
+             ADBResourceTypeEnum WSF_CALL
+             AviaryCommon::ResourceType::getResourceTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_ResourceType.c_str(), "COLLECTOR") == 0)
+                    return ResourceType_COLLECTOR;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "EXECUTOR") == 0)
+                    return ResourceType_EXECUTOR;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "EVENT_SERVER") == 0)
+                    return ResourceType_EVENT_SERVER;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "JOB_SERVER") == 0)
+                    return ResourceType_JOB_SERVER;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "LOW_LATENCY") == 0)
+                    return ResourceType_LOW_LATENCY;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "MASTER") == 0)
+                    return ResourceType_MASTER;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "NEGOTIATOR") == 0)
+                    return ResourceType_NEGOTIATOR;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "SCHEDULER") == 0)
+                    return ResourceType_SCHEDULER;
+             
+                 if (axutil_strcmp(property_ResourceType.c_str(), "CUSTOM") == 0)
+                    return ResourceType_CUSTOM;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBResourceTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for ResourceType.
+             */
+             bool WSF_CALL
+            AviaryCommon::ResourceType::setResourceTypeEnum(const ADBResourceTypeEnum  arg_ResourceType)
+             {
+                
+
+                
+                resetResourceType();
+
+                   
+                   switch (arg_ResourceType)
+                   {
+                     
+                       case ResourceType_COLLECTOR :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "COLLECTOR");
+                          break;
+                     
+                       case ResourceType_EXECUTOR :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "EXECUTOR");
+                          break;
+                     
+                       case ResourceType_EVENT_SERVER :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "EVENT_SERVER");
+                          break;
+                     
+                       case ResourceType_JOB_SERVER :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "JOB_SERVER");
+                          break;
+                     
+                       case ResourceType_LOW_LATENCY :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "LOW_LATENCY");
+                          break;
+                     
+                       case ResourceType_MASTER :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "MASTER");
+                          break;
+                     
+                       case ResourceType_NEGOTIATOR :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "NEGOTIATOR");
+                          break;
+                     
+                       case ResourceType_SCHEDULER :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "SCHEDULER");
+                          break;
+                     
+                       case ResourceType_CUSTOM :
+                            property_ResourceType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "CUSTOM");
+                          break;
+                     
+                     
+                       default:
+                          isValidResourceType = false;
+                          property_ResourceType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting ResourceType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_ResourceType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidResourceType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for ResourceType
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceType::resetResourceType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidResourceType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ResourceType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceType::isResourceTypeNil()
+           {
+               return !isValidResourceType;
+           }
+
+           /**
+            * Set ResourceType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::ResourceType::setResourceTypeNil()
+           {
+               return resetResourceType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Status.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Status.cpp
new file mode 100644
index 0000000..d959dff
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_Status.cpp
@@ -0,0 +1,698 @@
+
+
+        /**
+         * Status.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_Status.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = Status
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::Status::Status()
+        {
+
+        
+                property_Code  = NULL;
+              
+            isValidCode  = false;
+        
+                    property_Text;
+                
+            isValidText  = false;
+        
+        }
+
+       AviaryCommon::Status::Status(AviaryCommon::StatusCodeType* arg_Code,std::string arg_Text)
+        {
+             
+               property_Code  = NULL;
+             
+            isValidCode  = true;
+            
+                 property_Text;
+             
+            isValidText  = true;
+            
+                    property_Code = arg_Code;
+            
+                    property_Text = arg_Text;
+            
+        }
+        AviaryCommon::Status::~Status()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::Status::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building code element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "code", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("code", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("code", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::StatusCodeType* element = new AviaryCommon::StatusCodeType();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element code");
+                                      }
+                                      else
+                                      {
+                                          status = setCode(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for code ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element code missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building text element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "text", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("text", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("text", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setText(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element text");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setText("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for text ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::Status::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::Status::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::Status::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCode)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property code");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("code"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("code")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing code element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scode",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scode>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Code->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Code->serialize(current_node, parent_element,
+                                                                                 property_Code->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Code->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidText)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("text"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("text")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing text element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%stext>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%stext>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Text.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for code by  Property Number 1
+             */
+            AviaryCommon::StatusCodeType* WSF_CALL
+            AviaryCommon::Status::getProperty1()
+            {
+                return getCode();
+            }
+
+            /**
+             * getter for code.
+             */
+            AviaryCommon::StatusCodeType* WSF_CALL
+            AviaryCommon::Status::getCode()
+             {
+                return property_Code;
+             }
+
+            /**
+             * setter for code
+             */
+            bool WSF_CALL
+            AviaryCommon::Status::setCode(
+                    AviaryCommon::StatusCodeType*  arg_Code)
+             {
+                
+
+                if(isValidCode &&
+                        arg_Code == property_Code)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Code)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"code is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetCode();
+
+                
+                    if(NULL == arg_Code)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Code = arg_Code;
+                        isValidCode = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for code
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::resetCode()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Code != NULL)
+                {
+                   
+                   
+                         delete  property_Code;
+                     
+
+                   }
+
+                
+                
+                
+               isValidCode = false; 
+               return true;
+           }
+
+           /**
+            * Check whether code is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::isCodeNil()
+           {
+               return !isValidCode;
+           }
+
+           /**
+            * Set code to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::setCodeNil()
+           {
+               return resetCode();
+           }
+
+           
+
+            /**
+             * Getter for text by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::Status::getProperty2()
+            {
+                return getText();
+            }
+
+            /**
+             * getter for text.
+             */
+            std::string WSF_CALL
+            AviaryCommon::Status::getText()
+             {
+                return property_Text;
+             }
+
+            /**
+             * setter for text
+             */
+            bool WSF_CALL
+            AviaryCommon::Status::setText(
+                    const std::string  arg_Text)
+             {
+                
+
+                if(isValidText &&
+                        arg_Text == property_Text)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetText();
+
+                
+                        property_Text = std::string(arg_Text.c_str());
+                        isValidText = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for text
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::resetText()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidText = false; 
+               return true;
+           }
+
+           /**
+            * Check whether text is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::isTextNil()
+           {
+               return !isValidText;
+           }
+
+           /**
+            * Set text to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::Status::setTextNil()
+           {
+               return resetText();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_StatusCodeType.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_StatusCodeType.cpp
new file mode 100644
index 0000000..470823a
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_StatusCodeType.cpp
@@ -0,0 +1,382 @@
+
+
+        /**
+         * StatusCodeType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_StatusCodeType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+               /*
+                * Implementation of the StatusCodeType|http://common.aviary.grid.redhat.com Element
+                */
+           AviaryCommon::StatusCodeType::StatusCodeType()
+        {
+
+        
+            qname = NULL;
+        
+                    property_StatusCodeType;
+                
+            isValidStatusCodeType  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "StatusCodeType",
+                        "http://common.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryCommon::StatusCodeType::StatusCodeType(std::string arg_StatusCodeType)
+        {
+             
+                   qname = NULL;
+             
+                 property_StatusCodeType;
+             
+            isValidStatusCodeType  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "StatusCodeType",
+                       "http://common.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_StatusCodeType = arg_StatusCodeType;
+            
+        }
+        AviaryCommon::StatusCodeType::~StatusCodeType()
+        {
+
+        }
+
+        
+            bool WSF_CALL
+            StatusCodeType::deserializeFromString(
+                                            const axis2_char_t *node_value,
+                                            axiom_node_t *parent)
+            {
+              bool status = true;
+            
+                        setStatusCodeType(node_value);
+                    
+              return status;
+            }
+        
+
+        bool WSF_CALL
+        AviaryCommon::StatusCodeType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            
+        status = AXIS2_FAILURE;
+        if(parent)
+        {
+            axis2_char_t *attrib_text = NULL;
+            attrib_text = axiom_element_get_attribute_value_by_name((axiom_element_t*)axiom_node_get_data_element(parent, Environment::getEnv()), Environment::getEnv(), "nil");
+            if (attrib_text != NULL && !axutil_strcasecmp(attrib_text, "true"))
+            {
+              
+               /* but the wsdl says that, this is non nillable */
+                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element StatusCodeType");
+                status = AXIS2_FAILURE;
+               
+            }
+            else
+            {
+                axiom_node_t *text_node = NULL;
+                text_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                axiom_text_t *text_element = NULL;
+                if (text_node &&
+                        axiom_node_get_node_type(text_node, Environment::getEnv()) == AXIOM_TEXT)
+                    text_element = (axiom_text_t*)axiom_node_get_data_element(text_node, Environment::getEnv());
+                text_value = "";
+                if(text_element && axiom_text_get_value(text_element, Environment::getEnv()))
+                {
+                    text_value = (axis2_char_t*)axiom_text_get_value(text_element, Environment::getEnv());
+                }
+                status = deserializeFromString(text_value, parent);
+                }
+            }
+            
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::StatusCodeType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::StatusCodeType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+            char* WSF_CALL
+            AviaryCommon::StatusCodeType::serializeToString(axutil_hash_t *namespaces)
+            {
+                axis2_char_t *text_value = NULL;
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                
+                         text_value = (axis2_char_t*)axutil_xml_quote_string(Environment::getEnv(), (axis2_char_t*)property_StatusCodeType.c_str(), false);
+                         if (!text_value)
+                         {
+                             text_value = (axis2_char_t*)axutil_strdup(Environment::getEnv(), property_StatusCodeType.c_str());
+                         }
+                      
+                return text_value;
+            }
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::StatusCodeType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+            axiom_data_source_t *data_source = NULL;
+            axutil_stream_t *stream = NULL;
+            axis2_char_t *text_value;
+             
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+               if(!parent_tag_closed && !tag_closed)
+               {
+                  text_value = ">"; 
+                  axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+               }
+               
+               text_value = serializeToString(namespaces);
+               if(text_value)
+               {
+                    axutil_stream_write(stream, Environment::getEnv(), text_value, axutil_strlen(text_value));
+                    AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+               }
+            
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for StatusCodeType by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::StatusCodeType::getProperty1()
+            {
+                return getStatusCodeType();
+            }
+
+            /**
+             * getter for StatusCodeType.
+             */
+            std::string WSF_CALL
+            AviaryCommon::StatusCodeType::getStatusCodeType()
+             {
+                return property_StatusCodeType;
+             }
+
+            /**
+             * setter for StatusCodeType
+             */
+            bool WSF_CALL
+            AviaryCommon::StatusCodeType::setStatusCodeType(
+                    const std::string  arg_StatusCodeType)
+             {
+                
+
+                if(isValidStatusCodeType &&
+                        arg_StatusCodeType == property_StatusCodeType)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_StatusCodeType.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"StatusCodeType is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatusCodeType();
+
+                
+                        property_StatusCodeType = std::string(arg_StatusCodeType.c_str());
+                        isValidStatusCodeType = true;
+                    
+                return true;
+             }
+
+            
+             /**
+             * specialized enum getter for StatusCodeType.
+             */
+             ADBStatusCodeTypeEnum WSF_CALL
+             AviaryCommon::StatusCodeType::getStatusCodeTypeEnum()
+             {
+
+                
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "OK") == 0)
+                    return StatusCodeType_OK;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "FAIL") == 0)
+                    return StatusCodeType_FAIL;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "NO_MATCH") == 0)
+                    return StatusCodeType_NO_MATCH;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "INVALID_OFFSET") == 0)
+                    return StatusCodeType_INVALID_OFFSET;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "UNIMPLEMENTED") == 0)
+                    return StatusCodeType_UNIMPLEMENTED;
+             
+                 if (axutil_strcmp(property_StatusCodeType.c_str(), "UNAVAILABLE") == 0)
+                    return StatusCodeType_UNAVAILABLE;
+             
+             
+                 /* Error: none of the strings matched; invalid enum value */
+                 return (ADBStatusCodeTypeEnum)-1;
+             }
+             
+             
+             /**
+             * specialized enum setter for StatusCodeType.
+             */
+             bool WSF_CALL
+            AviaryCommon::StatusCodeType::setStatusCodeTypeEnum(const ADBStatusCodeTypeEnum  arg_StatusCodeType)
+             {
+                
+
+                
+                resetStatusCodeType();
+
+                   
+                   switch (arg_StatusCodeType)
+                   {
+                     
+                       case StatusCodeType_OK :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "OK");
+                          break;
+                     
+                       case StatusCodeType_FAIL :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "FAIL");
+                          break;
+                     
+                       case StatusCodeType_NO_MATCH :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "NO_MATCH");
+                          break;
+                     
+                       case StatusCodeType_INVALID_OFFSET :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "INVALID_OFFSET");
+                          break;
+                     
+                       case StatusCodeType_UNIMPLEMENTED :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "UNIMPLEMENTED");
+                          break;
+                     
+                       case StatusCodeType_UNAVAILABLE :
+                            property_StatusCodeType = (axis2_char_t *)axutil_strdup(Environment::getEnv(), "UNAVAILABLE");
+                          break;
+                     
+                     
+                       default:
+                          isValidStatusCodeType = false;
+                          property_StatusCodeType = "";
+                          WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Error setting StatusCodeType: undefined enum value");
+                          return false;
+                   }
+                
+                   if(property_StatusCodeType.empty())
+                   {
+                       return AXIS2_FAILURE;
+                   }
+                     isValidStatusCodeType = true;
+                        
+                
+                return true;
+             }
+             
+
+           /**
+            * resetter for StatusCodeType
+            */
+           bool WSF_CALL
+           AviaryCommon::StatusCodeType::resetStatusCodeType()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidStatusCodeType = false; 
+               return true;
+           }
+
+           /**
+            * Check whether StatusCodeType is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::StatusCodeType::isStatusCodeTypeNil()
+           {
+               return !isValidStatusCodeType;
+           }
+
+           /**
+            * Set StatusCodeType to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::StatusCodeType::setStatusCodeTypeNil()
+           {
+               return resetStatusCodeType();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionID.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionID.cpp
new file mode 100644
index 0000000..0d23b22
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionID.cpp
@@ -0,0 +1,717 @@
+
+
+        /**
+         * SubmissionID.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_SubmissionID.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = SubmissionID
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::SubmissionID::SubmissionID()
+        {
+
+        
+                    property_Name;
+                
+            isValidName  = false;
+        
+                    property_Owner;
+                
+            isValidOwner  = false;
+        
+        }
+
+       AviaryCommon::SubmissionID::SubmissionID(std::string arg_Name,std::string arg_Owner)
+        {
+             
+                 property_Name;
+             
+            isValidName  = true;
+            
+                 property_Owner;
+             
+            isValidOwner  = true;
+            
+                    property_Name = arg_Name;
+            
+                    property_Owner = arg_Owner;
+            
+        }
+        AviaryCommon::SubmissionID::~SubmissionID()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::SubmissionID::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building name element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setName(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setName("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building owner element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "owner", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("owner", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("owner", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setOwner(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element owner");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setOwner("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for owner ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::SubmissionID::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::SubmissionID::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::SubmissionID::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t *text_value_1;
+                    axis2_char_t *text_value_1_temp;
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidName)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sname>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_1 = (axis2_char_t*)property_Name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_1_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_1, true);
+                           if (text_value_1_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1_temp, axutil_strlen(text_value_1_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_1_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1, axutil_strlen(text_value_1));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidOwner)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("owner"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("owner")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing owner element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sowner>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sowner>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Owner.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for name by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryCommon::SubmissionID::getProperty1()
+            {
+                return getName();
+            }
+
+            /**
+             * getter for name.
+             */
+            std::string WSF_CALL
+            AviaryCommon::SubmissionID::getName()
+             {
+                return property_Name;
+             }
+
+            /**
+             * setter for name
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionID::setName(
+                    const std::string  arg_Name)
+             {
+                
+
+                if(isValidName &&
+                        arg_Name == property_Name)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetName();
+
+                
+                        property_Name = std::string(arg_Name.c_str());
+                        isValidName = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for name
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::resetName()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidName = false; 
+               return true;
+           }
+
+           /**
+            * Check whether name is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::isNameNil()
+           {
+               return !isValidName;
+           }
+
+           /**
+            * Set name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::setNameNil()
+           {
+               return resetName();
+           }
+
+           
+
+            /**
+             * Getter for owner by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryCommon::SubmissionID::getProperty2()
+            {
+                return getOwner();
+            }
+
+            /**
+             * getter for owner.
+             */
+            std::string WSF_CALL
+            AviaryCommon::SubmissionID::getOwner()
+             {
+                return property_Owner;
+             }
+
+            /**
+             * setter for owner
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionID::setOwner(
+                    const std::string  arg_Owner)
+             {
+                
+
+                if(isValidOwner &&
+                        arg_Owner == property_Owner)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetOwner();
+
+                
+                        property_Owner = std::string(arg_Owner.c_str());
+                        isValidOwner = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for owner
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::resetOwner()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidOwner = false; 
+               return true;
+           }
+
+           /**
+            * Check whether owner is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::isOwnerNil()
+           {
+               return !isValidOwner;
+           }
+
+           /**
+            * Set owner to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionID::setOwnerNil()
+           {
+               return resetOwner();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionSummary.cpp b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionSummary.cpp
new file mode 100644
index 0000000..bf367ee
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/common/src/AviaryCommon_SubmissionSummary.cpp
@@ -0,0 +1,2415 @@
+
+
+        /**
+         * SubmissionSummary.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryCommon_SubmissionSummary.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryCommon;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = SubmissionSummary
+                 * Namespace URI = http://common.aviary.grid.redhat.com
+                 * Namespace Prefix = ns1
+                 */
+           AviaryCommon::SubmissionSummary::SubmissionSummary()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+            isValidCompleted  = false;
+        
+            isValidHeld  = false;
+        
+            isValidIdle  = false;
+        
+            isValidRemoved  = false;
+        
+            isValidRunning  = false;
+        
+                property_Jobs  = NULL;
+              
+            isValidJobs  = false;
+        
+        }
+
+       AviaryCommon::SubmissionSummary::SubmissionSummary(AviaryCommon::SubmissionID* arg_Id,AviaryCommon::Status* arg_Status,int arg_Completed,int arg_Held,int arg_Idle,int arg_Removed,int arg_Running,std::vector<AviaryCommon::JobSummary*>* arg_Jobs)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+            isValidCompleted  = true;
+            
+            isValidHeld  = true;
+            
+            isValidIdle  = true;
+            
+            isValidRemoved  = true;
+            
+            isValidRunning  = true;
+            
+               property_Jobs  = NULL;
+             
+            isValidJobs  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+                    property_Completed = arg_Completed;
+            
+                    property_Held = arg_Held;
+            
+                    property_Idle = arg_Idle;
+            
+                    property_Removed = arg_Removed;
+            
+                    property_Running = arg_Running;
+            
+                    property_Jobs = arg_Jobs;
+            
+        }
+        AviaryCommon::SubmissionSummary::~SubmissionSummary()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryCommon::SubmissionSummary::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::SubmissionID* element = new AviaryCommon::SubmissionID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building completed element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "completed", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("completed", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("completed", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setCompleted(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element completed");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for completed ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element completed missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building held element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "held", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("held", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("held", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setHeld(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element held");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for held ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element held missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building idle element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "idle", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("idle", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("idle", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setIdle(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element idle");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for idle ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element idle missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building removed element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "removed", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("removed", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("removed", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setRemoved(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element removed");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for removed ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element removed missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building running element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "running", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("running", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("running", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setRunning(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element running");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for running ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element running missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                       { 
+                    /*
+                     * building Jobs array
+                     */
+                       std::vector<AviaryCommon::JobSummary*>* arr_list =new std::vector<AviaryCommon::JobSummary*>();
+                   
+
+                     
+                     /*
+                      * building jobs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "jobs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = (is_early_node_valid?axiom_node_get_next_sibling(current_node, Environment::getEnv()):current_node); !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("jobs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobSummary* element = new AviaryCommon::JobSummary();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element jobs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for jobs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setJobs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryCommon::SubmissionSummary::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryCommon::SubmissionSummary::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryCommon::SubmissionSummary::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_4[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_5[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_6[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_7[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_8[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCompleted)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property completed");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("completed"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("completed")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing completed element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scompleted>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scompleted>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_3, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Completed);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidHeld)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property held");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("held"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("held")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing held element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sheld>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sheld>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_4, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Held);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIdle)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property idle");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("idle"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("idle")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing idle element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sidle>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sidle>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_5, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Idle);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_5, axutil_strlen(text_value_5));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidRemoved)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property removed");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("removed"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("removed")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing removed element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sremoved>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sremoved>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_6, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Removed);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_6, axutil_strlen(text_value_6));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidRunning)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property running");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("running"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("running")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing running element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%srunning>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%srunning>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_7, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Running);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_7, axutil_strlen(text_value_7));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJobs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("jobs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("jobs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Jobs array
+                      */
+                     if (property_Jobs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sjobs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sjobs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Jobs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobSummary* element = (*property_Jobs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing jobs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryCommon::SubmissionSummary::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setId(
+                    AviaryCommon::SubmissionID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryCommon::SubmissionSummary::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for completed by  Property Number 3
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty3()
+            {
+                return getCompleted();
+            }
+
+            /**
+             * getter for completed.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getCompleted()
+             {
+                return property_Completed;
+             }
+
+            /**
+             * setter for completed
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setCompleted(
+                    const int  arg_Completed)
+             {
+                
+
+                if(isValidCompleted &&
+                        arg_Completed == property_Completed)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetCompleted();
+
+                
+                        property_Completed = arg_Completed;
+                        isValidCompleted = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for completed
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetCompleted()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidCompleted = false; 
+               return true;
+           }
+
+           /**
+            * Check whether completed is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isCompletedNil()
+           {
+               return !isValidCompleted;
+           }
+
+           /**
+            * Set completed to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setCompletedNil()
+           {
+               return resetCompleted();
+           }
+
+           
+
+            /**
+             * Getter for held by  Property Number 4
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty4()
+            {
+                return getHeld();
+            }
+
+            /**
+             * getter for held.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getHeld()
+             {
+                return property_Held;
+             }
+
+            /**
+             * setter for held
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setHeld(
+                    const int  arg_Held)
+             {
+                
+
+                if(isValidHeld &&
+                        arg_Held == property_Held)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetHeld();
+
+                
+                        property_Held = arg_Held;
+                        isValidHeld = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for held
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetHeld()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidHeld = false; 
+               return true;
+           }
+
+           /**
+            * Check whether held is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isHeldNil()
+           {
+               return !isValidHeld;
+           }
+
+           /**
+            * Set held to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setHeldNil()
+           {
+               return resetHeld();
+           }
+
+           
+
+            /**
+             * Getter for idle by  Property Number 5
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty5()
+            {
+                return getIdle();
+            }
+
+            /**
+             * getter for idle.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getIdle()
+             {
+                return property_Idle;
+             }
+
+            /**
+             * setter for idle
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setIdle(
+                    const int  arg_Idle)
+             {
+                
+
+                if(isValidIdle &&
+                        arg_Idle == property_Idle)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetIdle();
+
+                
+                        property_Idle = arg_Idle;
+                        isValidIdle = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for idle
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetIdle()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidIdle = false; 
+               return true;
+           }
+
+           /**
+            * Check whether idle is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isIdleNil()
+           {
+               return !isValidIdle;
+           }
+
+           /**
+            * Set idle to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setIdleNil()
+           {
+               return resetIdle();
+           }
+
+           
+
+            /**
+             * Getter for removed by  Property Number 6
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty6()
+            {
+                return getRemoved();
+            }
+
+            /**
+             * getter for removed.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getRemoved()
+             {
+                return property_Removed;
+             }
+
+            /**
+             * setter for removed
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setRemoved(
+                    const int  arg_Removed)
+             {
+                
+
+                if(isValidRemoved &&
+                        arg_Removed == property_Removed)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetRemoved();
+
+                
+                        property_Removed = arg_Removed;
+                        isValidRemoved = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for removed
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetRemoved()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidRemoved = false; 
+               return true;
+           }
+
+           /**
+            * Check whether removed is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isRemovedNil()
+           {
+               return !isValidRemoved;
+           }
+
+           /**
+            * Set removed to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setRemovedNil()
+           {
+               return resetRemoved();
+           }
+
+           
+
+            /**
+             * Getter for running by  Property Number 7
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty7()
+            {
+                return getRunning();
+            }
+
+            /**
+             * getter for running.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::getRunning()
+             {
+                return property_Running;
+             }
+
+            /**
+             * setter for running
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setRunning(
+                    const int  arg_Running)
+             {
+                
+
+                if(isValidRunning &&
+                        arg_Running == property_Running)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetRunning();
+
+                
+                        property_Running = arg_Running;
+                        isValidRunning = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for running
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetRunning()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidRunning = false; 
+               return true;
+           }
+
+           /**
+            * Check whether running is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isRunningNil()
+           {
+               return !isValidRunning;
+           }
+
+           /**
+            * Set running to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setRunningNil()
+           {
+               return resetRunning();
+           }
+
+           
+
+            /**
+             * Getter for jobs by  Property Number 8
+             */
+            std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+            AviaryCommon::SubmissionSummary::getProperty8()
+            {
+                return getJobs();
+            }
+
+            /**
+             * getter for jobs.
+             */
+            std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+            AviaryCommon::SubmissionSummary::getJobs()
+             {
+                return property_Jobs;
+             }
+
+            /**
+             * setter for jobs
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setJobs(
+                    std::vector<AviaryCommon::JobSummary*>*  arg_Jobs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidJobs &&
+                        arg_Jobs == property_Jobs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Jobs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Jobs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetJobs();
+
+                
+                    if(NULL == arg_Jobs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Jobs = arg_Jobs;
+                        if(non_nil_exists)
+                        {
+                            isValidJobs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of jobs.
+             */
+            AviaryCommon::JobSummary* WSF_CALL
+            AviaryCommon::SubmissionSummary::getJobsAt(int i)
+            {
+                AviaryCommon::JobSummary* ret_val;
+                if(property_Jobs == NULL)
+                {
+                    return (AviaryCommon::JobSummary*)0;
+                }
+                ret_val =   (*property_Jobs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of jobs.
+             */
+           bool WSF_CALL
+            AviaryCommon::SubmissionSummary::setJobsAt(int i,
+                    AviaryCommon::JobSummary* arg_Jobs)
+            {
+                 AviaryCommon::JobSummary* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidJobs &&
+                    property_Jobs &&
+                  
+                    arg_Jobs == (*property_Jobs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobSummary*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Jobs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = true;
+                        (*property_Jobs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Jobs)[i] = arg_Jobs;
+                  
+
+               isValidJobs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to jobs.
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::addJobs(
+                    AviaryCommon::JobSummary* arg_Jobs)
+             {
+
+                
+                    if( NULL == arg_Jobs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobSummary*>();
+                }
+              
+               property_Jobs->push_back(arg_Jobs);
+              
+                isValidJobs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the jobs array.
+             */
+            int WSF_CALL
+            AviaryCommon::SubmissionSummary::sizeofJobs()
+            {
+
+                if(property_Jobs == NULL)
+                {
+                    return 0;
+                }
+                return property_Jobs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryCommon::SubmissionSummary::removeJobsAt(int i)
+            {
+                return setJobsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for jobs
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::resetJobs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Jobs != NULL)
+                {
+                  std::vector<AviaryCommon::JobSummary*>::iterator it =  property_Jobs->begin();
+                  for( ; it <  property_Jobs->end() ; ++it)
+                  {
+                     AviaryCommon::JobSummary* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Jobs)
+                 delete property_Jobs;
+                
+               isValidJobs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether jobs is nill
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isJobsNil()
+           {
+               return !isValidJobs;
+           }
+
+           /**
+            * Set jobs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setJobsNil()
+           {
+               return resetJobs();
+           }
+
+           
+           /**
+            * Check whether jobs is nill at i
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::isJobsNilAt(int i)
+           {
+               return (isValidJobs == false ||
+                       NULL == property_Jobs ||
+                     NULL == (*property_Jobs)[i]);
+            }
+
+           /**
+            * Set jobs to nil at i
+            */
+           bool WSF_CALL
+           AviaryCommon::SubmissionSummary::setJobsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Jobs == NULL ||
+                            isValidJobs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Jobs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Jobs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of jobs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Jobs == NULL)
+                {
+                    isValidJobs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobSummary* element = (*property_Jobs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = false;
+                        (*property_Jobs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Jobs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJob.cpp
new file mode 100644
index 0000000..dc4a46a
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJob.cpp
@@ -0,0 +1,717 @@
+
+
+        /**
+         * ControlJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_ControlJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = ControlJob
+                 * Namespace URI = http://job.aviary.grid.redhat.com
+                 * Namespace Prefix = ns2
+                 */
+           AviaryJob::ControlJob::ControlJob()
+        {
+
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                    property_Reason;
+                
+            isValidReason  = false;
+        
+        }
+
+       AviaryJob::ControlJob::ControlJob(AviaryCommon::JobID* arg_Id,std::string arg_Reason)
+        {
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+                 property_Reason;
+             
+            isValidReason  = true;
+            
+                    property_Id = arg_Id;
+            
+                    property_Reason = arg_Reason;
+            
+        }
+        AviaryJob::ControlJob::~ControlJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::ControlJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building reason element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "reason", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("reason", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("reason", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setReason(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element reason");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setReason("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for reason ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element reason missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::ControlJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::ControlJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::ControlJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidReason)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property reason");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("reason"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("reason")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing reason element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sreason>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sreason>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Reason.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::ControlJob::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::ControlJob::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryJob::ControlJob::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for reason by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryJob::ControlJob::getProperty2()
+            {
+                return getReason();
+            }
+
+            /**
+             * getter for reason.
+             */
+            std::string WSF_CALL
+            AviaryJob::ControlJob::getReason()
+             {
+                return property_Reason;
+             }
+
+            /**
+             * setter for reason
+             */
+            bool WSF_CALL
+            AviaryJob::ControlJob::setReason(
+                    const std::string  arg_Reason)
+             {
+                
+
+                if(isValidReason &&
+                        arg_Reason == property_Reason)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Reason.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"reason is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetReason();
+
+                
+                        property_Reason = std::string(arg_Reason.c_str());
+                        isValidReason = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for reason
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::resetReason()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidReason = false; 
+               return true;
+           }
+
+           /**
+            * Check whether reason is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::isReasonNil()
+           {
+               return !isValidReason;
+           }
+
+           /**
+            * Set reason to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJob::setReasonNil()
+           {
+               return resetReason();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJobResponse.cpp
new file mode 100644
index 0000000..92ac909
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ControlJobResponse.cpp
@@ -0,0 +1,412 @@
+
+
+        /**
+         * ControlJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_ControlJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = ControlJobResponse
+                 * Namespace URI = http://job.aviary.grid.redhat.com
+                 * Namespace Prefix = ns2
+                 */
+           AviaryJob::ControlJobResponse::ControlJobResponse()
+        {
+
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+        }
+
+       AviaryJob::ControlJobResponse::ControlJobResponse(AviaryCommon::Status* arg_Status)
+        {
+             
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+                    property_Status = arg_Status;
+            
+        }
+        AviaryJob::ControlJobResponse::~ControlJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::ControlJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::ControlJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::ControlJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::ControlJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for status by  Property Number 1
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryJob::ControlJobResponse::getProperty1()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryJob::ControlJobResponse::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryJob::ControlJobResponse::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJobResponse::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJobResponse::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ControlJobResponse::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJob.cpp
new file mode 100644
index 0000000..66cd9b2
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJob.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * HoldJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_HoldJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the HoldJob|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::HoldJob::HoldJob()
+        {
+
+        
+            qname = NULL;
+        
+                property_HoldJob  = NULL;
+              
+            isValidHoldJob  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "HoldJob",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::HoldJob::HoldJob(AviaryJob::ControlJob* arg_HoldJob)
+        {
+             
+                   qname = NULL;
+             
+               property_HoldJob  = NULL;
+             
+            isValidHoldJob  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "HoldJob",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_HoldJob = arg_HoldJob;
+            
+        }
+        AviaryJob::HoldJob::~HoldJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::HoldJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for HoldJob : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building HoldJob element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "HoldJob", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJob* element = new AviaryJob::ControlJob();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element HoldJob");
+                                      }
+                                      else
+                                      {
+                                          status = setHoldJob(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for HoldJob ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element HoldJob missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::HoldJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::HoldJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::HoldJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "HoldJob", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidHoldJob)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property HoldJob");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("HoldJob"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("HoldJob")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing HoldJob element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sHoldJob",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sHoldJob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_HoldJob->serialize(current_node, parent_element,
+                                                                                 property_HoldJob->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for HoldJob by  Property Number 1
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::HoldJob::getProperty1()
+            {
+                return getHoldJob();
+            }
+
+            /**
+             * getter for HoldJob.
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::HoldJob::getHoldJob()
+             {
+                return property_HoldJob;
+             }
+
+            /**
+             * setter for HoldJob
+             */
+            bool WSF_CALL
+            AviaryJob::HoldJob::setHoldJob(
+                    AviaryJob::ControlJob*  arg_HoldJob)
+             {
+                
+
+                if(isValidHoldJob &&
+                        arg_HoldJob == property_HoldJob)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_HoldJob)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"HoldJob is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetHoldJob();
+
+                
+                    if(NULL == arg_HoldJob)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_HoldJob = arg_HoldJob;
+                        isValidHoldJob = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for HoldJob
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJob::resetHoldJob()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_HoldJob != NULL)
+                {
+                   
+                   
+                         delete  property_HoldJob;
+                     
+
+                   }
+
+                
+                
+                
+               isValidHoldJob = false; 
+               return true;
+           }
+
+           /**
+            * Check whether HoldJob is nill
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJob::isHoldJobNil()
+           {
+               return !isValidHoldJob;
+           }
+
+           /**
+            * Set HoldJob to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJob::setHoldJobNil()
+           {
+               return resetHoldJob();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJobResponse.cpp
new file mode 100644
index 0000000..1b80bc6
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_HoldJobResponse.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * HoldJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_HoldJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the HoldJobResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::HoldJobResponse::HoldJobResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_HoldJobResponse  = NULL;
+              
+            isValidHoldJobResponse  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "HoldJobResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::HoldJobResponse::HoldJobResponse(AviaryJob::ControlJobResponse* arg_HoldJobResponse)
+        {
+             
+                   qname = NULL;
+             
+               property_HoldJobResponse  = NULL;
+             
+            isValidHoldJobResponse  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "HoldJobResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_HoldJobResponse = arg_HoldJobResponse;
+            
+        }
+        AviaryJob::HoldJobResponse::~HoldJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::HoldJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for HoldJobResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building HoldJobResponse element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "HoldJobResponse", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJobResponse* element = new AviaryJob::ControlJobResponse();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element HoldJobResponse");
+                                      }
+                                      else
+                                      {
+                                          status = setHoldJobResponse(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for HoldJobResponse ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element HoldJobResponse missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::HoldJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::HoldJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::HoldJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "HoldJobResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidHoldJobResponse)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property HoldJobResponse");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("HoldJobResponse"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("HoldJobResponse")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing HoldJobResponse element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sHoldJobResponse",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sHoldJobResponse>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_HoldJobResponse->serialize(current_node, parent_element,
+                                                                                 property_HoldJobResponse->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for HoldJobResponse by  Property Number 1
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::HoldJobResponse::getProperty1()
+            {
+                return getHoldJobResponse();
+            }
+
+            /**
+             * getter for HoldJobResponse.
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::HoldJobResponse::getHoldJobResponse()
+             {
+                return property_HoldJobResponse;
+             }
+
+            /**
+             * setter for HoldJobResponse
+             */
+            bool WSF_CALL
+            AviaryJob::HoldJobResponse::setHoldJobResponse(
+                    AviaryJob::ControlJobResponse*  arg_HoldJobResponse)
+             {
+                
+
+                if(isValidHoldJobResponse &&
+                        arg_HoldJobResponse == property_HoldJobResponse)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_HoldJobResponse)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"HoldJobResponse is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetHoldJobResponse();
+
+                
+                    if(NULL == arg_HoldJobResponse)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_HoldJobResponse = arg_HoldJobResponse;
+                        isValidHoldJobResponse = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for HoldJobResponse
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJobResponse::resetHoldJobResponse()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_HoldJobResponse != NULL)
+                {
+                   
+                   
+                         delete  property_HoldJobResponse;
+                     
+
+                   }
+
+                
+                
+                
+               isValidHoldJobResponse = false; 
+               return true;
+           }
+
+           /**
+            * Check whether HoldJobResponse is nill
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJobResponse::isHoldJobResponseNil()
+           {
+               return !isValidHoldJobResponse;
+           }
+
+           /**
+            * Set HoldJobResponse to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::HoldJobResponse::setHoldJobResponseNil()
+           {
+               return resetHoldJobResponse();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJob.cpp
new file mode 100644
index 0000000..30d9977
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJob.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * ReleaseJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_ReleaseJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the ReleaseJob|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::ReleaseJob::ReleaseJob()
+        {
+
+        
+            qname = NULL;
+        
+                property_ReleaseJob  = NULL;
+              
+            isValidReleaseJob  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ReleaseJob",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::ReleaseJob::ReleaseJob(AviaryJob::ControlJob* arg_ReleaseJob)
+        {
+             
+                   qname = NULL;
+             
+               property_ReleaseJob  = NULL;
+             
+            isValidReleaseJob  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ReleaseJob",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ReleaseJob = arg_ReleaseJob;
+            
+        }
+        AviaryJob::ReleaseJob::~ReleaseJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::ReleaseJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for ReleaseJob : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building ReleaseJob element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "ReleaseJob", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJob* element = new AviaryJob::ControlJob();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element ReleaseJob");
+                                      }
+                                      else
+                                      {
+                                          status = setReleaseJob(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for ReleaseJob ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element ReleaseJob missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::ReleaseJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::ReleaseJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::ReleaseJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "ReleaseJob", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidReleaseJob)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property ReleaseJob");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ReleaseJob"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ReleaseJob")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing ReleaseJob element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sReleaseJob",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sReleaseJob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_ReleaseJob->serialize(current_node, parent_element,
+                                                                                 property_ReleaseJob->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ReleaseJob by  Property Number 1
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::ReleaseJob::getProperty1()
+            {
+                return getReleaseJob();
+            }
+
+            /**
+             * getter for ReleaseJob.
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::ReleaseJob::getReleaseJob()
+             {
+                return property_ReleaseJob;
+             }
+
+            /**
+             * setter for ReleaseJob
+             */
+            bool WSF_CALL
+            AviaryJob::ReleaseJob::setReleaseJob(
+                    AviaryJob::ControlJob*  arg_ReleaseJob)
+             {
+                
+
+                if(isValidReleaseJob &&
+                        arg_ReleaseJob == property_ReleaseJob)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_ReleaseJob)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ReleaseJob is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetReleaseJob();
+
+                
+                    if(NULL == arg_ReleaseJob)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_ReleaseJob = arg_ReleaseJob;
+                        isValidReleaseJob = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for ReleaseJob
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJob::resetReleaseJob()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_ReleaseJob != NULL)
+                {
+                   
+                   
+                         delete  property_ReleaseJob;
+                     
+
+                   }
+
+                
+                
+                
+               isValidReleaseJob = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ReleaseJob is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJob::isReleaseJobNil()
+           {
+               return !isValidReleaseJob;
+           }
+
+           /**
+            * Set ReleaseJob to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJob::setReleaseJobNil()
+           {
+               return resetReleaseJob();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJobResponse.cpp
new file mode 100644
index 0000000..dfabed5
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_ReleaseJobResponse.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * ReleaseJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_ReleaseJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the ReleaseJobResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::ReleaseJobResponse::ReleaseJobResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_ReleaseJobResponse  = NULL;
+              
+            isValidReleaseJobResponse  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "ReleaseJobResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::ReleaseJobResponse::ReleaseJobResponse(AviaryJob::ControlJobResponse* arg_ReleaseJobResponse)
+        {
+             
+                   qname = NULL;
+             
+               property_ReleaseJobResponse  = NULL;
+             
+            isValidReleaseJobResponse  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "ReleaseJobResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_ReleaseJobResponse = arg_ReleaseJobResponse;
+            
+        }
+        AviaryJob::ReleaseJobResponse::~ReleaseJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::ReleaseJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for ReleaseJobResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building ReleaseJobResponse element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "ReleaseJobResponse", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJobResponse* element = new AviaryJob::ControlJobResponse();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element ReleaseJobResponse");
+                                      }
+                                      else
+                                      {
+                                          status = setReleaseJobResponse(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for ReleaseJobResponse ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element ReleaseJobResponse missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::ReleaseJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::ReleaseJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::ReleaseJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "ReleaseJobResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidReleaseJobResponse)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property ReleaseJobResponse");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ReleaseJobResponse"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ReleaseJobResponse")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing ReleaseJobResponse element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sReleaseJobResponse",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sReleaseJobResponse>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_ReleaseJobResponse->serialize(current_node, parent_element,
+                                                                                 property_ReleaseJobResponse->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ReleaseJobResponse by  Property Number 1
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::ReleaseJobResponse::getProperty1()
+            {
+                return getReleaseJobResponse();
+            }
+
+            /**
+             * getter for ReleaseJobResponse.
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::ReleaseJobResponse::getReleaseJobResponse()
+             {
+                return property_ReleaseJobResponse;
+             }
+
+            /**
+             * setter for ReleaseJobResponse
+             */
+            bool WSF_CALL
+            AviaryJob::ReleaseJobResponse::setReleaseJobResponse(
+                    AviaryJob::ControlJobResponse*  arg_ReleaseJobResponse)
+             {
+                
+
+                if(isValidReleaseJobResponse &&
+                        arg_ReleaseJobResponse == property_ReleaseJobResponse)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_ReleaseJobResponse)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ReleaseJobResponse is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetReleaseJobResponse();
+
+                
+                    if(NULL == arg_ReleaseJobResponse)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_ReleaseJobResponse = arg_ReleaseJobResponse;
+                        isValidReleaseJobResponse = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for ReleaseJobResponse
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJobResponse::resetReleaseJobResponse()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_ReleaseJobResponse != NULL)
+                {
+                   
+                   
+                         delete  property_ReleaseJobResponse;
+                     
+
+                   }
+
+                
+                
+                
+               isValidReleaseJobResponse = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ReleaseJobResponse is nill
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJobResponse::isReleaseJobResponseNil()
+           {
+               return !isValidReleaseJobResponse;
+           }
+
+           /**
+            * Set ReleaseJobResponse to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::ReleaseJobResponse::setReleaseJobResponseNil()
+           {
+               return resetReleaseJobResponse();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJob.cpp
new file mode 100644
index 0000000..6b8f85e
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJob.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * RemoveJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_RemoveJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the RemoveJob|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::RemoveJob::RemoveJob()
+        {
+
+        
+            qname = NULL;
+        
+                property_RemoveJob  = NULL;
+              
+            isValidRemoveJob  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "RemoveJob",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::RemoveJob::RemoveJob(AviaryJob::ControlJob* arg_RemoveJob)
+        {
+             
+                   qname = NULL;
+             
+               property_RemoveJob  = NULL;
+             
+            isValidRemoveJob  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "RemoveJob",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_RemoveJob = arg_RemoveJob;
+            
+        }
+        AviaryJob::RemoveJob::~RemoveJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::RemoveJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for RemoveJob : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building RemoveJob element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "RemoveJob", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJob* element = new AviaryJob::ControlJob();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element RemoveJob");
+                                      }
+                                      else
+                                      {
+                                          status = setRemoveJob(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for RemoveJob ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element RemoveJob missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::RemoveJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::RemoveJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::RemoveJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "RemoveJob", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidRemoveJob)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property RemoveJob");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("RemoveJob"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("RemoveJob")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing RemoveJob element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sRemoveJob",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sRemoveJob>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_RemoveJob->serialize(current_node, parent_element,
+                                                                                 property_RemoveJob->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for RemoveJob by  Property Number 1
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::RemoveJob::getProperty1()
+            {
+                return getRemoveJob();
+            }
+
+            /**
+             * getter for RemoveJob.
+             */
+            AviaryJob::ControlJob* WSF_CALL
+            AviaryJob::RemoveJob::getRemoveJob()
+             {
+                return property_RemoveJob;
+             }
+
+            /**
+             * setter for RemoveJob
+             */
+            bool WSF_CALL
+            AviaryJob::RemoveJob::setRemoveJob(
+                    AviaryJob::ControlJob*  arg_RemoveJob)
+             {
+                
+
+                if(isValidRemoveJob &&
+                        arg_RemoveJob == property_RemoveJob)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_RemoveJob)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"RemoveJob is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetRemoveJob();
+
+                
+                    if(NULL == arg_RemoveJob)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_RemoveJob = arg_RemoveJob;
+                        isValidRemoveJob = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for RemoveJob
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJob::resetRemoveJob()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_RemoveJob != NULL)
+                {
+                   
+                   
+                         delete  property_RemoveJob;
+                     
+
+                   }
+
+                
+                
+                
+               isValidRemoveJob = false; 
+               return true;
+           }
+
+           /**
+            * Check whether RemoveJob is nill
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJob::isRemoveJobNil()
+           {
+               return !isValidRemoveJob;
+           }
+
+           /**
+            * Set RemoveJob to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJob::setRemoveJobNil()
+           {
+               return resetRemoveJob();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJobResponse.cpp
new file mode 100644
index 0000000..952425c
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_RemoveJobResponse.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * RemoveJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_RemoveJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the RemoveJobResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::RemoveJobResponse::RemoveJobResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_RemoveJobResponse  = NULL;
+              
+            isValidRemoveJobResponse  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "RemoveJobResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::RemoveJobResponse::RemoveJobResponse(AviaryJob::ControlJobResponse* arg_RemoveJobResponse)
+        {
+             
+                   qname = NULL;
+             
+               property_RemoveJobResponse  = NULL;
+             
+            isValidRemoveJobResponse  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "RemoveJobResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_RemoveJobResponse = arg_RemoveJobResponse;
+            
+        }
+        AviaryJob::RemoveJobResponse::~RemoveJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::RemoveJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for RemoveJobResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building RemoveJobResponse element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "RemoveJobResponse", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJobResponse* element = new AviaryJob::ControlJobResponse();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element RemoveJobResponse");
+                                      }
+                                      else
+                                      {
+                                          status = setRemoveJobResponse(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for RemoveJobResponse ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element RemoveJobResponse missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::RemoveJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::RemoveJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::RemoveJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "RemoveJobResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidRemoveJobResponse)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property RemoveJobResponse");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("RemoveJobResponse"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("RemoveJobResponse")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing RemoveJobResponse element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sRemoveJobResponse",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sRemoveJobResponse>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_RemoveJobResponse->serialize(current_node, parent_element,
+                                                                                 property_RemoveJobResponse->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for RemoveJobResponse by  Property Number 1
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::RemoveJobResponse::getProperty1()
+            {
+                return getRemoveJobResponse();
+            }
+
+            /**
+             * getter for RemoveJobResponse.
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::RemoveJobResponse::getRemoveJobResponse()
+             {
+                return property_RemoveJobResponse;
+             }
+
+            /**
+             * setter for RemoveJobResponse
+             */
+            bool WSF_CALL
+            AviaryJob::RemoveJobResponse::setRemoveJobResponse(
+                    AviaryJob::ControlJobResponse*  arg_RemoveJobResponse)
+             {
+                
+
+                if(isValidRemoveJobResponse &&
+                        arg_RemoveJobResponse == property_RemoveJobResponse)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_RemoveJobResponse)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"RemoveJobResponse is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetRemoveJobResponse();
+
+                
+                    if(NULL == arg_RemoveJobResponse)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_RemoveJobResponse = arg_RemoveJobResponse;
+                        isValidRemoveJobResponse = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for RemoveJobResponse
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJobResponse::resetRemoveJobResponse()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_RemoveJobResponse != NULL)
+                {
+                   
+                   
+                         delete  property_RemoveJobResponse;
+                     
+
+                   }
+
+                
+                
+                
+               isValidRemoveJobResponse = false; 
+               return true;
+           }
+
+           /**
+            * Check whether RemoveJobResponse is nill
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJobResponse::isRemoveJobResponseNil()
+           {
+               return !isValidRemoveJobResponse;
+           }
+
+           /**
+            * Set RemoveJobResponse to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::RemoveJobResponse::setRemoveJobResponseNil()
+           {
+               return resetRemoveJobResponse();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttribute.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttribute.cpp
new file mode 100644
index 0000000..5efdb33
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttribute.cpp
@@ -0,0 +1,720 @@
+
+
+        /**
+         * SetJobAttribute.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_SetJobAttribute.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the SetJobAttribute|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::SetJobAttribute::SetJobAttribute()
+        {
+
+        
+            qname = NULL;
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Attribute  = NULL;
+              
+            isValidAttribute  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "SetJobAttribute",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::SetJobAttribute::SetJobAttribute(AviaryCommon::JobID* arg_Id,AviaryCommon::Attribute* arg_Attribute)
+        {
+             
+                   qname = NULL;
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Attribute  = NULL;
+             
+            isValidAttribute  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "SetJobAttribute",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Id = arg_Id;
+            
+                    property_Attribute = arg_Attribute;
+            
+        }
+        AviaryJob::SetJobAttribute::~SetJobAttribute()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::SetJobAttribute::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for SetJobAttribute : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element id missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building attribute element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "attribute", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("attribute", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("attribute", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Attribute* element = new AviaryCommon::Attribute();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element attribute");
+                                      }
+                                      else
+                                      {
+                                          status = setAttribute(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for attribute ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element attribute missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::SetJobAttribute::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::SetJobAttribute::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::SetJobAttribute::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "SetJobAttribute", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property id");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidAttribute)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property attribute");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("attribute"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("attribute")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing attribute element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sattribute",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sattribute>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Attribute->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Attribute->serialize(current_node, parent_element,
+                                                                                 property_Attribute->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Attribute->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::SetJobAttribute::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::SetJobAttribute::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryJob::SetJobAttribute::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Id)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"id is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for attribute by  Property Number 2
+             */
+            AviaryCommon::Attribute* WSF_CALL
+            AviaryJob::SetJobAttribute::getProperty2()
+            {
+                return getAttribute();
+            }
+
+            /**
+             * getter for attribute.
+             */
+            AviaryCommon::Attribute* WSF_CALL
+            AviaryJob::SetJobAttribute::getAttribute()
+             {
+                return property_Attribute;
+             }
+
+            /**
+             * setter for attribute
+             */
+            bool WSF_CALL
+            AviaryJob::SetJobAttribute::setAttribute(
+                    AviaryCommon::Attribute*  arg_Attribute)
+             {
+                
+
+                if(isValidAttribute &&
+                        arg_Attribute == property_Attribute)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Attribute)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"attribute is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetAttribute();
+
+                
+                    if(NULL == arg_Attribute)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Attribute = arg_Attribute;
+                        isValidAttribute = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for attribute
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::resetAttribute()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Attribute != NULL)
+                {
+                   
+                   
+                         delete  property_Attribute;
+                     
+
+                   }
+
+                
+                
+                
+               isValidAttribute = false; 
+               return true;
+           }
+
+           /**
+            * Check whether attribute is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::isAttributeNil()
+           {
+               return !isValidAttribute;
+           }
+
+           /**
+            * Set attribute to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttribute::setAttributeNil()
+           {
+               return resetAttribute();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttributeResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttributeResponse.cpp
new file mode 100644
index 0000000..a8bc9e7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SetJobAttributeResponse.cpp
@@ -0,0 +1,451 @@
+
+
+        /**
+         * SetJobAttributeResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_SetJobAttributeResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the SetJobAttributeResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::SetJobAttributeResponse::SetJobAttributeResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_SetJobAttributeResponse  = NULL;
+              
+            isValidSetJobAttributeResponse  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "SetJobAttributeResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::SetJobAttributeResponse::SetJobAttributeResponse(AviaryJob::ControlJobResponse* arg_SetJobAttributeResponse)
+        {
+             
+                   qname = NULL;
+             
+               property_SetJobAttributeResponse  = NULL;
+             
+            isValidSetJobAttributeResponse  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "SetJobAttributeResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_SetJobAttributeResponse = arg_SetJobAttributeResponse;
+            
+        }
+        AviaryJob::SetJobAttributeResponse::~SetJobAttributeResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::SetJobAttributeResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = parent;
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for SetJobAttributeResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building SetJobAttributeResponse element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "SetJobAttributeResponse", "http://job.aviary.grid.redhat.com", NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname)))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryJob::ControlJobResponse* element = new AviaryJob::ControlJobResponse();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element SetJobAttributeResponse");
+                                      }
+                                      else
+                                      {
+                                          status = setSetJobAttributeResponse(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for SetJobAttributeResponse ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element SetJobAttributeResponse missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::SetJobAttributeResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::SetJobAttributeResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::SetJobAttributeResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "SetJobAttributeResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       if(!(p_prefix = (axis2_char_t*)axutil_hash_get(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING)))
+                       {
+                           p_prefix = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof (axis2_char_t) * ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT);
+                           sprintf(p_prefix, "n%d", (*next_ns_index)++);
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, p_prefix);
+                           
+                           axiom_element_declare_namespace_assume_param_ownership(parent_element, Environment::getEnv(), axiom_namespace_create (Environment::getEnv(),
+                                            "http://job.aviary.grid.redhat.com", p_prefix));
+                       }
+                      
+
+                   if (!isValidSetJobAttributeResponse)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property SetJobAttributeResponse");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("SetJobAttributeResponse"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("SetJobAttributeResponse")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing SetJobAttributeResponse element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sSetJobAttributeResponse",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sSetJobAttributeResponse>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    property_SetJobAttributeResponse->serialize(current_node, parent_element,
+                                                                                 property_SetJobAttributeResponse->isParticle() || true, namespaces, next_ns_index);
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for SetJobAttributeResponse by  Property Number 1
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::SetJobAttributeResponse::getProperty1()
+            {
+                return getSetJobAttributeResponse();
+            }
+
+            /**
+             * getter for SetJobAttributeResponse.
+             */
+            AviaryJob::ControlJobResponse* WSF_CALL
+            AviaryJob::SetJobAttributeResponse::getSetJobAttributeResponse()
+             {
+                return property_SetJobAttributeResponse;
+             }
+
+            /**
+             * setter for SetJobAttributeResponse
+             */
+            bool WSF_CALL
+            AviaryJob::SetJobAttributeResponse::setSetJobAttributeResponse(
+                    AviaryJob::ControlJobResponse*  arg_SetJobAttributeResponse)
+             {
+                
+
+                if(isValidSetJobAttributeResponse &&
+                        arg_SetJobAttributeResponse == property_SetJobAttributeResponse)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_SetJobAttributeResponse)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"SetJobAttributeResponse is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetSetJobAttributeResponse();
+
+                
+                    if(NULL == arg_SetJobAttributeResponse)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_SetJobAttributeResponse = arg_SetJobAttributeResponse;
+                        isValidSetJobAttributeResponse = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for SetJobAttributeResponse
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttributeResponse::resetSetJobAttributeResponse()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_SetJobAttributeResponse != NULL)
+                {
+                   
+                   
+                         delete  property_SetJobAttributeResponse;
+                     
+
+                   }
+
+                
+                
+                
+               isValidSetJobAttributeResponse = false; 
+               return true;
+           }
+
+           /**
+            * Check whether SetJobAttributeResponse is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttributeResponse::isSetJobAttributeResponseNil()
+           {
+               return !isValidSetJobAttributeResponse;
+           }
+
+           /**
+            * Set SetJobAttributeResponse to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SetJobAttributeResponse::setSetJobAttributeResponseNil()
+           {
+               return resetSetJobAttributeResponse();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJob.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJob.cpp
new file mode 100644
index 0000000..2a6970f
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJob.cpp
@@ -0,0 +1,3030 @@
+
+
+        /**
+         * SubmitJob.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_SubmitJob.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the SubmitJob|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::SubmitJob::SubmitJob()
+        {
+
+        
+            qname = NULL;
+        
+                    property_Cmd;
+                
+            isValidCmd  = false;
+        
+                    property_Args;
+                
+            isValidArgs  = false;
+        
+                    property_Owner;
+                
+            isValidOwner  = false;
+        
+                    property_Iwd;
+                
+            isValidIwd  = false;
+        
+                    property_Submission_name;
+                
+            isValidSubmission_name  = false;
+        
+                property_Requirements  = NULL;
+              
+            isValidRequirements  = false;
+        
+                property_Extra  = NULL;
+              
+            isValidExtra  = false;
+        
+            isValidAllowOverrides  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "SubmitJob",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::SubmitJob::SubmitJob(std::string arg_Cmd,std::string arg_Args,std::string arg_Owner,std::string arg_Iwd,std::string arg_Submission_name,std::vector<AviaryCommon::ResourceConstraint*>* arg_Requirements,std::vector<AviaryCommon::Attribute*>* arg_Extra,bool arg_AllowOverrides)
+        {
+             
+                   qname = NULL;
+             
+                 property_Cmd;
+             
+            isValidCmd  = true;
+            
+                 property_Args;
+             
+            isValidArgs  = true;
+            
+                 property_Owner;
+             
+            isValidOwner  = true;
+            
+                 property_Iwd;
+             
+            isValidIwd  = true;
+            
+                 property_Submission_name;
+             
+            isValidSubmission_name  = true;
+            
+               property_Requirements  = NULL;
+             
+            isValidRequirements  = true;
+            
+               property_Extra  = NULL;
+             
+            isValidExtra  = true;
+            
+            isValidAllowOverrides  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "SubmitJob",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Cmd = arg_Cmd;
+            
+                    property_Args = arg_Args;
+            
+                    property_Owner = arg_Owner;
+            
+                    property_Iwd = arg_Iwd;
+            
+                    property_Submission_name = arg_Submission_name;
+            
+                    property_Requirements = arg_Requirements;
+            
+                    property_Extra = arg_Extra;
+            
+                    property_AllowOverrides = arg_AllowOverrides;
+            
+        }
+        AviaryJob::SubmitJob::~SubmitJob()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::SubmitJob::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for SubmitJob : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+
+                     
+                     /*
+                      * building cmd element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "cmd", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("cmd", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("cmd", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setCmd(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element cmd");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setCmd("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for cmd ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element cmd missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building args element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "args", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("args", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setArgs(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element args");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setArgs("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for args ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building owner element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "owner", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("owner", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("owner", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setOwner(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element owner");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setOwner("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for owner ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element owner missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building iwd element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "iwd", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("iwd", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("iwd", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setIwd(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element iwd");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setIwd("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for iwd ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element iwd missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building submission_name element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "submission_name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submission_name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submission_name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setSubmission_name(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element submission_name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setSubmission_name("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for submission_name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                       { 
+                    /*
+                     * building Requirements array
+                     */
+                       std::vector<AviaryCommon::ResourceConstraint*>* arr_list =new std::vector<AviaryCommon::ResourceConstraint*>();
+                   
+
+                     
+                     /*
+                      * building requirements element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "requirements", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = (is_early_node_valid?axiom_node_get_next_sibling(current_node, Environment::getEnv()):current_node); !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("requirements", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::ResourceConstraint* element = new AviaryCommon::ResourceConstraint();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element requirements ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for requirements ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"requirements (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setRequirements(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                       { 
+                    /*
+                     * building Extra array
+                     */
+                       std::vector<AviaryCommon::Attribute*>* arr_list =new std::vector<AviaryCommon::Attribute*>();
+                   
+
+                     
+                     /*
+                      * building extra element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "extra", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = (is_early_node_valid?axiom_node_get_next_sibling(current_node, Environment::getEnv()):current_node); !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("extra", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::Attribute* element = new AviaryCommon::Attribute();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element extra ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for extra ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"extra (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setExtra(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "allowOverrides"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "allowOverrides", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "allowOverrides");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setAllowOverrides(true);
+                           }
+                           else
+                           {
+                               setAllowOverrides(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::SubmitJob::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::SubmitJob::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::SubmitJob::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t *text_value_1;
+                    axis2_char_t *text_value_1_temp;
+                    
+                    axis2_char_t *text_value_2;
+                    axis2_char_t *text_value_2_temp;
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t *text_value_4;
+                    axis2_char_t *text_value_4_temp;
+                    
+                    axis2_char_t *text_value_5;
+                    axis2_char_t *text_value_5_temp;
+                    
+                    axis2_char_t text_value_6[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_7[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_8[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "SubmitJob", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidAllowOverrides)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_AllowOverrides)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("allowOverrides")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "allowOverrides",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidCmd)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property cmd");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("cmd"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("cmd")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing cmd element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scmd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scmd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_1 = (axis2_char_t*)property_Cmd.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_1_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_1, true);
+                           if (text_value_1_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1_temp, axutil_strlen(text_value_1_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_1_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_1, axutil_strlen(text_value_1));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidArgs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("args"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("args")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing args element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sargs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sargs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_2 = (axis2_char_t*)property_Args.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_2_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_2, true);
+                           if (text_value_2_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2_temp, axutil_strlen(text_value_2_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_2_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidOwner)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property owner");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("owner"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("owner")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing owner element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sowner>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sowner>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_Owner.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIwd)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property iwd");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("iwd"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("iwd")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing iwd element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%siwd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%siwd>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_4 = (axis2_char_t*)property_Iwd.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_4_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_4, true);
+                           if (text_value_4_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_4_temp, axutil_strlen(text_value_4_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_4_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidSubmission_name)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("submission_name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("submission_name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing submission_name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%ssubmission_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%ssubmission_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_5 = (axis2_char_t*)property_Submission_name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_5_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_5, true);
+                           if (text_value_5_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_5_temp, axutil_strlen(text_value_5_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_5_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_5, axutil_strlen(text_value_5));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidRequirements)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("requirements"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("requirements")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Requirements array
+                      */
+                     if (property_Requirements != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%srequirements",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%srequirements>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Requirements->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::ResourceConstraint* element = (*property_Requirements)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing requirements element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidExtra)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("extra"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("extra")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Extra array
+                      */
+                     if (property_Extra != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sextra",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sextra>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Extra->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::Attribute* element = (*property_Extra)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing extra element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidAllowOverrides)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_AllowOverrides)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "allowOverrides", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for cmd by  Property Number 1
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty1()
+            {
+                return getCmd();
+            }
+
+            /**
+             * getter for cmd.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getCmd()
+             {
+                return property_Cmd;
+             }
+
+            /**
+             * setter for cmd
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setCmd(
+                    const std::string  arg_Cmd)
+             {
+                
+
+                if(isValidCmd &&
+                        arg_Cmd == property_Cmd)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Cmd.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"cmd is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetCmd();
+
+                
+                        property_Cmd = std::string(arg_Cmd.c_str());
+                        isValidCmd = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for cmd
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetCmd()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidCmd = false; 
+               return true;
+           }
+
+           /**
+            * Check whether cmd is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isCmdNil()
+           {
+               return !isValidCmd;
+           }
+
+           /**
+            * Set cmd to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setCmdNil()
+           {
+               return resetCmd();
+           }
+
+           
+
+            /**
+             * Getter for args by  Property Number 2
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty2()
+            {
+                return getArgs();
+            }
+
+            /**
+             * getter for args.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getArgs()
+             {
+                return property_Args;
+             }
+
+            /**
+             * setter for args
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setArgs(
+                    const std::string  arg_Args)
+             {
+                
+
+                if(isValidArgs &&
+                        arg_Args == property_Args)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetArgs();
+
+                
+                        property_Args = std::string(arg_Args.c_str());
+                        isValidArgs = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for args
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetArgs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidArgs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether args is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isArgsNil()
+           {
+               return !isValidArgs;
+           }
+
+           /**
+            * Set args to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setArgsNil()
+           {
+               return resetArgs();
+           }
+
+           
+
+            /**
+             * Getter for owner by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty3()
+            {
+                return getOwner();
+            }
+
+            /**
+             * getter for owner.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getOwner()
+             {
+                return property_Owner;
+             }
+
+            /**
+             * setter for owner
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setOwner(
+                    const std::string  arg_Owner)
+             {
+                
+
+                if(isValidOwner &&
+                        arg_Owner == property_Owner)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Owner.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"owner is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetOwner();
+
+                
+                        property_Owner = std::string(arg_Owner.c_str());
+                        isValidOwner = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for owner
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetOwner()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidOwner = false; 
+               return true;
+           }
+
+           /**
+            * Check whether owner is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isOwnerNil()
+           {
+               return !isValidOwner;
+           }
+
+           /**
+            * Set owner to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setOwnerNil()
+           {
+               return resetOwner();
+           }
+
+           
+
+            /**
+             * Getter for iwd by  Property Number 4
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty4()
+            {
+                return getIwd();
+            }
+
+            /**
+             * getter for iwd.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getIwd()
+             {
+                return property_Iwd;
+             }
+
+            /**
+             * setter for iwd
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setIwd(
+                    const std::string  arg_Iwd)
+             {
+                
+
+                if(isValidIwd &&
+                        arg_Iwd == property_Iwd)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(arg_Iwd.empty())
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"iwd is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetIwd();
+
+                
+                        property_Iwd = std::string(arg_Iwd.c_str());
+                        isValidIwd = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for iwd
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetIwd()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidIwd = false; 
+               return true;
+           }
+
+           /**
+            * Check whether iwd is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isIwdNil()
+           {
+               return !isValidIwd;
+           }
+
+           /**
+            * Set iwd to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setIwdNil()
+           {
+               return resetIwd();
+           }
+
+           
+
+            /**
+             * Getter for submission_name by  Property Number 5
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getProperty5()
+            {
+                return getSubmission_name();
+            }
+
+            /**
+             * getter for submission_name.
+             */
+            std::string WSF_CALL
+            AviaryJob::SubmitJob::getSubmission_name()
+             {
+                return property_Submission_name;
+             }
+
+            /**
+             * setter for submission_name
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setSubmission_name(
+                    const std::string  arg_Submission_name)
+             {
+                
+
+                if(isValidSubmission_name &&
+                        arg_Submission_name == property_Submission_name)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetSubmission_name();
+
+                
+                        property_Submission_name = std::string(arg_Submission_name.c_str());
+                        isValidSubmission_name = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for submission_name
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetSubmission_name()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidSubmission_name = false; 
+               return true;
+           }
+
+           /**
+            * Check whether submission_name is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isSubmission_nameNil()
+           {
+               return !isValidSubmission_name;
+           }
+
+           /**
+            * Set submission_name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setSubmission_nameNil()
+           {
+               return resetSubmission_name();
+           }
+
+           
+
+            /**
+             * Getter for requirements by  Property Number 6
+             */
+            std::vector<AviaryCommon::ResourceConstraint*>* WSF_CALL
+            AviaryJob::SubmitJob::getProperty6()
+            {
+                return getRequirements();
+            }
+
+            /**
+             * getter for requirements.
+             */
+            std::vector<AviaryCommon::ResourceConstraint*>* WSF_CALL
+            AviaryJob::SubmitJob::getRequirements()
+             {
+                return property_Requirements;
+             }
+
+            /**
+             * setter for requirements
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setRequirements(
+                    std::vector<AviaryCommon::ResourceConstraint*>*  arg_Requirements)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidRequirements &&
+                        arg_Requirements == property_Requirements)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Requirements->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"requirements has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Requirements)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetRequirements();
+
+                
+                    if(NULL == arg_Requirements)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Requirements = arg_Requirements;
+                        if(non_nil_exists)
+                        {
+                            isValidRequirements = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of requirements.
+             */
+            AviaryCommon::ResourceConstraint* WSF_CALL
+            AviaryJob::SubmitJob::getRequirementsAt(int i)
+            {
+                AviaryCommon::ResourceConstraint* ret_val;
+                if(property_Requirements == NULL)
+                {
+                    return (AviaryCommon::ResourceConstraint*)0;
+                }
+                ret_val =   (*property_Requirements)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of requirements.
+             */
+           bool WSF_CALL
+            AviaryJob::SubmitJob::setRequirementsAt(int i,
+                    AviaryCommon::ResourceConstraint* arg_Requirements)
+            {
+                 AviaryCommon::ResourceConstraint* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidRequirements &&
+                    property_Requirements &&
+                  
+                    arg_Requirements == (*property_Requirements)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Requirements == NULL)
+                {
+                    property_Requirements = new std::vector<AviaryCommon::ResourceConstraint*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Requirements)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidRequirements = true;
+                        (*property_Requirements)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Requirements)[i] = arg_Requirements;
+                  
+
+               isValidRequirements = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to requirements.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::addRequirements(
+                    AviaryCommon::ResourceConstraint* arg_Requirements)
+             {
+
+                
+                    if( NULL == arg_Requirements
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Requirements == NULL)
+                {
+                    property_Requirements = new std::vector<AviaryCommon::ResourceConstraint*>();
+                }
+              
+               property_Requirements->push_back(arg_Requirements);
+              
+                isValidRequirements = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the requirements array.
+             */
+            int WSF_CALL
+            AviaryJob::SubmitJob::sizeofRequirements()
+            {
+
+                if(property_Requirements == NULL)
+                {
+                    return 0;
+                }
+                return property_Requirements->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::removeRequirementsAt(int i)
+            {
+                return setRequirementsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for requirements
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetRequirements()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Requirements != NULL)
+                {
+                  std::vector<AviaryCommon::ResourceConstraint*>::iterator it =  property_Requirements->begin();
+                  for( ; it <  property_Requirements->end() ; ++it)
+                  {
+                     AviaryCommon::ResourceConstraint* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Requirements)
+                 delete property_Requirements;
+                
+               isValidRequirements = false; 
+               return true;
+           }
+
+           /**
+            * Check whether requirements is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isRequirementsNil()
+           {
+               return !isValidRequirements;
+           }
+
+           /**
+            * Set requirements to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setRequirementsNil()
+           {
+               return resetRequirements();
+           }
+
+           
+           /**
+            * Check whether requirements is nill at i
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isRequirementsNilAt(int i)
+           {
+               return (isValidRequirements == false ||
+                       NULL == property_Requirements ||
+                     NULL == (*property_Requirements)[i]);
+            }
+
+           /**
+            * Set requirements to nil at i
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setRequirementsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Requirements == NULL ||
+                            isValidRequirements == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Requirements->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Requirements)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of requirements is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Requirements == NULL)
+                {
+                    isValidRequirements = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::ResourceConstraint* element = (*property_Requirements)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidRequirements = false;
+                        (*property_Requirements)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Requirements)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for extra by  Property Number 7
+             */
+            std::vector<AviaryCommon::Attribute*>* WSF_CALL
+            AviaryJob::SubmitJob::getProperty7()
+            {
+                return getExtra();
+            }
+
+            /**
+             * getter for extra.
+             */
+            std::vector<AviaryCommon::Attribute*>* WSF_CALL
+            AviaryJob::SubmitJob::getExtra()
+             {
+                return property_Extra;
+             }
+
+            /**
+             * setter for extra
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setExtra(
+                    std::vector<AviaryCommon::Attribute*>*  arg_Extra)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidExtra &&
+                        arg_Extra == property_Extra)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Extra->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"extra has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Extra)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetExtra();
+
+                
+                    if(NULL == arg_Extra)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Extra = arg_Extra;
+                        if(non_nil_exists)
+                        {
+                            isValidExtra = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of extra.
+             */
+            AviaryCommon::Attribute* WSF_CALL
+            AviaryJob::SubmitJob::getExtraAt(int i)
+            {
+                AviaryCommon::Attribute* ret_val;
+                if(property_Extra == NULL)
+                {
+                    return (AviaryCommon::Attribute*)0;
+                }
+                ret_val =   (*property_Extra)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of extra.
+             */
+           bool WSF_CALL
+            AviaryJob::SubmitJob::setExtraAt(int i,
+                    AviaryCommon::Attribute* arg_Extra)
+            {
+                 AviaryCommon::Attribute* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidExtra &&
+                    property_Extra &&
+                  
+                    arg_Extra == (*property_Extra)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Extra == NULL)
+                {
+                    property_Extra = new std::vector<AviaryCommon::Attribute*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Extra)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidExtra = true;
+                        (*property_Extra)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Extra)[i] = arg_Extra;
+                  
+
+               isValidExtra = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to extra.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::addExtra(
+                    AviaryCommon::Attribute* arg_Extra)
+             {
+
+                
+                    if( NULL == arg_Extra
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Extra == NULL)
+                {
+                    property_Extra = new std::vector<AviaryCommon::Attribute*>();
+                }
+              
+               property_Extra->push_back(arg_Extra);
+              
+                isValidExtra = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the extra array.
+             */
+            int WSF_CALL
+            AviaryJob::SubmitJob::sizeofExtra()
+            {
+
+                if(property_Extra == NULL)
+                {
+                    return 0;
+                }
+                return property_Extra->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::removeExtraAt(int i)
+            {
+                return setExtraNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for extra
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetExtra()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Extra != NULL)
+                {
+                  std::vector<AviaryCommon::Attribute*>::iterator it =  property_Extra->begin();
+                  for( ; it <  property_Extra->end() ; ++it)
+                  {
+                     AviaryCommon::Attribute* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Extra)
+                 delete property_Extra;
+                
+               isValidExtra = false; 
+               return true;
+           }
+
+           /**
+            * Check whether extra is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isExtraNil()
+           {
+               return !isValidExtra;
+           }
+
+           /**
+            * Set extra to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setExtraNil()
+           {
+               return resetExtra();
+           }
+
+           
+           /**
+            * Check whether extra is nill at i
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isExtraNilAt(int i)
+           {
+               return (isValidExtra == false ||
+                       NULL == property_Extra ||
+                     NULL == (*property_Extra)[i]);
+            }
+
+           /**
+            * Set extra to nil at i
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setExtraNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Extra == NULL ||
+                            isValidExtra == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Extra->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Extra)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of extra is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Extra == NULL)
+                {
+                    isValidExtra = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::Attribute* element = (*property_Extra)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidExtra = false;
+                        (*property_Extra)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Extra)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for allowOverrides by  Property Number 8
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::getProperty8()
+            {
+                return getAllowOverrides();
+            }
+
+            /**
+             * getter for allowOverrides.
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::getAllowOverrides()
+             {
+                return property_AllowOverrides;
+             }
+
+            /**
+             * setter for allowOverrides
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJob::setAllowOverrides(
+                    bool  arg_AllowOverrides)
+             {
+                
+
+                if(isValidAllowOverrides &&
+                        arg_AllowOverrides == property_AllowOverrides)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetAllowOverrides();
+
+                
+                        property_AllowOverrides = arg_AllowOverrides;
+                        isValidAllowOverrides = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for allowOverrides
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::resetAllowOverrides()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidAllowOverrides = false; 
+               return true;
+           }
+
+           /**
+            * Check whether allowOverrides is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::isAllowOverridesNil()
+           {
+               return !isValidAllowOverrides;
+           }
+
+           /**
+            * Set allowOverrides to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJob::setAllowOverridesNil()
+           {
+               return resetAllowOverrides();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJobResponse.cpp b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJobResponse.cpp
new file mode 100644
index 0000000..fe0f2ed
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/job/src/AviaryJob_SubmitJobResponse.cpp
@@ -0,0 +1,701 @@
+
+
+        /**
+         * SubmitJobResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryJob_SubmitJobResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryJob;
+        
+               /*
+                * Implementation of the SubmitJobResponse|http://job.aviary.grid.redhat.com Element
+                */
+           AviaryJob::SubmitJobResponse::SubmitJobResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Id  = NULL;
+              
+            isValidId  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "SubmitJobResponse",
+                        "http://job.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryJob::SubmitJobResponse::SubmitJobResponse(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status)
+        {
+             
+                   qname = NULL;
+             
+               property_Id  = NULL;
+             
+            isValidId  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "SubmitJobResponse",
+                       "http://job.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Id = arg_Id;
+            
+                    property_Status = arg_Status;
+            
+        }
+        AviaryJob::SubmitJobResponse::~SubmitJobResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryJob::SubmitJobResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for SubmitJobResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building id element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "id", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("id", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobID* element = new AviaryCommon::JobID();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element id");
+                                      }
+                                      else
+                                      {
+                                          status = setId(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for id ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryJob::SubmitJobResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryJob::SubmitJobResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryJob::SubmitJobResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://job.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://job.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "SubmitJobResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidId)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("id"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("id")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing id element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sid",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sid>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Id->serialize(current_node, parent_element,
+                                                                                 property_Id->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Id->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for id by  Property Number 1
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::SubmitJobResponse::getProperty1()
+            {
+                return getId();
+            }
+
+            /**
+             * getter for id.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryJob::SubmitJobResponse::getId()
+             {
+                return property_Id;
+             }
+
+            /**
+             * setter for id
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJobResponse::setId(
+                    AviaryCommon::JobID*  arg_Id)
+             {
+                
+
+                if(isValidId &&
+                        arg_Id == property_Id)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetId();
+
+                
+                    if(NULL == arg_Id)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Id = arg_Id;
+                        isValidId = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for id
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::resetId()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Id != NULL)
+                {
+                   
+                   
+                         delete  property_Id;
+                     
+
+                   }
+
+                
+                
+                
+               isValidId = false; 
+               return true;
+           }
+
+           /**
+            * Check whether id is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::isIdNil()
+           {
+               return !isValidId;
+           }
+
+           /**
+            * Set id to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::setIdNil()
+           {
+               return resetId();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryJob::SubmitJobResponse::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryJob::SubmitJobResponse::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryJob::SubmitJobResponse::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryJob::SubmitJobResponse::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobData.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobData.cpp
new file mode 100644
index 0000000..142f4b7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobData.cpp
@@ -0,0 +1,910 @@
+
+
+        /**
+         * GetJobData.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobData.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobData|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobData::GetJobData()
+        {
+
+        
+            qname = NULL;
+        
+                property_Data  = NULL;
+              
+            isValidData  = false;
+        
+            isValidMax_bytes  = false;
+        
+            isValidFrom_end  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobData",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobData::GetJobData(AviaryCommon::JobData* arg_Data,int arg_Max_bytes,bool arg_From_end)
+        {
+             
+                   qname = NULL;
+             
+               property_Data  = NULL;
+             
+            isValidData  = true;
+            
+            isValidMax_bytes  = true;
+            
+            isValidFrom_end  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobData",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Data = arg_Data;
+            
+                    property_Max_bytes = arg_Max_bytes;
+            
+                    property_From_end = arg_From_end;
+            
+        }
+        AviaryQuery::GetJobData::~GetJobData()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobData::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobData : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building data element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "data", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("data", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("data", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobData* element = new AviaryCommon::JobData();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element data");
+                                      }
+                                      else
+                                      {
+                                          status = setData(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for data ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element data missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building max_bytes element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "max_bytes", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("max_bytes", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("max_bytes", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setMax_bytes(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element max_bytes");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for max_bytes ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element max_bytes missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building from_end element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "from_end", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("from_end", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("from_end", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            if (!axutil_strcasecmp(text_value , "true"))
+                                            {
+                                                status = setFrom_end(true);
+                                            }
+                                            else
+                                            {
+                                                status = setFrom_end(false);
+                                            }
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element from_end");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for from_end ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobData::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobData::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobData::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobData", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidData)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property data");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("data"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("data")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing data element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sdata",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sdata>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Data->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Data->serialize(current_node, parent_element,
+                                                                                 property_Data->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Data->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidMax_bytes)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property max_bytes");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("max_bytes"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("max_bytes")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing max_bytes element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%smax_bytes>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%smax_bytes>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_2, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_Max_bytes);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_2, axutil_strlen(text_value_2));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidFrom_end)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("from_end"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("from_end")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing from_end element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sfrom_end>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sfrom_end>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           strcpy(text_value_3, (property_From_end)?"true":"false");
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for data by  Property Number 1
+             */
+            AviaryCommon::JobData* WSF_CALL
+            AviaryQuery::GetJobData::getProperty1()
+            {
+                return getData();
+            }
+
+            /**
+             * getter for data.
+             */
+            AviaryCommon::JobData* WSF_CALL
+            AviaryQuery::GetJobData::getData()
+             {
+                return property_Data;
+             }
+
+            /**
+             * setter for data
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::setData(
+                    AviaryCommon::JobData*  arg_Data)
+             {
+                
+
+                if(isValidData &&
+                        arg_Data == property_Data)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Data)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"data is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetData();
+
+                
+                    if(NULL == arg_Data)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Data = arg_Data;
+                        isValidData = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for data
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::resetData()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Data != NULL)
+                {
+                   
+                   
+                         delete  property_Data;
+                     
+
+                   }
+
+                
+                
+                
+               isValidData = false; 
+               return true;
+           }
+
+           /**
+            * Check whether data is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::isDataNil()
+           {
+               return !isValidData;
+           }
+
+           /**
+            * Set data to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::setDataNil()
+           {
+               return resetData();
+           }
+
+           
+
+            /**
+             * Getter for max_bytes by  Property Number 2
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobData::getProperty2()
+            {
+                return getMax_bytes();
+            }
+
+            /**
+             * getter for max_bytes.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobData::getMax_bytes()
+             {
+                return property_Max_bytes;
+             }
+
+            /**
+             * setter for max_bytes
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::setMax_bytes(
+                    const int  arg_Max_bytes)
+             {
+                
+
+                if(isValidMax_bytes &&
+                        arg_Max_bytes == property_Max_bytes)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetMax_bytes();
+
+                
+                        property_Max_bytes = arg_Max_bytes;
+                        isValidMax_bytes = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for max_bytes
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::resetMax_bytes()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidMax_bytes = false; 
+               return true;
+           }
+
+           /**
+            * Check whether max_bytes is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::isMax_bytesNil()
+           {
+               return !isValidMax_bytes;
+           }
+
+           /**
+            * Set max_bytes to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::setMax_bytesNil()
+           {
+               return resetMax_bytes();
+           }
+
+           
+
+            /**
+             * Getter for from_end by  Property Number 3
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::getProperty3()
+            {
+                return getFrom_end();
+            }
+
+            /**
+             * getter for from_end.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::getFrom_end()
+             {
+                return property_From_end;
+             }
+
+            /**
+             * setter for from_end
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobData::setFrom_end(
+                    bool  arg_From_end)
+             {
+                
+
+                if(isValidFrom_end &&
+                        arg_From_end == property_From_end)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetFrom_end();
+
+                
+                        property_From_end = arg_From_end;
+                        isValidFrom_end = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for from_end
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::resetFrom_end()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidFrom_end = false; 
+               return true;
+           }
+
+           /**
+            * Check whether from_end is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::isFrom_endNil()
+           {
+               return !isValidFrom_end;
+           }
+
+           /**
+            * Set from_end to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobData::setFrom_endNil()
+           {
+               return resetFrom_end();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDataResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDataResponse.cpp
new file mode 100644
index 0000000..10256d7
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDataResponse.cpp
@@ -0,0 +1,1511 @@
+
+
+        /**
+         * GetJobDataResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobDataResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobDataResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobDataResponse::GetJobDataResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Data  = NULL;
+              
+            isValidData  = false;
+        
+                property_Status  = NULL;
+              
+            isValidStatus  = false;
+        
+                    property_File_name;
+                
+            isValidFile_name  = false;
+        
+            isValidFile_size  = false;
+        
+                    property_Content;
+                
+            isValidContent  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobDataResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobDataResponse::GetJobDataResponse(AviaryCommon::JobData* arg_Data,AviaryCommon::Status* arg_Status,std::string arg_File_name,int arg_File_size,std::string arg_Content)
+        {
+             
+                   qname = NULL;
+             
+               property_Data  = NULL;
+             
+            isValidData  = true;
+            
+               property_Status  = NULL;
+             
+            isValidStatus  = true;
+            
+                 property_File_name;
+             
+            isValidFile_name  = true;
+            
+            isValidFile_size  = true;
+            
+                 property_Content;
+             
+            isValidContent  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobDataResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Data = arg_Data;
+            
+                    property_Status = arg_Status;
+            
+                    property_File_name = arg_File_name;
+            
+                    property_File_size = arg_File_size;
+            
+                    property_Content = arg_Content;
+            
+        }
+        AviaryQuery::GetJobDataResponse::~GetJobDataResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobDataResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobDataResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+
+                     
+                     /*
+                      * building data element
+                      */
+                     
+                     
+                     
+                                   current_node = first_node;
+                                   is_early_node_valid = false;
+                                   
+                                   
+                                    while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                    {
+                                        current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                    }
+                                    if(current_node != NULL)
+                                    {
+                                        current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                        mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                    }
+                                   
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "data", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("data", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("data", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::JobData* element = new AviaryCommon::JobData();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element data");
+                                      }
+                                      else
+                                      {
+                                          status = setData(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for data ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element data missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building status element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "status", NULL, NULL);
+                                 
+
+                           if (isParticle() ||  
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("status", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 AviaryCommon::Status* element = new AviaryCommon::Status();
+
+                                      status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                      if(AXIS2_FAILURE == status)
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in building adb object for element status");
+                                      }
+                                      else
+                                      {
+                                          status = setStatus(element);
+                                      }
+                                    
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for status ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                              else if(!dont_care_minoccurs)
+                              {
+                                  if(element_qname)
+                                  {
+                                      axutil_qname_free(element_qname, Environment::getEnv());
+                                  }
+                                  /* this is not a nillable element*/
+				  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "non nillable or minOuccrs != 0 element status missing");
+                                  return AXIS2_FAILURE;
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building file_name element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "file_name", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("file_name", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("file_name", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setFile_name(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element file_name");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setFile_name("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for file_name ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building file_size element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "file_size", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("file_size", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("file_size", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setFile_size(atoi(text_value));
+                                      }
+                                      
+                                      else
+                                      {
+                                          WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element file_size");
+                                          status = AXIS2_FAILURE;
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for file_size ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+
+                     
+                     /*
+                      * building content element
+                      */
+                     
+                     
+                     
+                                    /*
+                                     * because elements are ordered this works fine
+                                     */
+                                  
+                                   
+                                   if(current_node != NULL && is_early_node_valid)
+                                   {
+                                       current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                       
+                                       
+                                        while(current_node && axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                        {
+                                            current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                        }
+                                        if(current_node != NULL)
+                                        {
+                                            current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                            mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+                                        }
+                                       
+                                   }
+                                   is_early_node_valid = false;
+                                 
+                                 element_qname = axutil_qname_create(Environment::getEnv(), "content", NULL, NULL);
+                                 
+
+                           if ( 
+                                (current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("content", axiom_element_get_localname(current_element, Environment::getEnv())))))
+                           {
+                              if( current_node   && current_element && (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("content", axiom_element_get_localname(current_element, Environment::getEnv()))))
+                              {
+                                is_early_node_valid = true;
+                              }
+                              
+                                 
+                                      text_value = axiom_element_get_text(current_element, Environment::getEnv(), current_node);
+                                      if(text_value != NULL)
+                                      {
+                                            status = setContent(text_value);
+                                      }
+                                      
+                                      else
+                                      {
+                                            /*
+                                             * axis2_qname_t *qname = NULL;
+                                             * axiom_attribute_t *the_attri = NULL;
+                                             * 
+                                             * qname = axutil_qname_create(Environment::getEnv(), "nil", "http://www.w3.org/2001/XMLSchema-instance", "xsi");
+                                             * the_attri = axiom_element_get_attribute(current_element, Environment::getEnv(), qname);
+                                             */
+                                            /* currently thereis a bug in the axiom_element_get_attribute, so we have to go to this bad method */
+
+                                            axiom_attribute_t *the_attri = NULL;
+                                            axis2_char_t *attrib_text = NULL;
+                                            axutil_hash_t *attribute_hash = NULL;
+
+                                            attribute_hash = axiom_element_get_all_attributes(current_element, Environment::getEnv());
+
+                                            attrib_text = NULL;
+                                            if(attribute_hash)
+                                            {
+                                                 axutil_hash_index_t *hi;
+                                                 void *val;
+                                                 const void *key;
+                                        
+                                                 for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                                                 {
+                                                     axutil_hash_this(hi, &key, NULL, &val);
+                                                     
+                                                     if(strstr((axis2_char_t*)key, "nil|http://www.w3.org/2001/XMLSchema-instance"))
+                                                     {
+                                                         the_attri = (axiom_attribute_t*)val;
+                                                         break;
+                                                     }
+                                                 }
+                                            }
+
+                                            if(the_attri)
+                                            {
+                                                attrib_text = axiom_attribute_get_value(the_attri, Environment::getEnv());
+                                            }
+                                            else
+                                            {
+                                                /* this is hoping that attribute is stored in "http://www.w3.org/2001/XMLSchema-instance", this happnes when name is in default namespace */
+                                                attrib_text = axiom_element_get_attribute_value_by_name(current_element, Environment::getEnv(), "nil");
+                                            }
+
+                                            if(attrib_text && 0 == axutil_strcmp(attrib_text, "1"))
+                                            {
+                                                WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "NULL value is set to a non nillable element content");
+                                                status = AXIS2_FAILURE;
+                                            }
+                                            else
+                                            {
+                                                /* after all, we found this is a empty string */
+                                                status = setContent("");
+                                            }
+                                      }
+                                      
+                                 if(AXIS2_FAILURE ==  status)
+                                 {
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"failed in setting the value for content ");
+                                     if(element_qname)
+                                     {
+                                         axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     return AXIS2_FAILURE;
+                                 }
+                              }
+                           
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobDataResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobDataResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobDataResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_3;
+                    axis2_char_t *text_value_3_temp;
+                    
+                    axis2_char_t text_value_4[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t *text_value_5;
+                    axis2_char_t *text_value_5_temp;
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobDataResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidData)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property data");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("data"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("data")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing data element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sdata",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sdata>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Data->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Data->serialize(current_node, parent_element,
+                                                                                 property_Data->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Data->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidStatus)
+                   {
+                      
+                            
+                            WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"Nil value found in non-nillable property status");
+                            return NULL;
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("status"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("status")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing status element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sstatus",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":""); 
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sstatus>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                     
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            property_Status->serialize(current_node, parent_element,
+                                                                                 property_Status->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!property_Status->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidFile_name)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("file_name"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("file_name")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing file_name element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sfile_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sfile_name>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_3 = (axis2_char_t*)property_File_name.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_3_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_3, true);
+                           if (text_value_3_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3_temp, axutil_strlen(text_value_3_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_3_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_3, axutil_strlen(text_value_3));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidFile_size)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("file_size"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("file_size")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing file_size element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%sfile_size>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%sfile_size>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                               sprintf (text_value_4, AXIS2_PRINTF_INT32_FORMAT_SPECIFIER, property_File_size);
+                             
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), text_value_4, axutil_strlen(text_value_4));
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidContent)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("content"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("content")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     
+                     /*
+                      * parsing content element
+                      */
+
+                    
+                    
+                            sprintf(start_input_str, "<%s%scontent>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                        start_input_str_len = axutil_strlen(start_input_str);
+                        sprintf(end_input_str, "</%s%scontent>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                        end_input_str_len = axutil_strlen(end_input_str);
+                    
+                           text_value_5 = (axis2_char_t*)property_Content.c_str();
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                           
+                            
+                           text_value_5_temp = axutil_xml_quote_string(Environment::getEnv(), text_value_5, true);
+                           if (text_value_5_temp)
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_5_temp, axutil_strlen(text_value_5_temp));
+                               AXIS2_FREE(Environment::getEnv()->allocator, text_value_5_temp);
+                           }
+                           else
+                           {
+                               axutil_stream_write(stream, Environment::getEnv(), text_value_5, axutil_strlen(text_value_5));
+                           }
+                           
+                           axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                           
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for data by  Property Number 1
+             */
+            AviaryCommon::JobData* WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty1()
+            {
+                return getData();
+            }
+
+            /**
+             * getter for data.
+             */
+            AviaryCommon::JobData* WSF_CALL
+            AviaryQuery::GetJobDataResponse::getData()
+             {
+                return property_Data;
+             }
+
+            /**
+             * setter for data
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setData(
+                    AviaryCommon::JobData*  arg_Data)
+             {
+                
+
+                if(isValidData &&
+                        arg_Data == property_Data)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Data)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"data is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetData();
+
+                
+                    if(NULL == arg_Data)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Data = arg_Data;
+                        isValidData = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for data
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetData()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Data != NULL)
+                {
+                   
+                   
+                         delete  property_Data;
+                     
+
+                   }
+
+                
+                
+                
+               isValidData = false; 
+               return true;
+           }
+
+           /**
+            * Check whether data is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isDataNil()
+           {
+               return !isValidData;
+           }
+
+           /**
+            * Set data to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setDataNil()
+           {
+               return resetData();
+           }
+
+           
+
+            /**
+             * Getter for status by  Property Number 2
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty2()
+            {
+                return getStatus();
+            }
+
+            /**
+             * getter for status.
+             */
+            AviaryCommon::Status* WSF_CALL
+            AviaryQuery::GetJobDataResponse::getStatus()
+             {
+                return property_Status;
+             }
+
+            /**
+             * setter for status
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setStatus(
+                    AviaryCommon::Status*  arg_Status)
+             {
+                
+
+                if(isValidStatus &&
+                        arg_Status == property_Status)
+                {
+                    
+                    return true;
+                }
+
+                
+                  if(NULL == arg_Status)
+                       
+                  {
+                      WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"status is being set to NULL, but it is not a nullable element");
+                      return AXIS2_FAILURE;
+                  }
+                
+
+                
+                resetStatus();
+
+                
+                    if(NULL == arg_Status)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Status = arg_Status;
+                        isValidStatus = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for status
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetStatus()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+            
+                
+
+                if(property_Status != NULL)
+                {
+                   
+                   
+                         delete  property_Status;
+                     
+
+                   }
+
+                
+                
+                
+               isValidStatus = false; 
+               return true;
+           }
+
+           /**
+            * Check whether status is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isStatusNil()
+           {
+               return !isValidStatus;
+           }
+
+           /**
+            * Set status to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setStatusNil()
+           {
+               return resetStatus();
+           }
+
+           
+
+            /**
+             * Getter for file_name by  Property Number 3
+             */
+            std::string WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty3()
+            {
+                return getFile_name();
+            }
+
+            /**
+             * getter for file_name.
+             */
+            std::string WSF_CALL
+            AviaryQuery::GetJobDataResponse::getFile_name()
+             {
+                return property_File_name;
+             }
+
+            /**
+             * setter for file_name
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setFile_name(
+                    const std::string  arg_File_name)
+             {
+                
+
+                if(isValidFile_name &&
+                        arg_File_name == property_File_name)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetFile_name();
+
+                
+                        property_File_name = std::string(arg_File_name.c_str());
+                        isValidFile_name = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for file_name
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetFile_name()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidFile_name = false; 
+               return true;
+           }
+
+           /**
+            * Check whether file_name is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isFile_nameNil()
+           {
+               return !isValidFile_name;
+           }
+
+           /**
+            * Set file_name to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setFile_nameNil()
+           {
+               return resetFile_name();
+           }
+
+           
+
+            /**
+             * Getter for file_size by  Property Number 4
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty4()
+            {
+                return getFile_size();
+            }
+
+            /**
+             * getter for file_size.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobDataResponse::getFile_size()
+             {
+                return property_File_size;
+             }
+
+            /**
+             * setter for file_size
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setFile_size(
+                    const int  arg_File_size)
+             {
+                
+
+                if(isValidFile_size &&
+                        arg_File_size == property_File_size)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetFile_size();
+
+                
+                        property_File_size = arg_File_size;
+                        isValidFile_size = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for file_size
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetFile_size()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidFile_size = false; 
+               return true;
+           }
+
+           /**
+            * Check whether file_size is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isFile_sizeNil()
+           {
+               return !isValidFile_size;
+           }
+
+           /**
+            * Set file_size to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setFile_sizeNil()
+           {
+               return resetFile_size();
+           }
+
+           
+
+            /**
+             * Getter for content by  Property Number 5
+             */
+            std::string WSF_CALL
+            AviaryQuery::GetJobDataResponse::getProperty5()
+            {
+                return getContent();
+            }
+
+            /**
+             * getter for content.
+             */
+            std::string WSF_CALL
+            AviaryQuery::GetJobDataResponse::getContent()
+             {
+                return property_Content;
+             }
+
+            /**
+             * setter for content
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDataResponse::setContent(
+                    const std::string  arg_Content)
+             {
+                
+
+                if(isValidContent &&
+                        arg_Content == property_Content)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetContent();
+
+                
+                        property_Content = std::string(arg_Content.c_str());
+                        isValidContent = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for content
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::resetContent()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidContent = false; 
+               return true;
+           }
+
+           /**
+            * Check whether content is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::isContentNil()
+           {
+               return !isValidContent;
+           }
+
+           /**
+            * Set content to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDataResponse::setContentNil()
+           {
+               return resetContent();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetails.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetails.cpp
new file mode 100644
index 0000000..e09bf50
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetails.cpp
@@ -0,0 +1,980 @@
+
+
+        /**
+         * GetJobDetails.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobDetails.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobDetails|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobDetails::GetJobDetails()
+        {
+
+        
+            qname = NULL;
+        
+                property_Ids  = NULL;
+              
+            isValidIds  = false;
+        
+            isValidPartialMatches  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobDetails",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobDetails::GetJobDetails(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches)
+        {
+             
+                   qname = NULL;
+             
+               property_Ids  = NULL;
+             
+            isValidIds  = true;
+            
+            isValidPartialMatches  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobDetails",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Ids = arg_Ids;
+            
+                    property_PartialMatches = arg_PartialMatches;
+            
+        }
+        AviaryQuery::GetJobDetails::~GetJobDetails()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobDetails::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobDetails : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                       { 
+                    /*
+                     * building Ids array
+                     */
+                       std::vector<AviaryCommon::JobID*>* arr_list =new std::vector<AviaryCommon::JobID*>();
+                   
+
+                     
+                     /*
+                      * building ids element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "ids", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("ids", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobID* element = new AviaryCommon::JobID();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element ids ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for ids ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setIds(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "partialMatches"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "partialMatches", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "partialMatches");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setPartialMatches(true);
+                           }
+                           else
+                           {
+                               setPartialMatches(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobDetails::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobDetails::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobDetails::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobDetails", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidPartialMatches)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_PartialMatches)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("partialMatches")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "partialMatches",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIds)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ids"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ids")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Ids array
+                      */
+                     if (property_Ids != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sids",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sids>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Ids->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobID* element = (*property_Ids)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing ids element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidPartialMatches)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_PartialMatches)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "partialMatches", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ids by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobDetails::getProperty1()
+            {
+                return getIds();
+            }
+
+            /**
+             * getter for ids.
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobDetails::getIds()
+             {
+                return property_Ids;
+             }
+
+            /**
+             * setter for ids
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::setIds(
+                    std::vector<AviaryCommon::JobID*>*  arg_Ids)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidIds &&
+                        arg_Ids == property_Ids)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Ids->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Ids)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetIds();
+
+                
+                    if(NULL == arg_Ids)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Ids = arg_Ids;
+                        if(non_nil_exists)
+                        {
+                            isValidIds = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of ids.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryQuery::GetJobDetails::getIdsAt(int i)
+            {
+                AviaryCommon::JobID* ret_val;
+                if(property_Ids == NULL)
+                {
+                    return (AviaryCommon::JobID*)0;
+                }
+                ret_val =   (*property_Ids)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of ids.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobDetails::setIdsAt(int i,
+                    AviaryCommon::JobID* arg_Ids)
+            {
+                 AviaryCommon::JobID* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidIds &&
+                    property_Ids &&
+                  
+                    arg_Ids == (*property_Ids)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Ids)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = true;
+                        (*property_Ids)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Ids)[i] = arg_Ids;
+                  
+
+               isValidIds = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to ids.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::addIds(
+                    AviaryCommon::JobID* arg_Ids)
+             {
+
+                
+                    if( NULL == arg_Ids
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+              
+               property_Ids->push_back(arg_Ids);
+              
+                isValidIds = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the ids array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobDetails::sizeofIds()
+            {
+
+                if(property_Ids == NULL)
+                {
+                    return 0;
+                }
+                return property_Ids->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::removeIdsAt(int i)
+            {
+                return setIdsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for ids
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::resetIds()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Ids != NULL)
+                {
+                  std::vector<AviaryCommon::JobID*>::iterator it =  property_Ids->begin();
+                  for( ; it <  property_Ids->end() ; ++it)
+                  {
+                     AviaryCommon::JobID* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Ids)
+                 delete property_Ids;
+                
+               isValidIds = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ids is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::isIdsNil()
+           {
+               return !isValidIds;
+           }
+
+           /**
+            * Set ids to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::setIdsNil()
+           {
+               return resetIds();
+           }
+
+           
+           /**
+            * Check whether ids is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::isIdsNilAt(int i)
+           {
+               return (isValidIds == false ||
+                       NULL == property_Ids ||
+                     NULL == (*property_Ids)[i]);
+            }
+
+           /**
+            * Set ids to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::setIdsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Ids == NULL ||
+                            isValidIds == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Ids->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Ids)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of ids is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Ids == NULL)
+                {
+                    isValidIds = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobID* element = (*property_Ids)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = false;
+                        (*property_Ids)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Ids)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for partialMatches by  Property Number 2
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::getProperty2()
+            {
+                return getPartialMatches();
+            }
+
+            /**
+             * getter for partialMatches.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::getPartialMatches()
+             {
+                return property_PartialMatches;
+             }
+
+            /**
+             * setter for partialMatches
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetails::setPartialMatches(
+                    bool  arg_PartialMatches)
+             {
+                
+
+                if(isValidPartialMatches &&
+                        arg_PartialMatches == property_PartialMatches)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPartialMatches();
+
+                
+                        property_PartialMatches = arg_PartialMatches;
+                        isValidPartialMatches = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for partialMatches
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::resetPartialMatches()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPartialMatches = false; 
+               return true;
+           }
+
+           /**
+            * Check whether partialMatches is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::isPartialMatchesNil()
+           {
+               return !isValidPartialMatches;
+           }
+
+           /**
+            * Set partialMatches to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetails::setPartialMatchesNil()
+           {
+               return resetPartialMatches();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetailsResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetailsResponse.cpp
new file mode 100644
index 0000000..05025b8
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobDetailsResponse.cpp
@@ -0,0 +1,776 @@
+
+
+        /**
+         * GetJobDetailsResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobDetailsResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobDetailsResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobDetailsResponse::GetJobDetailsResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Jobs  = NULL;
+              
+            isValidJobs  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobDetailsResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobDetailsResponse::GetJobDetailsResponse(std::vector<AviaryCommon::JobDetails*>* arg_Jobs)
+        {
+             
+                   qname = NULL;
+             
+               property_Jobs  = NULL;
+             
+            isValidJobs  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobDetailsResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Jobs = arg_Jobs;
+            
+        }
+        AviaryQuery::GetJobDetailsResponse::~GetJobDetailsResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobDetailsResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobDetailsResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                       { 
+                    /*
+                     * building Jobs array
+                     */
+                       std::vector<AviaryCommon::JobDetails*>* arr_list =new std::vector<AviaryCommon::JobDetails*>();
+                   
+
+                     
+                     /*
+                      * building jobs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "jobs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("jobs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobDetails* element = new AviaryCommon::JobDetails();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element jobs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for jobs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setJobs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobDetailsResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobDetailsResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobDetailsResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobDetailsResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJobs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("jobs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("jobs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Jobs array
+                      */
+                     if (property_Jobs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sjobs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sjobs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Jobs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobDetails* element = (*property_Jobs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing jobs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for jobs by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobDetails*>* WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::getProperty1()
+            {
+                return getJobs();
+            }
+
+            /**
+             * getter for jobs.
+             */
+            std::vector<AviaryCommon::JobDetails*>* WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::getJobs()
+             {
+                return property_Jobs;
+             }
+
+            /**
+             * setter for jobs
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::setJobs(
+                    std::vector<AviaryCommon::JobDetails*>*  arg_Jobs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidJobs &&
+                        arg_Jobs == property_Jobs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Jobs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Jobs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetJobs();
+
+                
+                    if(NULL == arg_Jobs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Jobs = arg_Jobs;
+                        if(non_nil_exists)
+                        {
+                            isValidJobs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of jobs.
+             */
+            AviaryCommon::JobDetails* WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::getJobsAt(int i)
+            {
+                AviaryCommon::JobDetails* ret_val;
+                if(property_Jobs == NULL)
+                {
+                    return (AviaryCommon::JobDetails*)0;
+                }
+                ret_val =   (*property_Jobs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of jobs.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::setJobsAt(int i,
+                    AviaryCommon::JobDetails* arg_Jobs)
+            {
+                 AviaryCommon::JobDetails* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidJobs &&
+                    property_Jobs &&
+                  
+                    arg_Jobs == (*property_Jobs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobDetails*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Jobs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = true;
+                        (*property_Jobs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Jobs)[i] = arg_Jobs;
+                  
+
+               isValidJobs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to jobs.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::addJobs(
+                    AviaryCommon::JobDetails* arg_Jobs)
+             {
+
+                
+                    if( NULL == arg_Jobs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobDetails*>();
+                }
+              
+               property_Jobs->push_back(arg_Jobs);
+              
+                isValidJobs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the jobs array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::sizeofJobs()
+            {
+
+                if(property_Jobs == NULL)
+                {
+                    return 0;
+                }
+                return property_Jobs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobDetailsResponse::removeJobsAt(int i)
+            {
+                return setJobsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for jobs
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::resetJobs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Jobs != NULL)
+                {
+                  std::vector<AviaryCommon::JobDetails*>::iterator it =  property_Jobs->begin();
+                  for( ; it <  property_Jobs->end() ; ++it)
+                  {
+                     AviaryCommon::JobDetails* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Jobs)
+                 delete property_Jobs;
+                
+               isValidJobs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether jobs is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::isJobsNil()
+           {
+               return !isValidJobs;
+           }
+
+           /**
+            * Set jobs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::setJobsNil()
+           {
+               return resetJobs();
+           }
+
+           
+           /**
+            * Check whether jobs is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::isJobsNilAt(int i)
+           {
+               return (isValidJobs == false ||
+                       NULL == property_Jobs ||
+                     NULL == (*property_Jobs)[i]);
+            }
+
+           /**
+            * Set jobs to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobDetailsResponse::setJobsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Jobs == NULL ||
+                            isValidJobs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Jobs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Jobs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of jobs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Jobs == NULL)
+                {
+                    isValidJobs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobDetails* element = (*property_Jobs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = false;
+                        (*property_Jobs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Jobs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatus.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatus.cpp
new file mode 100644
index 0000000..215973c
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatus.cpp
@@ -0,0 +1,980 @@
+
+
+        /**
+         * GetJobStatus.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobStatus.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobStatus|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobStatus::GetJobStatus()
+        {
+
+        
+            qname = NULL;
+        
+                property_Ids  = NULL;
+              
+            isValidIds  = false;
+        
+            isValidPartialMatches  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobStatus",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobStatus::GetJobStatus(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches)
+        {
+             
+                   qname = NULL;
+             
+               property_Ids  = NULL;
+             
+            isValidIds  = true;
+            
+            isValidPartialMatches  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobStatus",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Ids = arg_Ids;
+            
+                    property_PartialMatches = arg_PartialMatches;
+            
+        }
+        AviaryQuery::GetJobStatus::~GetJobStatus()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobStatus::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobStatus : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                       { 
+                    /*
+                     * building Ids array
+                     */
+                       std::vector<AviaryCommon::JobID*>* arr_list =new std::vector<AviaryCommon::JobID*>();
+                   
+
+                     
+                     /*
+                      * building ids element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "ids", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("ids", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobID* element = new AviaryCommon::JobID();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element ids ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for ids ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setIds(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "partialMatches"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "partialMatches", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "partialMatches");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setPartialMatches(true);
+                           }
+                           else
+                           {
+                               setPartialMatches(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobStatus::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobStatus::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobStatus::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobStatus", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidPartialMatches)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_PartialMatches)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("partialMatches")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "partialMatches",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIds)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ids"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ids")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Ids array
+                      */
+                     if (property_Ids != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sids",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sids>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Ids->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobID* element = (*property_Ids)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing ids element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidPartialMatches)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_PartialMatches)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "partialMatches", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ids by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobStatus::getProperty1()
+            {
+                return getIds();
+            }
+
+            /**
+             * getter for ids.
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobStatus::getIds()
+             {
+                return property_Ids;
+             }
+
+            /**
+             * setter for ids
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::setIds(
+                    std::vector<AviaryCommon::JobID*>*  arg_Ids)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidIds &&
+                        arg_Ids == property_Ids)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Ids->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Ids)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetIds();
+
+                
+                    if(NULL == arg_Ids)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Ids = arg_Ids;
+                        if(non_nil_exists)
+                        {
+                            isValidIds = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of ids.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryQuery::GetJobStatus::getIdsAt(int i)
+            {
+                AviaryCommon::JobID* ret_val;
+                if(property_Ids == NULL)
+                {
+                    return (AviaryCommon::JobID*)0;
+                }
+                ret_val =   (*property_Ids)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of ids.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobStatus::setIdsAt(int i,
+                    AviaryCommon::JobID* arg_Ids)
+            {
+                 AviaryCommon::JobID* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidIds &&
+                    property_Ids &&
+                  
+                    arg_Ids == (*property_Ids)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Ids)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = true;
+                        (*property_Ids)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Ids)[i] = arg_Ids;
+                  
+
+               isValidIds = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to ids.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::addIds(
+                    AviaryCommon::JobID* arg_Ids)
+             {
+
+                
+                    if( NULL == arg_Ids
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+              
+               property_Ids->push_back(arg_Ids);
+              
+                isValidIds = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the ids array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobStatus::sizeofIds()
+            {
+
+                if(property_Ids == NULL)
+                {
+                    return 0;
+                }
+                return property_Ids->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::removeIdsAt(int i)
+            {
+                return setIdsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for ids
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::resetIds()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Ids != NULL)
+                {
+                  std::vector<AviaryCommon::JobID*>::iterator it =  property_Ids->begin();
+                  for( ; it <  property_Ids->end() ; ++it)
+                  {
+                     AviaryCommon::JobID* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Ids)
+                 delete property_Ids;
+                
+               isValidIds = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ids is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::isIdsNil()
+           {
+               return !isValidIds;
+           }
+
+           /**
+            * Set ids to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::setIdsNil()
+           {
+               return resetIds();
+           }
+
+           
+           /**
+            * Check whether ids is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::isIdsNilAt(int i)
+           {
+               return (isValidIds == false ||
+                       NULL == property_Ids ||
+                     NULL == (*property_Ids)[i]);
+            }
+
+           /**
+            * Set ids to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::setIdsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Ids == NULL ||
+                            isValidIds == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Ids->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Ids)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of ids is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Ids == NULL)
+                {
+                    isValidIds = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobID* element = (*property_Ids)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = false;
+                        (*property_Ids)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Ids)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for partialMatches by  Property Number 2
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::getProperty2()
+            {
+                return getPartialMatches();
+            }
+
+            /**
+             * getter for partialMatches.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::getPartialMatches()
+             {
+                return property_PartialMatches;
+             }
+
+            /**
+             * setter for partialMatches
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatus::setPartialMatches(
+                    bool  arg_PartialMatches)
+             {
+                
+
+                if(isValidPartialMatches &&
+                        arg_PartialMatches == property_PartialMatches)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPartialMatches();
+
+                
+                        property_PartialMatches = arg_PartialMatches;
+                        isValidPartialMatches = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for partialMatches
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::resetPartialMatches()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPartialMatches = false; 
+               return true;
+           }
+
+           /**
+            * Check whether partialMatches is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::isPartialMatchesNil()
+           {
+               return !isValidPartialMatches;
+           }
+
+           /**
+            * Set partialMatches to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatus::setPartialMatchesNil()
+           {
+               return resetPartialMatches();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatusResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatusResponse.cpp
new file mode 100644
index 0000000..656f042
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobStatusResponse.cpp
@@ -0,0 +1,776 @@
+
+
+        /**
+         * GetJobStatusResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobStatusResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobStatusResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobStatusResponse::GetJobStatusResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Jobs  = NULL;
+              
+            isValidJobs  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobStatusResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobStatusResponse::GetJobStatusResponse(std::vector<AviaryCommon::JobStatus*>* arg_Jobs)
+        {
+             
+                   qname = NULL;
+             
+               property_Jobs  = NULL;
+             
+            isValidJobs  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobStatusResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Jobs = arg_Jobs;
+            
+        }
+        AviaryQuery::GetJobStatusResponse::~GetJobStatusResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobStatusResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobStatusResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                       { 
+                    /*
+                     * building Jobs array
+                     */
+                       std::vector<AviaryCommon::JobStatus*>* arr_list =new std::vector<AviaryCommon::JobStatus*>();
+                   
+
+                     
+                     /*
+                      * building jobs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "jobs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("jobs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobStatus* element = new AviaryCommon::JobStatus();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element jobs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for jobs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setJobs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobStatusResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobStatusResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobStatusResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobStatusResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJobs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("jobs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("jobs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Jobs array
+                      */
+                     if (property_Jobs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sjobs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sjobs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Jobs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobStatus* element = (*property_Jobs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing jobs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for jobs by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobStatus*>* WSF_CALL
+            AviaryQuery::GetJobStatusResponse::getProperty1()
+            {
+                return getJobs();
+            }
+
+            /**
+             * getter for jobs.
+             */
+            std::vector<AviaryCommon::JobStatus*>* WSF_CALL
+            AviaryQuery::GetJobStatusResponse::getJobs()
+             {
+                return property_Jobs;
+             }
+
+            /**
+             * setter for jobs
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatusResponse::setJobs(
+                    std::vector<AviaryCommon::JobStatus*>*  arg_Jobs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidJobs &&
+                        arg_Jobs == property_Jobs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Jobs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Jobs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetJobs();
+
+                
+                    if(NULL == arg_Jobs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Jobs = arg_Jobs;
+                        if(non_nil_exists)
+                        {
+                            isValidJobs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of jobs.
+             */
+            AviaryCommon::JobStatus* WSF_CALL
+            AviaryQuery::GetJobStatusResponse::getJobsAt(int i)
+            {
+                AviaryCommon::JobStatus* ret_val;
+                if(property_Jobs == NULL)
+                {
+                    return (AviaryCommon::JobStatus*)0;
+                }
+                ret_val =   (*property_Jobs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of jobs.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobStatusResponse::setJobsAt(int i,
+                    AviaryCommon::JobStatus* arg_Jobs)
+            {
+                 AviaryCommon::JobStatus* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidJobs &&
+                    property_Jobs &&
+                  
+                    arg_Jobs == (*property_Jobs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobStatus*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Jobs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = true;
+                        (*property_Jobs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Jobs)[i] = arg_Jobs;
+                  
+
+               isValidJobs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to jobs.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatusResponse::addJobs(
+                    AviaryCommon::JobStatus* arg_Jobs)
+             {
+
+                
+                    if( NULL == arg_Jobs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobStatus*>();
+                }
+              
+               property_Jobs->push_back(arg_Jobs);
+              
+                isValidJobs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the jobs array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobStatusResponse::sizeofJobs()
+            {
+
+                if(property_Jobs == NULL)
+                {
+                    return 0;
+                }
+                return property_Jobs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobStatusResponse::removeJobsAt(int i)
+            {
+                return setJobsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for jobs
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::resetJobs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Jobs != NULL)
+                {
+                  std::vector<AviaryCommon::JobStatus*>::iterator it =  property_Jobs->begin();
+                  for( ; it <  property_Jobs->end() ; ++it)
+                  {
+                     AviaryCommon::JobStatus* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Jobs)
+                 delete property_Jobs;
+                
+               isValidJobs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether jobs is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::isJobsNil()
+           {
+               return !isValidJobs;
+           }
+
+           /**
+            * Set jobs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::setJobsNil()
+           {
+               return resetJobs();
+           }
+
+           
+           /**
+            * Check whether jobs is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::isJobsNilAt(int i)
+           {
+               return (isValidJobs == false ||
+                       NULL == property_Jobs ||
+                     NULL == (*property_Jobs)[i]);
+            }
+
+           /**
+            * Set jobs to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobStatusResponse::setJobsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Jobs == NULL ||
+                            isValidJobs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Jobs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Jobs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of jobs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Jobs == NULL)
+                {
+                    isValidJobs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobStatus* element = (*property_Jobs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = false;
+                        (*property_Jobs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Jobs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummary.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummary.cpp
new file mode 100644
index 0000000..bfbaa18
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummary.cpp
@@ -0,0 +1,980 @@
+
+
+        /**
+         * GetJobSummary.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobSummary.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobSummary|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobSummary::GetJobSummary()
+        {
+
+        
+            qname = NULL;
+        
+                property_Ids  = NULL;
+              
+            isValidIds  = false;
+        
+            isValidPartialMatches  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobSummary",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobSummary::GetJobSummary(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches)
+        {
+             
+                   qname = NULL;
+             
+               property_Ids  = NULL;
+             
+            isValidIds  = true;
+            
+            isValidPartialMatches  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobSummary",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Ids = arg_Ids;
+            
+                    property_PartialMatches = arg_PartialMatches;
+            
+        }
+        AviaryQuery::GetJobSummary::~GetJobSummary()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobSummary::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobSummary : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                       { 
+                    /*
+                     * building Ids array
+                     */
+                       std::vector<AviaryCommon::JobID*>* arr_list =new std::vector<AviaryCommon::JobID*>();
+                   
+
+                     
+                     /*
+                      * building ids element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "ids", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("ids", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobID* element = new AviaryCommon::JobID();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element ids ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for ids ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setIds(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "partialMatches"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "partialMatches", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "partialMatches");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setPartialMatches(true);
+                           }
+                           else
+                           {
+                               setPartialMatches(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobSummary::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobSummary::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobSummary::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobSummary", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidPartialMatches)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_PartialMatches)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("partialMatches")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "partialMatches",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIds)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ids"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ids")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Ids array
+                      */
+                     if (property_Ids != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sids",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sids>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Ids->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobID* element = (*property_Ids)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing ids element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidPartialMatches)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_PartialMatches)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "partialMatches", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ids by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobSummary::getProperty1()
+            {
+                return getIds();
+            }
+
+            /**
+             * getter for ids.
+             */
+            std::vector<AviaryCommon::JobID*>* WSF_CALL
+            AviaryQuery::GetJobSummary::getIds()
+             {
+                return property_Ids;
+             }
+
+            /**
+             * setter for ids
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::setIds(
+                    std::vector<AviaryCommon::JobID*>*  arg_Ids)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidIds &&
+                        arg_Ids == property_Ids)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Ids->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Ids)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetIds();
+
+                
+                    if(NULL == arg_Ids)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Ids = arg_Ids;
+                        if(non_nil_exists)
+                        {
+                            isValidIds = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of ids.
+             */
+            AviaryCommon::JobID* WSF_CALL
+            AviaryQuery::GetJobSummary::getIdsAt(int i)
+            {
+                AviaryCommon::JobID* ret_val;
+                if(property_Ids == NULL)
+                {
+                    return (AviaryCommon::JobID*)0;
+                }
+                ret_val =   (*property_Ids)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of ids.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobSummary::setIdsAt(int i,
+                    AviaryCommon::JobID* arg_Ids)
+            {
+                 AviaryCommon::JobID* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidIds &&
+                    property_Ids &&
+                  
+                    arg_Ids == (*property_Ids)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Ids)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = true;
+                        (*property_Ids)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Ids)[i] = arg_Ids;
+                  
+
+               isValidIds = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to ids.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::addIds(
+                    AviaryCommon::JobID* arg_Ids)
+             {
+
+                
+                    if( NULL == arg_Ids
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::JobID*>();
+                }
+              
+               property_Ids->push_back(arg_Ids);
+              
+                isValidIds = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the ids array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobSummary::sizeofIds()
+            {
+
+                if(property_Ids == NULL)
+                {
+                    return 0;
+                }
+                return property_Ids->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::removeIdsAt(int i)
+            {
+                return setIdsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for ids
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::resetIds()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Ids != NULL)
+                {
+                  std::vector<AviaryCommon::JobID*>::iterator it =  property_Ids->begin();
+                  for( ; it <  property_Ids->end() ; ++it)
+                  {
+                     AviaryCommon::JobID* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Ids)
+                 delete property_Ids;
+                
+               isValidIds = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ids is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::isIdsNil()
+           {
+               return !isValidIds;
+           }
+
+           /**
+            * Set ids to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::setIdsNil()
+           {
+               return resetIds();
+           }
+
+           
+           /**
+            * Check whether ids is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::isIdsNilAt(int i)
+           {
+               return (isValidIds == false ||
+                       NULL == property_Ids ||
+                     NULL == (*property_Ids)[i]);
+            }
+
+           /**
+            * Set ids to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::setIdsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Ids == NULL ||
+                            isValidIds == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Ids->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Ids)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of ids is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Ids == NULL)
+                {
+                    isValidIds = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobID* element = (*property_Ids)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = false;
+                        (*property_Ids)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Ids)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for partialMatches by  Property Number 2
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::getProperty2()
+            {
+                return getPartialMatches();
+            }
+
+            /**
+             * getter for partialMatches.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::getPartialMatches()
+             {
+                return property_PartialMatches;
+             }
+
+            /**
+             * setter for partialMatches
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummary::setPartialMatches(
+                    bool  arg_PartialMatches)
+             {
+                
+
+                if(isValidPartialMatches &&
+                        arg_PartialMatches == property_PartialMatches)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPartialMatches();
+
+                
+                        property_PartialMatches = arg_PartialMatches;
+                        isValidPartialMatches = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for partialMatches
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::resetPartialMatches()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPartialMatches = false; 
+               return true;
+           }
+
+           /**
+            * Check whether partialMatches is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::isPartialMatchesNil()
+           {
+               return !isValidPartialMatches;
+           }
+
+           /**
+            * Set partialMatches to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummary::setPartialMatchesNil()
+           {
+               return resetPartialMatches();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummaryResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummaryResponse.cpp
new file mode 100644
index 0000000..a3bdc0c
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetJobSummaryResponse.cpp
@@ -0,0 +1,776 @@
+
+
+        /**
+         * GetJobSummaryResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetJobSummaryResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetJobSummaryResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetJobSummaryResponse::GetJobSummaryResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Jobs  = NULL;
+              
+            isValidJobs  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetJobSummaryResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetJobSummaryResponse::GetJobSummaryResponse(std::vector<AviaryCommon::JobSummary*>* arg_Jobs)
+        {
+             
+                   qname = NULL;
+             
+               property_Jobs  = NULL;
+             
+            isValidJobs  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetJobSummaryResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Jobs = arg_Jobs;
+            
+        }
+        AviaryQuery::GetJobSummaryResponse::~GetJobSummaryResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetJobSummaryResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetJobSummaryResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                       { 
+                    /*
+                     * building Jobs array
+                     */
+                       std::vector<AviaryCommon::JobSummary*>* arr_list =new std::vector<AviaryCommon::JobSummary*>();
+                   
+
+                     
+                     /*
+                      * building jobs element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "jobs", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("jobs", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::JobSummary* element = new AviaryCommon::JobSummary();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element jobs ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for jobs ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setJobs(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetJobSummaryResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetJobSummaryResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetJobSummaryResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetJobSummaryResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidJobs)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("jobs"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("jobs")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Jobs array
+                      */
+                     if (property_Jobs != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sjobs",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sjobs>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Jobs->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::JobSummary* element = (*property_Jobs)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing jobs element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for jobs by  Property Number 1
+             */
+            std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::getProperty1()
+            {
+                return getJobs();
+            }
+
+            /**
+             * getter for jobs.
+             */
+            std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::getJobs()
+             {
+                return property_Jobs;
+             }
+
+            /**
+             * setter for jobs
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::setJobs(
+                    std::vector<AviaryCommon::JobSummary*>*  arg_Jobs)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidJobs &&
+                        arg_Jobs == property_Jobs)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Jobs->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"jobs has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Jobs)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetJobs();
+
+                
+                    if(NULL == arg_Jobs)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Jobs = arg_Jobs;
+                        if(non_nil_exists)
+                        {
+                            isValidJobs = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of jobs.
+             */
+            AviaryCommon::JobSummary* WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::getJobsAt(int i)
+            {
+                AviaryCommon::JobSummary* ret_val;
+                if(property_Jobs == NULL)
+                {
+                    return (AviaryCommon::JobSummary*)0;
+                }
+                ret_val =   (*property_Jobs)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of jobs.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::setJobsAt(int i,
+                    AviaryCommon::JobSummary* arg_Jobs)
+            {
+                 AviaryCommon::JobSummary* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidJobs &&
+                    property_Jobs &&
+                  
+                    arg_Jobs == (*property_Jobs)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobSummary*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Jobs)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = true;
+                        (*property_Jobs)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Jobs)[i] = arg_Jobs;
+                  
+
+               isValidJobs = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to jobs.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::addJobs(
+                    AviaryCommon::JobSummary* arg_Jobs)
+             {
+
+                
+                    if( NULL == arg_Jobs
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Jobs == NULL)
+                {
+                    property_Jobs = new std::vector<AviaryCommon::JobSummary*>();
+                }
+              
+               property_Jobs->push_back(arg_Jobs);
+              
+                isValidJobs = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the jobs array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::sizeofJobs()
+            {
+
+                if(property_Jobs == NULL)
+                {
+                    return 0;
+                }
+                return property_Jobs->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetJobSummaryResponse::removeJobsAt(int i)
+            {
+                return setJobsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for jobs
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::resetJobs()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Jobs != NULL)
+                {
+                  std::vector<AviaryCommon::JobSummary*>::iterator it =  property_Jobs->begin();
+                  for( ; it <  property_Jobs->end() ; ++it)
+                  {
+                     AviaryCommon::JobSummary* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Jobs)
+                 delete property_Jobs;
+                
+               isValidJobs = false; 
+               return true;
+           }
+
+           /**
+            * Check whether jobs is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::isJobsNil()
+           {
+               return !isValidJobs;
+           }
+
+           /**
+            * Set jobs to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::setJobsNil()
+           {
+               return resetJobs();
+           }
+
+           
+           /**
+            * Check whether jobs is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::isJobsNilAt(int i)
+           {
+               return (isValidJobs == false ||
+                       NULL == property_Jobs ||
+                     NULL == (*property_Jobs)[i]);
+            }
+
+           /**
+            * Set jobs to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetJobSummaryResponse::setJobsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Jobs == NULL ||
+                            isValidJobs == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Jobs->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Jobs)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of jobs is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Jobs == NULL)
+                {
+                    isValidJobs = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::JobSummary* element = (*property_Jobs)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidJobs = false;
+                        (*property_Jobs)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Jobs)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummary.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummary.cpp
new file mode 100644
index 0000000..1f56355
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummary.cpp
@@ -0,0 +1,1163 @@
+
+
+        /**
+         * GetSubmissionSummary.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetSubmissionSummary.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetSubmissionSummary|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetSubmissionSummary::GetSubmissionSummary()
+        {
+
+        
+            qname = NULL;
+        
+                property_Ids  = NULL;
+              
+            isValidIds  = false;
+        
+            isValidPartialMatches  = false;
+        
+            isValidIncludeJobSummaries  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetSubmissionSummary",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetSubmissionSummary::GetSubmissionSummary(std::vector<AviaryCommon::SubmissionID*>* arg_Ids,bool arg_PartialMatches,bool arg_IncludeJobSummaries)
+        {
+             
+                   qname = NULL;
+             
+               property_Ids  = NULL;
+             
+            isValidIds  = true;
+            
+            isValidPartialMatches  = true;
+            
+            isValidIncludeJobSummaries  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetSubmissionSummary",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Ids = arg_Ids;
+            
+                    property_PartialMatches = arg_PartialMatches;
+            
+                    property_IncludeJobSummaries = arg_IncludeJobSummaries;
+            
+        }
+        AviaryQuery::GetSubmissionSummary::~GetSubmissionSummary()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetSubmissionSummary::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetSubmissionSummary : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                       { 
+                    /*
+                     * building Ids array
+                     */
+                       std::vector<AviaryCommon::SubmissionID*>* arr_list =new std::vector<AviaryCommon::SubmissionID*>();
+                   
+
+                     
+                     /*
+                      * building ids element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "ids", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("ids", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::SubmissionID* element = new AviaryCommon::SubmissionID();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element ids ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for ids ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setIds(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "partialMatches"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "partialMatches", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "partialMatches");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setPartialMatches(true);
+                           }
+                           else
+                           {
+                               setPartialMatches(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "includeJobSummaries"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "includeJobSummaries", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "includeJobSummaries");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setIncludeJobSummaries(true);
+                           }
+                           else
+                           {
+                               setIncludeJobSummaries(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetSubmissionSummary::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetSubmissionSummary::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetSubmissionSummary::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_2[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                    axis2_char_t text_value_3[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetSubmissionSummary", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidPartialMatches)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_PartialMatches)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("partialMatches")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "partialMatches",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+                if(isValidIncludeJobSummaries)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_IncludeJobSummaries)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("includeJobSummaries")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "includeJobSummaries",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+            }
+            
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidIds)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("ids"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("ids")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Ids array
+                      */
+                     if (property_Ids != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%sids",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%sids>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Ids->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::SubmissionID* element = (*property_Ids)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing ids element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidPartialMatches)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_PartialMatches)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "partialMatches", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidIncludeJobSummaries)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_IncludeJobSummaries)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "includeJobSummaries", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for ids by  Property Number 1
+             */
+            std::vector<AviaryCommon::SubmissionID*>* WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getProperty1()
+            {
+                return getIds();
+            }
+
+            /**
+             * getter for ids.
+             */
+            std::vector<AviaryCommon::SubmissionID*>* WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getIds()
+             {
+                return property_Ids;
+             }
+
+            /**
+             * setter for ids
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::setIds(
+                    std::vector<AviaryCommon::SubmissionID*>*  arg_Ids)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidIds &&
+                        arg_Ids == property_Ids)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Ids->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"ids has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Ids)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetIds();
+
+                
+                    if(NULL == arg_Ids)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Ids = arg_Ids;
+                        if(non_nil_exists)
+                        {
+                            isValidIds = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of ids.
+             */
+            AviaryCommon::SubmissionID* WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getIdsAt(int i)
+            {
+                AviaryCommon::SubmissionID* ret_val;
+                if(property_Ids == NULL)
+                {
+                    return (AviaryCommon::SubmissionID*)0;
+                }
+                ret_val =   (*property_Ids)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of ids.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::setIdsAt(int i,
+                    AviaryCommon::SubmissionID* arg_Ids)
+            {
+                 AviaryCommon::SubmissionID* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidIds &&
+                    property_Ids &&
+                  
+                    arg_Ids == (*property_Ids)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::SubmissionID*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Ids)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = true;
+                        (*property_Ids)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Ids)[i] = arg_Ids;
+                  
+
+               isValidIds = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to ids.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::addIds(
+                    AviaryCommon::SubmissionID* arg_Ids)
+             {
+
+                
+                    if( NULL == arg_Ids
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Ids == NULL)
+                {
+                    property_Ids = new std::vector<AviaryCommon::SubmissionID*>();
+                }
+              
+               property_Ids->push_back(arg_Ids);
+              
+                isValidIds = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the ids array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetSubmissionSummary::sizeofIds()
+            {
+
+                if(property_Ids == NULL)
+                {
+                    return 0;
+                }
+                return property_Ids->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::removeIdsAt(int i)
+            {
+                return setIdsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for ids
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::resetIds()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Ids != NULL)
+                {
+                  std::vector<AviaryCommon::SubmissionID*>::iterator it =  property_Ids->begin();
+                  for( ; it <  property_Ids->end() ; ++it)
+                  {
+                     AviaryCommon::SubmissionID* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Ids)
+                 delete property_Ids;
+                
+               isValidIds = false; 
+               return true;
+           }
+
+           /**
+            * Check whether ids is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::isIdsNil()
+           {
+               return !isValidIds;
+           }
+
+           /**
+            * Set ids to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::setIdsNil()
+           {
+               return resetIds();
+           }
+
+           
+           /**
+            * Check whether ids is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::isIdsNilAt(int i)
+           {
+               return (isValidIds == false ||
+                       NULL == property_Ids ||
+                     NULL == (*property_Ids)[i]);
+            }
+
+           /**
+            * Set ids to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::setIdsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Ids == NULL ||
+                            isValidIds == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Ids->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Ids)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of ids is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Ids == NULL)
+                {
+                    isValidIds = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::SubmissionID* element = (*property_Ids)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidIds = false;
+                        (*property_Ids)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Ids)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
+            /**
+             * Getter for partialMatches by  Property Number 2
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getProperty2()
+            {
+                return getPartialMatches();
+            }
+
+            /**
+             * getter for partialMatches.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getPartialMatches()
+             {
+                return property_PartialMatches;
+             }
+
+            /**
+             * setter for partialMatches
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::setPartialMatches(
+                    bool  arg_PartialMatches)
+             {
+                
+
+                if(isValidPartialMatches &&
+                        arg_PartialMatches == property_PartialMatches)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetPartialMatches();
+
+                
+                        property_PartialMatches = arg_PartialMatches;
+                        isValidPartialMatches = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for partialMatches
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::resetPartialMatches()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidPartialMatches = false; 
+               return true;
+           }
+
+           /**
+            * Check whether partialMatches is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::isPartialMatchesNil()
+           {
+               return !isValidPartialMatches;
+           }
+
+           /**
+            * Set partialMatches to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::setPartialMatchesNil()
+           {
+               return resetPartialMatches();
+           }
+
+           
+
+            /**
+             * Getter for includeJobSummaries by  Property Number 3
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getProperty3()
+            {
+                return getIncludeJobSummaries();
+            }
+
+            /**
+             * getter for includeJobSummaries.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::getIncludeJobSummaries()
+             {
+                return property_IncludeJobSummaries;
+             }
+
+            /**
+             * setter for includeJobSummaries
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummary::setIncludeJobSummaries(
+                    bool  arg_IncludeJobSummaries)
+             {
+                
+
+                if(isValidIncludeJobSummaries &&
+                        arg_IncludeJobSummaries == property_IncludeJobSummaries)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetIncludeJobSummaries();
+
+                
+                        property_IncludeJobSummaries = arg_IncludeJobSummaries;
+                        isValidIncludeJobSummaries = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for includeJobSummaries
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::resetIncludeJobSummaries()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidIncludeJobSummaries = false; 
+               return true;
+           }
+
+           /**
+            * Check whether includeJobSummaries is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::isIncludeJobSummariesNil()
+           {
+               return !isValidIncludeJobSummaries;
+           }
+
+           /**
+            * Set includeJobSummaries to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummary::setIncludeJobSummariesNil()
+           {
+               return resetIncludeJobSummaries();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummaryResponse.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummaryResponse.cpp
new file mode 100644
index 0000000..b780821
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_GetSubmissionSummaryResponse.cpp
@@ -0,0 +1,776 @@
+
+
+        /**
+         * GetSubmissionSummaryResponse.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_GetSubmissionSummaryResponse.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+               /*
+                * Implementation of the GetSubmissionSummaryResponse|http://query.aviary.grid.redhat.com Element
+                */
+           AviaryQuery::GetSubmissionSummaryResponse::GetSubmissionSummaryResponse()
+        {
+
+        
+            qname = NULL;
+        
+                property_Submissions  = NULL;
+              
+            isValidSubmissions  = false;
+        
+                  qname =  axutil_qname_create (Environment::getEnv(),
+                        "GetSubmissionSummaryResponse",
+                        "http://query.aviary.grid.redhat.com",
+                        NULL);
+                
+        }
+
+       AviaryQuery::GetSubmissionSummaryResponse::GetSubmissionSummaryResponse(std::vector<AviaryCommon::SubmissionSummary*>* arg_Submissions)
+        {
+             
+                   qname = NULL;
+             
+               property_Submissions  = NULL;
+             
+            isValidSubmissions  = true;
+            
+                 qname =  axutil_qname_create (Environment::getEnv(),
+                       "GetSubmissionSummaryResponse",
+                       "http://query.aviary.grid.redhat.com",
+                       NULL);
+               
+                    property_Submissions = arg_Submissions;
+            
+        }
+        AviaryQuery::GetSubmissionSummaryResponse::~GetSubmissionSummaryResponse()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::GetSubmissionSummaryResponse::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+               int i = 0;
+            
+               int sequence_broken = 0;
+               axiom_node_t *tmp_node = NULL;
+            
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+
+                    current_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                    mqname = axiom_element_get_qname(current_element, Environment::getEnv(), parent);
+                    if (axutil_qname_equals(mqname, Environment::getEnv(), this->qname))
+                    {
+                        
+                          first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                          
+                    }
+                    else
+                    {
+                        WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI,
+                              "Failed in building adb object for GetSubmissionSummaryResponse : "
+                              "Expected %s but returned %s",
+                              axutil_qname_to_string(qname, Environment::getEnv()),
+                              axutil_qname_to_string(mqname, Environment::getEnv()));
+                        
+                        return AXIS2_FAILURE;
+                    }
+                    
+                       { 
+                    /*
+                     * building Submissions array
+                     */
+                       std::vector<AviaryCommon::SubmissionSummary*>* arr_list =new std::vector<AviaryCommon::SubmissionSummary*>();
+                   
+
+                     
+                     /*
+                      * building submissions element
+                      */
+                     
+                     
+                     
+                                    element_qname = axutil_qname_create(Environment::getEnv(), "submissions", NULL, NULL);
+                                  
+                               
+                               for (i = 0, sequence_broken = 0, current_node = first_node; !sequence_broken && current_node != NULL;)
+                                             
+                               {
+                                  if(axiom_node_get_node_type(current_node, Environment::getEnv()) != AXIOM_ELEMENT)
+                                  {
+                                     current_node =axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                     is_early_node_valid = false;
+                                     continue;
+                                  }
+                                  
+                                  current_element = (axiom_element_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                                  mqname = axiom_element_get_qname(current_element, Environment::getEnv(), current_node);
+
+                                  if (axutil_qname_equals(element_qname, Environment::getEnv(), mqname) || !axutil_strcmp("submissions", axiom_element_get_localname(current_element, Environment::getEnv())))
+                                  {
+                                  
+                                      is_early_node_valid = true;
+                                      
+                                     AviaryCommon::SubmissionSummary* element = new AviaryCommon::SubmissionSummary();
+                                          
+                                          status =  element->deserialize(&current_node, &is_early_node_valid, false);
+                                          
+                                          if(AXIS2_FAILURE ==  status)
+                                          {
+					  WSF_LOG_ERROR_MSG(Environment::getEnv()->log,WSF_LOG_SI, "failed in building element submissions ");
+                                          }
+                                          else
+                                          {
+                                            arr_list->push_back(element);
+                                            
+                                          }
+                                        
+                                     if(AXIS2_FAILURE ==  status)
+                                     {
+                                         WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "failed in setting the value for submissions ");
+                                         if(element_qname)
+                                         {
+                                            axutil_qname_free(element_qname, Environment::getEnv());
+                                         }
+                                         if(arr_list)
+                                         {
+                                            delete arr_list;
+                                         }
+                                         return false;
+                                     }
+
+                                     i++;
+                                    current_node = axiom_node_get_next_sibling(current_node, Environment::getEnv());
+                                  }
+                                  else
+                                  {
+                                      is_early_node_valid = false;
+                                      sequence_broken = 1;
+                                  }
+                                  
+                               }
+
+                               
+                                   if (i < 0)
+                                   {
+                                     /* found element out of order */
+                                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"submissions (@minOccurs = '0') only have %d elements", i);
+                                     if(element_qname)
+                                     {
+                                        axutil_qname_free(element_qname, Environment::getEnv());
+                                     }
+                                     if(arr_list)
+                                     {
+                                        delete arr_list;
+                                     }
+                                     return false;
+                                   }
+                               
+
+                               if(0 == arr_list->size())
+                               {
+                                    delete arr_list;
+                               }
+                               else
+                               {
+                                    status = setSubmissions(arr_list);
+                               }
+
+                              
+                            } 
+                        
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::GetSubmissionSummaryResponse::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::GetSubmissionSummaryResponse::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::GetSubmissionSummaryResponse::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+               int i = 0;
+               int count = 0;
+               void *element = NULL;
+             
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+               axis2_char_t *start_input_str = NULL;
+               axis2_char_t *end_input_str = NULL;
+               unsigned int start_input_str_len = 0;
+               unsigned int end_input_str_len = 0;
+            
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+             
+                int next_ns_index_value = 0;
+             
+                    namespaces = axutil_hash_make(Environment::getEnv());
+                    next_ns_index = &next_ns_index_value;
+                     
+                           ns1 = axiom_namespace_create (Environment::getEnv(),
+                                             "http://query.aviary.grid.redhat.com",
+                                             "n"); 
+                           axutil_hash_set(namespaces, "http://query.aviary.grid.redhat.com", AXIS2_HASH_KEY_STRING, axutil_strdup(Environment::getEnv(), "n"));
+                       
+                     
+                    parent_element = axiom_element_create (Environment::getEnv(), NULL, "GetSubmissionSummaryResponse", ns1 , &parent);
+                    
+                    
+                    axiom_element_set_namespace(parent_element, Environment::getEnv(), ns1, parent);
+
+
+            
+                    data_source = axiom_data_source_create(Environment::getEnv(), parent, &current_node);
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv());
+                  
+                       p_prefix = NULL;
+                      
+
+                   if (!isValidSubmissions)
+                   {
+                      
+                           /* no need to complain for minoccurs=0 element */
+                            
+                          
+                   }
+                   else
+                   {
+                     start_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (4 + axutil_strlen(p_prefix) + 
+                                  axutil_strlen("submissions"))); 
+                                 
+                                 /* axutil_strlen("<:>") + 1 = 4 */
+                     end_input_str = (axis2_char_t*)AXIS2_MALLOC(Environment::getEnv()->allocator, sizeof(axis2_char_t) *
+                                 (5 + axutil_strlen(p_prefix) + axutil_strlen("submissions")));
+                                  /* axutil_strlen("</:>") + 1 = 5 */
+                                  
+                     
+
+                   
+                   
+                     /*
+                      * Parsing Submissions array
+                      */
+                     if (property_Submissions != NULL)
+                     {
+                        
+
+                            sprintf(start_input_str, "<%s%ssubmissions",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                            
+                         start_input_str_len = axutil_strlen(start_input_str);
+
+                         sprintf(end_input_str, "</%s%ssubmissions>",
+                                 p_prefix?p_prefix:"",
+                                 (p_prefix && axutil_strcmp(p_prefix, ""))?":":"");
+                         end_input_str_len = axutil_strlen(end_input_str);
+
+                         count = property_Submissions->size();
+                         for(i = 0; i < count; i++)
+                         {
+                            AviaryCommon::SubmissionSummary* element = (*property_Submissions)[i];
+
+                            if(NULL == element) 
+                            {
+                                continue;
+                            }
+
+                    
+                     
+                     /*
+                      * parsing submissions element
+                      */
+
+                    
+                     
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), start_input_str, start_input_str_len);
+                            }
+                            element->serialize(current_node, parent_element,
+                                                                                 element->isParticle() || false, namespaces, next_ns_index);
+                            
+                            if(!element->isParticle())
+                            {
+                                axutil_stream_write(stream, Environment::getEnv(), end_input_str, end_input_str_len);
+                            }
+                            
+                         }
+                     }
+                   
+                     
+                     AXIS2_FREE(Environment::getEnv()->allocator,start_input_str);
+                     AXIS2_FREE(Environment::getEnv()->allocator,end_input_str);
+                 } 
+
+                 
+                   if(namespaces)
+                   {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       for (hi = axutil_hash_first(namespaces, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, NULL, NULL, &val);
+                           AXIS2_FREE(Environment::getEnv()->allocator, val);
+                       }
+                       axutil_hash_free(namespaces, Environment::getEnv());
+                   }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for submissions by  Property Number 1
+             */
+            std::vector<AviaryCommon::SubmissionSummary*>* WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::getProperty1()
+            {
+                return getSubmissions();
+            }
+
+            /**
+             * getter for submissions.
+             */
+            std::vector<AviaryCommon::SubmissionSummary*>* WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::getSubmissions()
+             {
+                return property_Submissions;
+             }
+
+            /**
+             * setter for submissions
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::setSubmissions(
+                    std::vector<AviaryCommon::SubmissionSummary*>*  arg_Submissions)
+             {
+                
+                 int size = 0;
+                 int i = 0;
+                 bool non_nil_exists = false;
+                
+
+                if(isValidSubmissions &&
+                        arg_Submissions == property_Submissions)
+                {
+                    
+                    return true;
+                }
+
+                
+                 size = arg_Submissions->size();
+                 
+                 if (size < 0)
+                 {
+                     WSF_LOG_ERROR_MSG( Environment::getEnv()->log,WSF_LOG_SI,"submissions has less than minOccurs(0)");
+                     return false;
+                 }
+                 for(i = 0; i < size; i ++ )
+                 {
+                     if(NULL != (*arg_Submissions)[i])
+                     {
+                         non_nil_exists = true;
+                         break;
+                     }
+                 }
+
+                 
+
+                
+                resetSubmissions();
+
+                
+                    if(NULL == arg_Submissions)
+                         
+                {
+                    /* We are already done */
+                    return true;
+                }
+                
+                        property_Submissions = arg_Submissions;
+                        if(non_nil_exists)
+                        {
+                            isValidSubmissions = true;
+                        }
+                        
+                    
+                return true;
+             }
+
+            
+            /**
+             * Get ith element of submissions.
+             */
+            AviaryCommon::SubmissionSummary* WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::getSubmissionsAt(int i)
+            {
+                AviaryCommon::SubmissionSummary* ret_val;
+                if(property_Submissions == NULL)
+                {
+                    return (AviaryCommon::SubmissionSummary*)0;
+                }
+                ret_val =   (*property_Submissions)[i];
+                
+                    return ret_val;
+                  
+            }
+
+            /**
+             * Set the ith element of submissions.
+             */
+           bool WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::setSubmissionsAt(int i,
+                    AviaryCommon::SubmissionSummary* arg_Submissions)
+            {
+                 AviaryCommon::SubmissionSummary* element;
+                int size = 0;
+
+                int non_nil_count;
+                bool non_nil_exists = false;
+
+                 
+
+                if( isValidSubmissions &&
+                    property_Submissions &&
+                  
+                    arg_Submissions == (*property_Submissions)[i])
+                  
+                 {
+                    
+                    return AXIS2_SUCCESS; 
+                }
+
+                   
+                     non_nil_exists = true;
+                  
+
+                if(property_Submissions == NULL)
+                {
+                    property_Submissions = new std::vector<AviaryCommon::SubmissionSummary*>();
+                }
+                else{
+                /* check whether there already exist an element */
+                element = (*property_Submissions)[i];
+                }
+
+                
+                        if(NULL != element)
+                        {
+                          
+                          
+                          
+                                delete element;
+                             
+                        }
+                        
+                    
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidSubmissions = true;
+                        (*property_Submissions)[i]= NULL;
+                        
+                        return AXIS2_SUCCESS;
+                    }
+                
+                    (*property_Submissions)[i] = arg_Submissions;
+                  
+
+               isValidSubmissions = true;
+                
+                return AXIS2_SUCCESS;
+            }
+
+            /**
+             * Add to submissions.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::addSubmissions(
+                    AviaryCommon::SubmissionSummary* arg_Submissions)
+             {
+
+                
+                    if( NULL == arg_Submissions
+                     )
+                    {
+                      
+                           return true; 
+                        
+                    }
+                  
+
+                if(property_Submissions == NULL)
+                {
+                    property_Submissions = new std::vector<AviaryCommon::SubmissionSummary*>();
+                }
+              
+               property_Submissions->push_back(arg_Submissions);
+              
+                isValidSubmissions = true;
+                return true;
+             }
+
+            /**
+             * Get the size of the submissions array.
+             */
+            int WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::sizeofSubmissions()
+            {
+
+                if(property_Submissions == NULL)
+                {
+                    return 0;
+                }
+                return property_Submissions->size();
+            }
+
+            /**
+             * remove the ith element, same as set_nil_at.
+             */
+            bool WSF_CALL
+            AviaryQuery::GetSubmissionSummaryResponse::removeSubmissionsAt(int i)
+            {
+                return setSubmissionsNilAt(i);
+            }
+
+            
+
+           /**
+            * resetter for submissions
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::resetSubmissions()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+                if (property_Submissions != NULL)
+                {
+                  std::vector<AviaryCommon::SubmissionSummary*>::iterator it =  property_Submissions->begin();
+                  for( ; it <  property_Submissions->end() ; ++it)
+                  {
+                     AviaryCommon::SubmissionSummary* element = *it;
+                
+            
+                
+
+                if(element != NULL)
+                {
+                   
+                   
+                         delete  element;
+                     
+
+                   }
+
+                
+                
+                
+               }
+
+             }
+                
+                    if(NULL != property_Submissions)
+                 delete property_Submissions;
+                
+               isValidSubmissions = false; 
+               return true;
+           }
+
+           /**
+            * Check whether submissions is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::isSubmissionsNil()
+           {
+               return !isValidSubmissions;
+           }
+
+           /**
+            * Set submissions to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::setSubmissionsNil()
+           {
+               return resetSubmissions();
+           }
+
+           
+           /**
+            * Check whether submissions is nill at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::isSubmissionsNilAt(int i)
+           {
+               return (isValidSubmissions == false ||
+                       NULL == property_Submissions ||
+                     NULL == (*property_Submissions)[i]);
+            }
+
+           /**
+            * Set submissions to nil at i
+            */
+           bool WSF_CALL
+           AviaryQuery::GetSubmissionSummaryResponse::setSubmissionsNilAt(int i)
+           {
+                int size = 0;
+                int j;
+                bool non_nil_exists = false;
+
+                int k = 0;
+
+                if(property_Submissions == NULL ||
+                            isValidSubmissions == false)
+                {
+                    
+                    non_nil_exists = false;
+                }
+                else
+                {
+                    size = property_Submissions->size();
+                    for(j = 0, k = 0; j < size; j ++ )
+                    {
+                        if(i == j) continue; 
+                        if(NULL != (*property_Submissions)[i])
+                        {
+                            k++;
+                            non_nil_exists = true;
+                            if( k >= 0)
+                            {
+                                break;
+                            }
+                        }
+                    }
+                }
+                
+
+                if( k < 0)
+                {
+                       WSF_LOG_ERROR_MSG(Environment::getEnv()->log, WSF_LOG_SI, "Size of the array of submissions is beinng set to be smaller than the specificed number of minOccurs(0)");
+                       return AXIS2_FAILURE;
+                }
+ 
+                if(property_Submissions == NULL)
+                {
+                    isValidSubmissions = false;
+                    
+                    return true;
+                }
+                 
+                 /* check whether there already exist an element */
+                 AviaryCommon::SubmissionSummary* element = (*property_Submissions)[i];
+                if(NULL != element)
+                {
+                  
+                  
+                  
+                        delete element;
+                     
+                 }
+                 
+                    if(!non_nil_exists)
+                    {
+                        
+                        isValidSubmissions = false;
+                        (*property_Submissions)[i] = NULL;
+                        return AXIS2_SUCCESS;
+                    }
+                
+
+                
+                (*property_Submissions)[i] = NULL;
+                
+                return AXIS2_SUCCESS;
+
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_QueryRequestType.cpp b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_QueryRequestType.cpp
new file mode 100644
index 0000000..f59b227
--- /dev/null
+++ b/src/condor_contrib/aviary/codegen/query/src/AviaryQuery_QueryRequestType.cpp
@@ -0,0 +1,346 @@
+
+
+        /**
+         * QueryRequestType.cpp
+         *
+         * This file was auto-generated from WSDL
+         * by the Apache Axis2/C version: SNAPSHOT  Built on : Mar 10, 2008 (08:35:52 GMT+00:00)
+         */
+
+        #include "AviaryQuery_QueryRequestType.h"
+        #include <Environment.h>
+        #include <WSFError.h>
+
+
+        using namespace wso2wsf;
+        using namespace std;
+        
+        using namespace AviaryQuery;
+        
+                /*
+                 * This type was generated from the piece of schema that had
+                 * name = QueryRequestType
+                 * Namespace URI = http://query.aviary.grid.redhat.com
+                 * Namespace Prefix = ns2
+                 */
+           AviaryQuery::QueryRequestType::QueryRequestType()
+        {
+
+        
+            isValidAllowPartialMatching  = false;
+        
+        }
+
+       AviaryQuery::QueryRequestType::QueryRequestType(bool arg_AllowPartialMatching)
+        {
+             
+            isValidAllowPartialMatching  = true;
+            
+                    property_AllowPartialMatching = arg_AllowPartialMatching;
+            
+        }
+        AviaryQuery::QueryRequestType::~QueryRequestType()
+        {
+
+        }
+
+        
+
+        bool WSF_CALL
+        AviaryQuery::QueryRequestType::deserialize(axiom_node_t** dp_parent,bool *dp_is_early_node_valid, bool dont_care_minoccurs)
+        {
+          axiom_node_t *parent = *dp_parent;
+          
+          bool status = AXIS2_SUCCESS;
+          
+          axiom_attribute_t *parent_attri = NULL;
+          axiom_element_t *parent_element = NULL;
+          axis2_char_t *attrib_text = NULL;
+
+          axutil_hash_t *attribute_hash = NULL;
+
+           
+         const axis2_char_t* text_value = NULL;
+         axutil_qname_t *mqname = NULL;
+          
+            axutil_qname_t *element_qname = NULL; 
+            
+               axiom_node_t *first_node = NULL;
+               bool is_early_node_valid = true;
+               axiom_node_t *current_node = NULL;
+               axiom_element_t *current_element = NULL;
+            
+              
+              while(parent && axiom_node_get_node_type(parent, Environment::getEnv()) != AXIOM_ELEMENT)
+              {
+                  parent = axiom_node_get_next_sibling(parent, Environment::getEnv());
+              }
+              if (NULL == parent)
+              {   
+                return AXIS2_FAILURE;
+              }
+              
+                      
+                      first_node = axiom_node_get_first_child(parent, Environment::getEnv());
+                      
+                    
+                 parent_element = (axiom_element_t *)axiom_node_get_data_element(parent, Environment::getEnv());
+                 attribute_hash = axiom_element_get_all_attributes(parent_element, Environment::getEnv());
+              
+                
+                
+                  parent_attri = NULL;
+                  attrib_text = NULL;
+                  if(attribute_hash)
+                  {
+                       axutil_hash_index_t *hi;
+                       void *val;
+                       const void *key;
+
+                       for (hi = axutil_hash_first(attribute_hash, Environment::getEnv()); hi; hi = axutil_hash_next(Environment::getEnv(), hi))
+                       {
+                           axutil_hash_this(hi, &key, NULL, &val);
+                           
+                           
+                               if(!strcmp((axis2_char_t*)key, "allowPartialMatching"))
+                             
+                               {
+                                   parent_attri = (axiom_attribute_t*)val;
+                                   break;
+                               }
+                       }
+                  }
+
+                  if(parent_attri)
+                  {
+                    attrib_text = axiom_attribute_get_value(parent_attri, Environment::getEnv());
+                  }
+                  else
+                  {
+                    /* this is hoping that attribute is stored in "allowPartialMatching", this happnes when name is in default namespace */
+                    attrib_text = axiom_element_get_attribute_value_by_name(parent_element, Environment::getEnv(), "allowPartialMatching");
+                  }
+
+                  if(attrib_text != NULL)
+                  {
+                      
+                      
+                           if (!axutil_strcmp(attrib_text, "TRUE") || !axutil_strcmp(attrib_text, "true"))
+                           {
+                               setAllowPartialMatching(true);
+                           }
+                           else
+                           {
+                               setAllowPartialMatching(false);
+                           }
+                        
+                    }
+                  
+                  if(element_qname)
+                  {
+                     axutil_qname_free(element_qname, Environment::getEnv());
+                     element_qname = NULL;
+                  }
+                 
+          return status;
+       }
+
+          bool WSF_CALL
+          AviaryQuery::QueryRequestType::isParticle()
+          {
+            
+                 return false;
+              
+          }
+
+
+          void WSF_CALL
+          AviaryQuery::QueryRequestType::declareParentNamespaces(
+                    axiom_element_t *parent_element,
+                    axutil_hash_t *namespaces, int *next_ns_index)
+          {
+            
+                  /* Here this is an empty function, Nothing to declare */
+                 
+          }
+
+        
+        
+        axiom_node_t* WSF_CALL
+	AviaryQuery::QueryRequestType::serialize(axiom_node_t *parent, 
+			axiom_element_t *parent_element, 
+			int parent_tag_closed, 
+			axutil_hash_t *namespaces, 
+			int *next_ns_index)
+        {
+            
+            
+               axiom_attribute_t *text_attri = NULL;
+             
+             axis2_char_t *string_to_stream;
+            
+         
+         axiom_node_t *current_node = NULL;
+         int tag_closed = 0;
+
+         
+         
+                axiom_namespace_t *ns1 = NULL;
+
+                axis2_char_t *qname_uri = NULL;
+                axis2_char_t *qname_prefix = NULL;
+                axis2_char_t *p_prefix = NULL;
+            
+                    axis2_char_t text_value_1[ADB_DEFAULT_DIGIT_LIMIT];
+                    
+                axis2_char_t *text_value = NULL;
+             
+            
+               axiom_data_source_t *data_source = NULL;
+               axutil_stream_t *stream = NULL;
+
+            
+                    current_node = parent;
+                    data_source = (axiom_data_source_t *)axiom_node_get_data_element(current_node, Environment::getEnv());
+                    if (!data_source)
+                        return NULL;
+                    stream = axiom_data_source_get_stream(data_source, Environment::getEnv()); /* assume parent is of type data source */
+                    if (!stream)
+                        return NULL;
+                  
+            if(!parent_tag_closed)
+            {
+            
+                if(isValidAllowPartialMatching)
+                {
+                
+                        p_prefix = NULL;
+                      
+                           
+                           text_value = (axis2_char_t*)((property_AllowPartialMatching)?"true":"false");
+                           string_to_stream = (axis2_char_t*) AXIS2_MALLOC (Environment::getEnv()-> allocator, sizeof (axis2_char_t) *
+                                                            (5  + ADB_DEFAULT_NAMESPACE_PREFIX_LIMIT +
+                                                             axutil_strlen(text_value) + 
+                                                             axutil_strlen("allowPartialMatching")));
+                           sprintf(string_to_stream, " %s%s%s=\"%s\"", p_prefix?p_prefix:"", (p_prefix && axutil_strcmp(p_prefix, ""))?":":"",
+                                                "allowPartialMatching",  text_value);
+                           axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+                           AXIS2_FREE(Environment::getEnv()-> allocator, string_to_stream);
+                        
+                   }
+                   
+              string_to_stream = ">"; 
+              axutil_stream_write(stream, Environment::getEnv(), string_to_stream, axutil_strlen(string_to_stream));
+              tag_closed = 1;
+            
+            }
+            
+                    
+                    if(parent_tag_closed)
+                    {
+                       if(isValidAllowPartialMatching)
+                       {
+                       
+                           p_prefix = NULL;
+                           ns1 = NULL;
+                         
+                           
+                           text_value =  (axis2_char_t*)((property_AllowPartialMatching)?axutil_strdup(Environment::getEnv(), "true"):axutil_strdup(Environment::getEnv(), "false"));
+                           text_attri = axiom_attribute_create (Environment::getEnv(), "allowPartialMatching", text_value, ns1);
+                           axiom_element_add_attribute (parent_element, Environment::getEnv(), text_attri, parent);
+                           AXIS2_FREE(Environment::getEnv()->allocator, text_value);
+                        
+                      }
+                       
+                  }
+                
+
+            return parent;
+        }
+
+
+        
+
+            /**
+             * Getter for allowPartialMatching by  Property Number 1
+             */
+            bool WSF_CALL
+            AviaryQuery::QueryRequestType::getProperty1()
+            {
+                return getAllowPartialMatching();
+            }
+
+            /**
+             * getter for allowPartialMatching.
+             */
+            bool WSF_CALL
+            AviaryQuery::QueryRequestType::getAllowPartialMatching()
+             {
+                return property_AllowPartialMatching;
+             }
+
+            /**
+             * setter for allowPartialMatching
+             */
+            bool WSF_CALL
+            AviaryQuery::QueryRequestType::setAllowPartialMatching(
+                    bool  arg_AllowPartialMatching)
+             {
+                
+
+                if(isValidAllowPartialMatching &&
+                        arg_AllowPartialMatching == property_AllowPartialMatching)
+                {
+                    
+                    return true;
+                }
+
+                
+
+                
+                resetAllowPartialMatching();
+
+                
+                        property_AllowPartialMatching = arg_AllowPartialMatching;
+                        isValidAllowPartialMatching = true;
+                    
+                return true;
+             }
+
+             
+
+           /**
+            * resetter for allowPartialMatching
+            */
+           bool WSF_CALL
+           AviaryQuery::QueryRequestType::resetAllowPartialMatching()
+           {
+               int i = 0;
+               int count = 0;
+
+
+               
+               isValidAllowPartialMatching = false; 
+               return true;
+           }
+
+           /**
+            * Check whether allowPartialMatching is nill
+            */
+           bool WSF_CALL
+           AviaryQuery::QueryRequestType::isAllowPartialMatchingNil()
+           {
+               return !isValidAllowPartialMatching;
+           }
+
+           /**
+            * Set allowPartialMatching to nill (currently the same as reset)
+            */
+           bool WSF_CALL
+           AviaryQuery::QueryRequestType::setAllowPartialMatchingNil()
+           {
+               return resetAllowPartialMatching();
+           }
+
+           
+
diff --git a/src/condor_contrib/aviary/etc/61aviary.config b/src/condor_contrib/aviary/etc/61aviary.config
new file mode 100644
index 0000000..5fdc884
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/61aviary.config
@@ -0,0 +1,34 @@
+# Base configuration for Aviary
+#
+# Included is the Schedd plugin, AviaryScheddPlugin-plugin.so, and the aviary_query_server
+
+# The general Aviary config file for Axis2
+# axis2.xml has parameters that point to lib and services dir
+WSFCPP_HOME=/var/lib/condor/aviary/axis2.xml
+
+# Aviary Schedd plugin, provides submission and job control endpoint
+SCHEDD.PLUGINS = $(SCHEDD.PLUGINS) $(LIB)/plugins/AviaryScheddPlugin-plugin.so
+
+# Port the Aviary Schedd plugin listens on, default 9090
+#SCHEDD.HTTP_PORT = 9090
+
+# Aviary query server, provides endpoint for job and submission queries
+QUERY_SERVER = $(SBIN)/aviary_query_server
+QUERY_SERVER_ARGS = -f
+QUERY_SERVER.QUERY_SERVER_LOG = $(LOG)/QueryServerLog
+QUERY_SERVER.QUERY_SERVER_DEBUG = D_ALWAYS
+DAEMON_LIST = $(DAEMON_LIST), QUERY_SERVER
+
+# Port the QueryServer listens on, default 9091
+#QUERY_SERVER.HTTP_PORT = 9091
+
+# HISTORY_INTERVAL specifies the number of seconds between polls of the HISTORY file, default 120
+#QUERY_SERVER.HISTORY_INTERVAL = 120
+
+# If there is more than one Schedd on the system or if the Schedd and
+# QueryServer reside on different systems, it is necessary to tell the
+# QueryServer the name of the Schedd it is working with via
+# QUERY_SERVER.SCHEDD_NAME. This allows the QueryServer to provide
+# fully-qualified job ids, i.e. cluster.proc:pool:scheduler. Default
+# is constructed in the same way the Schedd constructs its name.
+#QUERY_SERVER.SCHEDD_NAME =
diff --git a/src/condor_contrib/aviary/etc/aviary-common.xsd b/src/condor_contrib/aviary/etc/aviary-common.xsd
new file mode 100644
index 0000000..30f20be
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-common.xsd
@@ -0,0 +1,203 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://common.aviary.grid.redhat.com" targetNamespace="http://common.aviary.grid.redhat.com">
+	<!-- common types should make use of simple and complex types for reuse -->
+	<xs:simpleType name="StatusCodeType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="OK"/>
+			<xs:enumeration value="FAIL"/>
+			<xs:enumeration value="NO_MATCH"/>
+			<xs:enumeration value="INVALID_OFFSET"/>
+			<xs:enumeration value="UNIMPLEMENTED"/>
+			<xs:enumeration value="UNAVAILABLE"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="Status">
+		<xs:sequence>
+			<xs:element name="code" type="tns:StatusCodeType"/>
+			<xs:element name="text" type="xs:string" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="AttributeType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="INTEGER"/>
+			<xs:enumeration value="FLOAT"/>
+			<xs:enumeration value="STRING"/>
+			<xs:enumeration value="EXPRESSION"/>
+			<xs:enumeration value="BOOLEAN"/>
+			<xs:enumeration value="UNDEFINED"/>
+			<xs:enumeration value="ERROR"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="Attribute">
+		<xs:sequence>
+			<xs:element name="name" type="xs:string"/>
+			<xs:element name="type" type="tns:AttributeType"/>
+			<xs:element name="value" type="xs:string"/>
+		</xs:sequence>
+	</xs:complexType>
+	<!-- might just want to use the following just for returning data like in getJobDetails -->
+	<xs:complexType name="Attributes">
+		<xs:sequence>
+			<xs:element name="attrs" type="tns:Attribute" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="OSType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="LINUX"/>
+			<xs:enumeration value="WINDOWS"/>
+			<!-- can expand later -->
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="ArchType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="INTEL"/>
+			<xs:enumeration value="X86_64"/>
+			<!-- can expand later -->
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="ResourceConstraintType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="OS"/>
+			<xs:enumeration value="ARCH"/>
+			<xs:enumeration value="MEMORY"/>
+			<xs:enumeration value="DISK"/>
+			<xs:enumeration value="FILESYSTEM"/>
+			<!-- when we say MEMORY or DISK we always mean at least the amount provided -->
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="ResourceConstraint">
+		<xs:sequence>
+			<xs:element name="type" type="tns:ResourceConstraintType"/>
+			<xs:element name="value" type="xs:string"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="JobConstraintType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="CMD"/>
+			<xs:enumeration value="ARGS"/>
+			<xs:enumeration value="OWNER"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="JobConstraint">
+		<xs:sequence>
+			<xs:element name="type" type="tns:JobConstraintType"/>
+			<xs:element name="value" type="xs:string"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="SubmissionID">
+		<xs:sequence>
+			<xs:element name="name" type="xs:string" minOccurs="0"/>
+			<xs:element name="owner" type="xs:string" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="JobID">
+		<xs:sequence>
+			<xs:element name="job" type="xs:string"/>
+			<xs:element name="pool" type="xs:string" minOccurs="0"/>
+			<xs:element name="scheduler" type="xs:string" minOccurs="0"/>
+			<xs:element name="submission" type="tns:SubmissionID" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="JobStatusType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="IDLE"/>
+			<xs:enumeration value="RUNNING"/>
+			<xs:enumeration value="REMOVED"/>
+			<xs:enumeration value="COMPLETED"/>
+			<xs:enumeration value="HELD"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<!-- reuse through extension not available for the following related types -->
+	<xs:complexType name="JobStatus">
+		<xs:sequence>
+			<xs:element name="id" type="tns:JobID"/>
+			<xs:element name="status" type="tns:Status"/>
+			<xs:element name="job_status" type="tns:JobStatusType" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="JobSummary">
+		<xs:sequence>
+			<xs:element name="id" type="tns:JobID"/>
+			<xs:element name="status" type="tns:Status"/>
+			<xs:element name="queued" type="xs:dateTime"/>
+			<xs:element name="last_update" type="xs:dateTime"/>
+			<xs:element name="job_status" type="tns:JobStatusType"/>
+			<xs:element name="cmd" type="xs:string"/>
+			<xs:element name="args1" type="xs:string" minOccurs="0"/>
+			<xs:element name="args2" type="xs:string" minOccurs="0"/>
+			<xs:element name="held" type="xs:string" minOccurs="0"/>
+			<xs:element name="released" type="xs:string" minOccurs="0"/>
+			<xs:element name="removed" type="xs:string" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+		<xs:complexType name="SubmissionSummary">
+		<xs:sequence>
+			<xs:element name="id" type="tns:SubmissionID"/>
+			<xs:element name="status" type="tns:Status"/>
+			<xs:element name="completed" type="xs:int"/>
+			<xs:element name="held" type="xs:int"/>
+			<xs:element name="idle" type="xs:int"/>
+			<xs:element name="removed" type="xs:int"/>
+			<xs:element name="running" type="xs:int"/>
+			<xs:element name="jobs" type="tns:JobSummary" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="JobDetails">
+		<xs:sequence>
+			<xs:element name="id" type="tns:JobID"/>
+			<xs:element name="status" type="tns:Status"/>
+			<xs:element name="details" type="tns:Attributes" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="JobDataType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="ERR"/>
+			<xs:enumeration value="LOG"/>
+			<xs:enumeration value="OUT"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="JobData">
+		<xs:sequence>
+			<xs:element name="id" type="tns:JobID"/>
+			<xs:element name="type" type="tns:JobDataType"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="ResourceType">
+		<xs:restriction base="xs:string">
+			<xs:enumeration value="COLLECTOR"/>
+			<xs:enumeration value="EXECUTOR"/>
+			<xs:enumeration value="EVENT_SERVER"/>
+			<xs:enumeration value="JOB_SERVER"/>
+			<xs:enumeration value="LOW_LATENCY"/>
+			<xs:enumeration value="MASTER"/>
+			<xs:enumeration value="NEGOTIATOR"/>
+			<xs:enumeration value="SCHEDULER"/>
+			<xs:enumeration value="CUSTOM"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="ResourceID">
+		<xs:sequence>
+			<xs:element name="subsystem_type" type="tns:ResourceType"/>
+			<xs:element name="pool" type="xs:string"/>
+			<xs:element name="name" type="xs:string"/>
+			<xs:element name="custom_name" type="xs:string" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+</xs:schema>
diff --git a/src/condor_contrib/aviary/etc/aviary-job.wsdl b/src/condor_contrib/aviary/etc/aviary-job.wsdl
new file mode 100644
index 0000000..c401778
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-job.wsdl
@@ -0,0 +1,130 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://grid.redhat.com/aviary-job/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:job="http://job.aviary.grid.redhat.com" xmlns:ns="http://common.aviary.grid.redhat.com" targetNamespace="http://grid.redhat.com/aviary-job/" name="aviary-job">
+	<wsdl:types>
+		<xsd:schema targetNamespace="http://grid.redhat.com/aviary-job/">
+			<xsd:import schemaLocation="aviary-job.xsd" namespace="http://job.aviary.grid.redhat.com"/>
+		</xsd:schema>
+	</wsdl:types>
+	<wsdl:message name="SubmitJobRequest">
+		<wsdl:part name="parameters" element="job:SubmitJob"/>
+	</wsdl:message>
+	<wsdl:message name="SubmitJobResponse">
+		<wsdl:part name="parameters" element="job:SubmitJobResponse"/>
+	</wsdl:message>
+	<wsdl:message name="HoldJobRequest">
+		<wsdl:part name="parameters" element="job:HoldJob"/>
+	</wsdl:message>
+	<wsdl:message name="HoldJobResponse">
+		<wsdl:part name="parameters" element="job:HoldJobResponse"/>
+	</wsdl:message>
+	<wsdl:message name="ReleaseJobRequest">
+		<wsdl:part name="parameters" element="job:ReleaseJob"/>
+	</wsdl:message>
+	<wsdl:message name="ReleaseJobResponse">
+		<wsdl:part name="parameters" element="job:ReleaseJobResponse"/>
+	</wsdl:message>
+	<wsdl:message name="RemoveJobRequest">
+		<wsdl:part name="parameters" element="job:RemoveJob"/>
+	</wsdl:message>
+	<wsdl:message name="RemoveJobResponse">
+		<wsdl:part name="parameters" element="job:RemoveJobResponse"/>
+	</wsdl:message>
+	<wsdl:message name="SetJobAttributeRequest">
+		<wsdl:part name="parameters" element="job:SetJobAttribute"/>
+	</wsdl:message>
+	<wsdl:message name="SetJobAttributeResponse">
+		<wsdl:part name="parameters" element="job:SetJobAttributeResponse"/>
+	</wsdl:message>
+	<wsdl:portType name="AviaryJob">
+		<wsdl:operation name="submitJob">
+			<wsdl:input message="tns:SubmitJobRequest"/>
+			<wsdl:output message="tns:SubmitJobResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="holdJob">
+			<wsdl:input message="tns:HoldJobRequest"/>
+			<wsdl:output message="tns:HoldJobResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="releaseJob">
+			<wsdl:input message="tns:ReleaseJobRequest"/>
+			<wsdl:output message="tns:ReleaseJobResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="removeJob">
+			<wsdl:input message="tns:RemoveJobRequest"/>
+			<wsdl:output message="tns:RemoveJobResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="setJobAttribute">
+			<wsdl:input message="tns:SetJobAttributeRequest"/>
+			<wsdl:output message="tns:SetJobAttributeResponse"/>
+		</wsdl:operation>
+	</wsdl:portType>
+	<wsdl:binding name="AviaryJobSOAPBinding" type="tns:AviaryJob">
+		<soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
+		<wsdl:operation name="submitJob">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/submit"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="holdJob">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/hold"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="releaseJob">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/release"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="removeJob">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/remove"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="setJobAttribute">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-job/set-attr"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+	</wsdl:binding>
+	<wsdl:service name="AviaryJobService">
+		<wsdl:port name="AviaryJobSOAPPort" binding="tns:AviaryJobSOAPBinding">
+			<soap:address location="http://localhost"/>
+		</wsdl:port>
+	</wsdl:service>
+</wsdl:definitions>
diff --git a/src/condor_contrib/aviary/etc/aviary-job.xsd b/src/condor_contrib/aviary/etc/aviary-job.xsd
new file mode 100644
index 0000000..d00b63b
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-job.xsd
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:job="http://job.aviary.grid.redhat.com" xmlns:mrg="http://common.aviary.grid.redhat.com" targetNamespace="http://job.aviary.grid.redhat.com">
+	<xs:import namespace="http://common.aviary.grid.redhat.com" schemaLocation="aviary-common.xsd"/>
+	<!-- declare message-level elements using anonymous complex types for simpler generated types -->
+	<xs:element name="SubmitJob">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="cmd" type="xs:string"/>
+				<xs:element name="args" type="xs:string" minOccurs="0"/>
+				<xs:element name="owner" type="xs:string"/>
+				<xs:element name="iwd" type="xs:string"/>
+				<xs:element name="submission_name" type="xs:string" minOccurs="0"/>
+				<xs:element name="requirements" type="mrg:ResourceConstraint"  minOccurs="0" maxOccurs="unbounded"/>
+				<xs:element name="extra" type="mrg:Attribute" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="allowOverrides" type="xs:boolean" default="false"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="SubmitJobResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="id" type="mrg:JobID" minOccurs="0"/>
+				<xs:element name="status" type="mrg:Status"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:complexType name="ControlJob">
+		<xs:sequence>
+			<xs:element name="id" type="mrg:JobID"/>
+			<xs:element name="reason" type="xs:string"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="ControlJobResponse">
+		<xs:sequence>
+			<xs:element name="status" type="mrg:Status"/>
+		</xs:sequence>
+	</xs:complexType>
+	<!-- these all follow the same type pattern so reuse -->
+	<xs:element name="HoldJob" type="job:ControlJob"/>
+	<xs:element name="HoldJobResponse" type="job:ControlJobResponse"/>
+	<xs:element name="ReleaseJob" type="job:ControlJob"/>
+	<xs:element name="ReleaseJobResponse" type="job:ControlJobResponse"/>
+	<xs:element name="RemoveJob" type="job:ControlJob"/>
+	<xs:element name="RemoveJobResponse" type="job:ControlJobResponse"/>
+	<xs:element name="SetJobAttribute">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="id" type="mrg:JobID"/>
+				<xs:element name="attribute" type="mrg:Attribute"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="SetJobAttributeResponse" type="job:ControlJobResponse"/>
+</xs:schema>
diff --git a/src/condor_contrib/aviary/etc/aviary-query.wsdl b/src/condor_contrib/aviary/etc/aviary-query.wsdl
new file mode 100644
index 0000000..3769e05
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-query.wsdl
@@ -0,0 +1,130 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://grid.redhat.com/aviary-query/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:qry="http://query.aviary.grid.redhat.com" xmlns:ns="http://common.aviary.grid.redhat.com" targetNamespace="http://grid.redhat.com/aviary-query/" name="aviary-query">
+	<wsdl:types>
+		<xsd:schema targetNamespace="http://grid.redhat.com/aviary-query/">
+			<xsd:import schemaLocation="aviary-query.xsd" namespace="http://query.aviary.grid.redhat.com"/>
+		</xsd:schema>
+	</wsdl:types>
+	<wsdl:message name="GetJobSummaryRequest">
+		<wsdl:part name="parameters" element="qry:GetJobSummary"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobSummaryResponse">
+		<wsdl:part name="parameters" element="qry:GetJobSummaryResponse"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobStatusRequest">
+		<wsdl:part name="parameters" element="qry:GetJobStatus"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobStatusResponse">
+		<wsdl:part name="parameters" element="qry:GetJobStatusResponse"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobDetailsRequest">
+		<wsdl:part name="parameters" element="qry:GetJobDetails"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobDetailsResponse">
+		<wsdl:part name="parameters" element="qry:GetJobDetailsResponse"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobDataRequest">
+		<wsdl:part name="parameters" element="qry:GetJobData"/>
+	</wsdl:message>
+	<wsdl:message name="GetJobDataResponse">
+		<wsdl:part name="parameters" element="qry:GetJobDataResponse"/>
+	</wsdl:message>
+	<wsdl:message name="GetSubmissionSummaryRequest">
+		<wsdl:part name="parameters" element="qry:GetSubmissionSummary"/>
+	</wsdl:message>
+	<wsdl:message name="GetSubmissionSummaryResponse">
+		<wsdl:part name="parameters" element="qry:GetSubmissionSummaryResponse"/>
+	</wsdl:message>
+	<wsdl:portType name="AviaryQuery">
+		<wsdl:operation name="getJobSummary">
+			<wsdl:input message="tns:GetJobSummaryRequest"/>
+			<wsdl:output message="tns:GetJobSummaryResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="getJobStatus">
+			<wsdl:input message="tns:GetJobStatusRequest"/>
+			<wsdl:output message="tns:GetJobStatusResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="getJobDetails">
+			<wsdl:input message="tns:GetJobDetailsRequest"/>
+			<wsdl:output message="tns:GetJobDetailsResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="getJobData">
+			<wsdl:input message="tns:GetJobDataRequest"/>
+			<wsdl:output message="tns:GetJobDataResponse"/>
+		</wsdl:operation>
+		<wsdl:operation name="getSubmissionSummary">
+			<wsdl:input message="tns:GetSubmissionSummaryRequest"/>
+			<wsdl:output message="tns:GetSubmissionSummaryResponse"/>
+		</wsdl:operation>
+	</wsdl:portType>
+	<wsdl:binding name="AviaryQuerySOAPBinding" type="tns:AviaryQuery">
+		<soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
+		<wsdl:operation name="getJobSummary">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/summary"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="getJobStatus">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/status"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="getJobDetails">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/details"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="getJobData">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/data"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+		<wsdl:operation name="getSubmissionSummary">
+			<soap:operation soapAction="http://grid.redhat.com/aviary-query/job/submission"/>
+			<wsdl:input>
+				<soap:body use="literal"/>
+			</wsdl:input>
+			<wsdl:output>
+				<soap:body use="literal"/>
+			</wsdl:output>
+		</wsdl:operation>
+	</wsdl:binding>
+	<wsdl:service name="AviaryQueryService">
+		<wsdl:port name="AviaryQuerySOAPPort" binding="tns:AviaryQuerySOAPBinding">
+			<soap:address location="http://localhost"/>
+		</wsdl:port>
+	</wsdl:service>
+</wsdl:definitions>
diff --git a/src/condor_contrib/aviary/etc/aviary-query.xsd b/src/condor_contrib/aviary/etc/aviary-query.xsd
new file mode 100644
index 0000000..a46ceb8
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/aviary-query.xsd
@@ -0,0 +1,106 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:qry="http://query.aviary.grid.redhat.com" xmlns:mrg="http://common.aviary.grid.redhat.com" targetNamespace="http://query.aviary.grid.redhat.com">
+	<xs:import namespace="http://common.aviary.grid.redhat.com" schemaLocation="aviary-common.xsd"/>
+
+	<!-- declare  message-level elements using anonymous complex types for simpler generated types -->
+	<!-- use of refs, inheritance into anonymous types, etc. eschewed for simplicity and interop -->
+	<xs:element name="GetJobSummary">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="ids" type="mrg:JobID" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="partialMatches" type="xs:boolean" default="true"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobSummaryResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="jobs" type="mrg:JobSummary" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobStatus">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="ids" type="mrg:JobID" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="partialMatches" type="xs:boolean" default="true"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobStatusResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="jobs" type="mrg:JobStatus" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobDetails">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="ids" type="mrg:JobID" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="partialMatches" type="xs:boolean" default="true"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobDetailsResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="jobs" type="mrg:JobDetails" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobData">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="data" type="mrg:JobData"/>
+				<xs:element name="max_bytes" type="xs:integer" default="1024"/>
+				<xs:element name="from_end" type="xs:boolean" minOccurs="0" default="false"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetJobDataResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="data" type="mrg:JobData"/>
+				<xs:element name="status" type="mrg:Status"/>
+				<xs:element name="file_name" type="xs:string" minOccurs="0"/>
+				<xs:element name="file_size" type="xs:integer" minOccurs="0"/>
+				<!-- string for file content...we probably want to keep line feeds, etc. TODO: need to revisit this-->
+				<xs:element name="content" type="xs:string" minOccurs="0"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetSubmissionSummary">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="ids" type="mrg:SubmissionID" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+			<xs:attribute name="partialMatches" type="xs:boolean" default="true"/>
+			<xs:attribute name="includeJobSummaries" type="xs:boolean" default="false"/>
+		</xs:complexType>
+	</xs:element>
+	<xs:element name="GetSubmissionSummaryResponse">
+		<xs:complexType>
+			<xs:sequence>
+				<xs:element name="submissions" type="mrg:SubmissionSummary" minOccurs="0" maxOccurs="unbounded"/>
+			</xs:sequence>
+		</xs:complexType>
+	</xs:element>
+</xs:schema>
diff --git a/src/condor_contrib/aviary/etc/axis2.xml.in b/src/condor_contrib/aviary/etc/axis2.xml.in
new file mode 100644
index 0000000..4e06bbd
--- /dev/null
+++ b/src/condor_contrib/aviary/etc/axis2.xml.in
@@ -0,0 +1,102 @@
+<!--
+/*
+ * Copyright 2000-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+
+<!-- Aviary-specific axis2.xml -->
+<axisconfig name="Axis2/C">
+	<!-- ================================================= -->
+	<!-- Parameters -->
+	<!-- ================================================= -->
+	<parameter name="libDir">@WS02_LIB_ROOT@</parameter>
+	<parameter name="servicesDir">/var/lib/condor/aviary/services</parameter>
+	<parameter name="enableREST" locked="false">true</parameter>
+	<parameter name="persistOperationContext" locked="false">true</parameter>
+
+	<!-- ================================================= -->
+	<!-- Transport Ins -->
+	<!-- ================================================= -->
+	<transportReceiver name="http" class="libaxis2_http_receiver.so.0">
+		<parameter name="port" locked="false">6060</parameter>
+	</transportReceiver>
+
+    <!-- applies to Axis2/C clients only -->
+	<transportReceiver name="https" class="libaxis2_http_receiver.so.0">
+		<parameter name="port" locked="false">6060</parameter>
+	</transportReceiver>
+	<!--transportReceiver name="tcp" class="axis2_tcp_receiver"-->
+	<!--parameter name="port" locked="false">6060</parameter-->
+	<!--/transportReceiver-->
+
+	<!-- ================================================= -->
+	<!-- Transport Outs -->
+	<!-- ================================================= -->
+
+	<transportSender name="http" class="libaxis2_http_sender.so.0">
+		<parameter name="PROTOCOL" locked="false">HTTP/1.1</parameter>
+		<parameter name="xml-declaration" insert="false"/>
+		<!--parameter name="Transfer-Encoding">chunked</parameter-->
+		<!--parameter name="PROXY" proxy_host="127.0.0.1" proxy_port="8080" locked="true"/-->
+	</transportSender>
+
+    <!-- applies to Axis2/C clients only -->
+	<transportSender name="https" class="libaxis2_http_sender.so.0">
+		<parameter name="PROTOCOL" locked="false">HTTP/1.1</parameter>
+		<parameter name="xml-declaration" insert="false"/>
+	</transportSender>
+
+	<!-- ================================================= -->
+	<!-- SSL  -->
+	<!-- ================================================= -->
+	<!-- NOTE: server-side SSL support currently unavailable for aviary components -->
+	<!-- alternatives include the use of a SSL-enabled proxy server such as squid; -->
+	<!-- the following settings would apply to Axis2/C clients only if enabled -->
+	<!-- set the server's SSL certificate here -->
+	<!--parameter name="SERVER_CERT">/path/to/ca/certificate</parameter-->
+	<!-- set the client's SSL key file and passphrase here for client auth -->
+	<!--parameter name="KEY_FILE">/path/to/client/certificate/chain/file</parameter-->
+	<!--parameter name="SSL_PASSPHRASE">passphrase</parameter-->
+
+	<!-- ================================================= -->
+	<!-- Phases  -->
+	<!-- ================================================= -->
+	<phaseOrder type="inflow">
+		<!-- System pre defined phases -->
+		<phase name="Transport"/>
+		<phase name="PreDispatch"/>
+		<phase name="Dispatch"/>
+		<phase name="PostDispatch"/>
+		<!-- End system pre defined phases -->
+		<!-- After PostDispatch phase, module or service author can add any phase as required  -->
+		<!-- User defined phases could be added here -->
+		<phase name="Security"/>
+		<phase name="Rahas"/>
+	</phaseOrder>
+	<phaseOrder type="outflow">
+		<!-- User defined phases could be added here -->
+		<phase name="MessageOut"/>
+		<phase name="Security"/>
+	</phaseOrder>
+	<phaseOrder type="INfaultflow">
+		<!-- User defined phases could be added here -->
+		<!--phase name="userphase1"/-->
+	</phaseOrder>
+	<phaseOrder type="Outfaultflow">
+		<!-- User defined phases could be added here -->
+		<!--phase name="userphase1"/-->
+		<phase name="MessageOut"/>
+	</phaseOrder>
+</axisconfig>
diff --git a/src/condor_contrib/aviary/gen-xsd-cpp.sh b/src/condor_contrib/aviary/gen-xsd-cpp.sh
new file mode 100755
index 0000000..2740157
--- /dev/null
+++ b/src/condor_contrib/aviary/gen-xsd-cpp.sh
@@ -0,0 +1,51 @@
+#!/bin/sh
+
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# codegen to provide WSDL/XSD CPP headers and source
+
+WSFCPP_HOME=/usr
+if [ -z "$1" ]; then
+    echo No arg - using default
+else
+    WSFCPP_HOME=$1
+fi
+echo WSFCPP_HOME=$WSFCPP_HOME
+
+# generate our cpp types from WSDL
+WSDL2CPP.sh -uri etc/aviary-job.wsdl -or -d adb -ss -g -ns2p http://common.aviary.grid.redhat.com=AviaryCommon,http://job.aviary.grid.redhat.com=AviaryJob -o codegen/job
+WSDL2CPP.sh -uri etc/aviary-query.wsdl -or -d adb -ss -g -ns2p http://common.aviary.grid.redhat.com=AviaryCommon,http://query.aviary.grid.redhat.com=AviaryQuery -o codegen/query
+
+# get rid of the extraneous stuff that WSDL2CPP won't let us turn off
+rm -f codegen/job/*AviaryJob*Service*.{h,cpp,vcproj}
+rm -f codegen/query/*AviaryQuery*Service*.{h,cpp,vcproj}
+
+# setup our include dir
+if ! test -d include; then
+    mkdir include;
+fi
+
+# stow the headers for others steps in the build 
+mv codegen/job/src/*.h include;
+mv codegen/query/src/*.h include;
+
+# WSDLCPP should do this for us but break out common
+if ! test -d codegen/common/src; then
+    mkdir -p codegen/common/src;
+fi
+mv codegen/query/src/AviaryCommon*.cpp codegen/common/src
+rm -f codegen/job/src/AviaryCommon*.cpp
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ArchType.h b/src/condor_contrib/aviary/include/AviaryCommon_ArchType.h
new file mode 100644
index 0000000..89aa5c2
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ArchType.h
@@ -0,0 +1,245 @@
+
+
+        #ifndef AviaryCommon_ARCHTYPE_H
+        #define AviaryCommon_ARCHTYPE_H
+
+       /**
+        * ArchType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ArchType class
+        */
+
+        namespace AviaryCommon{
+            class ArchType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            ArchType_INTEL,
+            ArchType_X86_64
+        } ADBArchTypeEnum;
+        
+        
+
+        class ArchType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_ArchType;
+
+                
+                bool isValidArchType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setArchTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ArchType
+         */
+
+        ArchType();
+
+        /**
+         * Destructor ArchType
+         */
+        ~ArchType();
+
+
+       
+
+        /**
+         * Constructor for creating ArchType
+         * @param 
+         * @param ArchType std::string
+         * @return newly created ArchType object
+         */
+        ArchType(std::string arg_ArchType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ArchType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getArchType();
+
+        /**
+         * Setter for ArchType.
+         * @param arg_ArchType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setArchType(const std::string  arg_ArchType);
+
+        /**
+         * Re setter for ArchType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetArchType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for ArchType.
+            * @return ADBArchTypeEnum; -1 on failure
+            */
+            ADBArchTypeEnum WSF_CALL
+            getArchTypeEnum();
+            
+            /**
+            * Enum setter for ArchType.
+            * @param arg_ArchType ADBArchTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setArchTypeEnum(
+            const ADBArchTypeEnum arg_ArchType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ArchType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isArchTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ArchType_om_node node to serialize from
+         * @param ArchType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ArchType_om_node, axiom_element_t *ArchType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ArchType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ArchType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* ARCHTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_Attribute.h b/src/condor_contrib/aviary/include/AviaryCommon_Attribute.h
new file mode 100644
index 0000000..1f47890
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_Attribute.h
@@ -0,0 +1,307 @@
+
+
+        #ifndef AviaryCommon_ATTRIBUTE_H
+        #define AviaryCommon_ATTRIBUTE_H
+
+       /**
+        * Attribute.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  Attribute class
+        */
+
+        namespace AviaryCommon{
+            class Attribute;
+        }
+        
+
+        
+       #include "AviaryCommon_AttributeType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class Attribute {
+
+        private:
+             std::string property_Name;
+
+                
+                bool isValidName;
+            AviaryCommon::AttributeType* property_Type;
+
+                
+                bool isValidType;
+            std::string property_Value;
+
+                
+                bool isValidValue;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setNameNil();
+            
+
+        bool WSF_CALL
+        setTypeNil();
+            
+
+        bool WSF_CALL
+        setValueNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class Attribute
+         */
+
+        Attribute();
+
+        /**
+         * Destructor Attribute
+         */
+        ~Attribute();
+
+
+       
+
+        /**
+         * Constructor for creating Attribute
+         * @param 
+         * @param Name std::string
+         * @param Type AviaryCommon::AttributeType*
+         * @param Value std::string
+         * @return newly created Attribute object
+         */
+        Attribute(std::string arg_Name,AviaryCommon::AttributeType* arg_Type,std::string arg_Value);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getName();
+
+        /**
+         * Setter for name.
+         * @param arg_Name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setName(const std::string  arg_Name);
+
+        /**
+         * Re setter for name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetName();
+        
+        
+
+        /**
+         * Getter for type. 
+         * @return AviaryCommon::AttributeType*
+         */
+        WSF_EXTERN AviaryCommon::AttributeType* WSF_CALL
+        getType();
+
+        /**
+         * Setter for type.
+         * @param arg_Type AviaryCommon::AttributeType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setType(AviaryCommon::AttributeType*  arg_Type);
+
+        /**
+         * Re setter for type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetType();
+        
+        
+
+        /**
+         * Getter for value. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getValue();
+
+        /**
+         * Setter for value.
+         * @param arg_Value std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setValue(const std::string  arg_Value);
+
+        /**
+         * Re setter for value
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetValue();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isNameNil();
+
+
+        
+
+        /**
+         * Check whether type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTypeNil();
+
+
+        
+
+        /**
+         * Check whether value is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isValueNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param Attribute_om_node node to serialize from
+         * @param Attribute_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* Attribute_om_node, axiom_element_t *Attribute_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the Attribute is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for name by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for type by property number (2)
+         * @return AviaryCommon::AttributeType
+         */
+
+        AviaryCommon::AttributeType* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for value by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* ATTRIBUTE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_AttributeType.h b/src/condor_contrib/aviary/include/AviaryCommon_AttributeType.h
new file mode 100644
index 0000000..34d7c36
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_AttributeType.h
@@ -0,0 +1,250 @@
+
+
+        #ifndef AviaryCommon_ATTRIBUTETYPE_H
+        #define AviaryCommon_ATTRIBUTETYPE_H
+
+       /**
+        * AttributeType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  AttributeType class
+        */
+
+        namespace AviaryCommon{
+            class AttributeType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            AttributeType_INTEGER,
+            AttributeType_FLOAT,
+            AttributeType_STRING,
+            AttributeType_EXPRESSION,
+            AttributeType_BOOLEAN,
+            AttributeType_UNDEFINED,
+            AttributeType_ERROR
+        } ADBAttributeTypeEnum;
+        
+        
+
+        class AttributeType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_AttributeType;
+
+                
+                bool isValidAttributeType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setAttributeTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class AttributeType
+         */
+
+        AttributeType();
+
+        /**
+         * Destructor AttributeType
+         */
+        ~AttributeType();
+
+
+       
+
+        /**
+         * Constructor for creating AttributeType
+         * @param 
+         * @param AttributeType std::string
+         * @return newly created AttributeType object
+         */
+        AttributeType(std::string arg_AttributeType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for AttributeType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getAttributeType();
+
+        /**
+         * Setter for AttributeType.
+         * @param arg_AttributeType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAttributeType(const std::string  arg_AttributeType);
+
+        /**
+         * Re setter for AttributeType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAttributeType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for AttributeType.
+            * @return ADBAttributeTypeEnum; -1 on failure
+            */
+            ADBAttributeTypeEnum WSF_CALL
+            getAttributeTypeEnum();
+            
+            /**
+            * Enum setter for AttributeType.
+            * @param arg_AttributeType ADBAttributeTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setAttributeTypeEnum(
+            const ADBAttributeTypeEnum arg_AttributeType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether AttributeType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAttributeTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param AttributeType_om_node node to serialize from
+         * @param AttributeType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* AttributeType_om_node, axiom_element_t *AttributeType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the AttributeType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for AttributeType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* ATTRIBUTETYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_Attributes.h b/src/condor_contrib/aviary/include/AviaryCommon_Attributes.h
new file mode 100644
index 0000000..d3c9823
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_Attributes.h
@@ -0,0 +1,296 @@
+
+
+        #ifndef AviaryCommon_ATTRIBUTES_H
+        #define AviaryCommon_ATTRIBUTES_H
+
+       /**
+        * Attributes.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  Attributes class
+        */
+
+        namespace AviaryCommon{
+            class Attributes;
+        }
+        
+
+        
+       #include "AviaryCommon_Attribute.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class Attributes {
+
+        private:
+             std::vector<AviaryCommon::Attribute*>* property_Attrs;
+
+                
+                bool isValidAttrs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setAttrsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class Attributes
+         */
+
+        Attributes();
+
+        /**
+         * Destructor Attributes
+         */
+        ~Attributes();
+
+
+       
+
+        /**
+         * Constructor for creating Attributes
+         * @param 
+         * @param Attrs std::vector<AviaryCommon::Attribute*>*
+         * @return newly created Attributes object
+         */
+        Attributes(std::vector<AviaryCommon::Attribute*>* arg_Attrs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for attrs. Deprecated for array types, Use getAttrsAt instead
+         * @return Array of AviaryCommon::Attribute*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::Attribute*>* WSF_CALL
+        getAttrs();
+
+        /**
+         * Setter for attrs.Deprecated for array types, Use setAttrsAt
+         * or addAttrs instead.
+         * @param arg_Attrs Array of AviaryCommon::Attribute*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAttrs(std::vector<AviaryCommon::Attribute*>*  arg_Attrs);
+
+        /**
+         * Re setter for attrs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAttrs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of attrs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::Attribute* of the array
+         */
+        WSF_EXTERN AviaryCommon::Attribute* WSF_CALL
+        getAttrsAt(int i);
+
+        /**
+         * Set the ith element of attrs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Attrs element to set AviaryCommon::Attribute* to the array
+         * @return ith AviaryCommon::Attribute* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAttrsAt(int i,
+                AviaryCommon::Attribute* arg_Attrs);
+
+
+        /**
+         * Add to attrs.
+         * @param arg_Attrs element to add AviaryCommon::Attribute* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addAttrs(
+            AviaryCommon::Attribute* arg_Attrs);
+
+        /**
+         * Get the size of the attrs array.
+         * @return the size of the attrs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofAttrs();
+
+        /**
+         * Remove the ith element of attrs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeAttrsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether attrs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAttrsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether attrs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isAttrsNilAt(int i);
+ 
+       
+        /**
+         * Set attrs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setAttrsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param Attributes_om_node node to serialize from
+         * @param Attributes_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* Attributes_om_node, axiom_element_t *Attributes_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the Attributes is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for attrs by property number (1)
+         * @return Array of AviaryCommon::Attributes.
+         */
+
+        std::vector<AviaryCommon::Attribute*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* ATTRIBUTES_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobConstraint.h b/src/condor_contrib/aviary/include/AviaryCommon_JobConstraint.h
new file mode 100644
index 0000000..80f3da0
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobConstraint.h
@@ -0,0 +1,253 @@
+
+
+        #ifndef AviaryCommon_JOBCONSTRAINT_H
+        #define AviaryCommon_JOBCONSTRAINT_H
+
+       /**
+        * JobConstraint.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobConstraint class
+        */
+
+        namespace AviaryCommon{
+            class JobConstraint;
+        }
+        
+
+        
+       #include "AviaryCommon_JobConstraintType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobConstraint {
+
+        private:
+             AviaryCommon::JobConstraintType* property_Type;
+
+                
+                bool isValidType;
+            std::string property_Value;
+
+                
+                bool isValidValue;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setTypeNil();
+            
+
+        bool WSF_CALL
+        setValueNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobConstraint
+         */
+
+        JobConstraint();
+
+        /**
+         * Destructor JobConstraint
+         */
+        ~JobConstraint();
+
+
+       
+
+        /**
+         * Constructor for creating JobConstraint
+         * @param 
+         * @param Type AviaryCommon::JobConstraintType*
+         * @param Value std::string
+         * @return newly created JobConstraint object
+         */
+        JobConstraint(AviaryCommon::JobConstraintType* arg_Type,std::string arg_Value);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for type. 
+         * @return AviaryCommon::JobConstraintType*
+         */
+        WSF_EXTERN AviaryCommon::JobConstraintType* WSF_CALL
+        getType();
+
+        /**
+         * Setter for type.
+         * @param arg_Type AviaryCommon::JobConstraintType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setType(AviaryCommon::JobConstraintType*  arg_Type);
+
+        /**
+         * Re setter for type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetType();
+        
+        
+
+        /**
+         * Getter for value. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getValue();
+
+        /**
+         * Setter for value.
+         * @param arg_Value std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setValue(const std::string  arg_Value);
+
+        /**
+         * Re setter for value
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetValue();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTypeNil();
+
+
+        
+
+        /**
+         * Check whether value is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isValueNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobConstraint_om_node node to serialize from
+         * @param JobConstraint_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobConstraint_om_node, axiom_element_t *JobConstraint_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobConstraint is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for type by property number (1)
+         * @return AviaryCommon::JobConstraintType
+         */
+
+        AviaryCommon::JobConstraintType* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for value by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* JOBCONSTRAINT_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobConstraintType.h b/src/condor_contrib/aviary/include/AviaryCommon_JobConstraintType.h
new file mode 100644
index 0000000..032c481
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobConstraintType.h
@@ -0,0 +1,246 @@
+
+
+        #ifndef AviaryCommon_JOBCONSTRAINTTYPE_H
+        #define AviaryCommon_JOBCONSTRAINTTYPE_H
+
+       /**
+        * JobConstraintType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobConstraintType class
+        */
+
+        namespace AviaryCommon{
+            class JobConstraintType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            JobConstraintType_CMD,
+            JobConstraintType_ARGS,
+            JobConstraintType_OWNER
+        } ADBJobConstraintTypeEnum;
+        
+        
+
+        class JobConstraintType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_JobConstraintType;
+
+                
+                bool isValidJobConstraintType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobConstraintTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobConstraintType
+         */
+
+        JobConstraintType();
+
+        /**
+         * Destructor JobConstraintType
+         */
+        ~JobConstraintType();
+
+
+       
+
+        /**
+         * Constructor for creating JobConstraintType
+         * @param 
+         * @param JobConstraintType std::string
+         * @return newly created JobConstraintType object
+         */
+        JobConstraintType(std::string arg_JobConstraintType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for JobConstraintType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getJobConstraintType();
+
+        /**
+         * Setter for JobConstraintType.
+         * @param arg_JobConstraintType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobConstraintType(const std::string  arg_JobConstraintType);
+
+        /**
+         * Re setter for JobConstraintType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobConstraintType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for JobConstraintType.
+            * @return ADBJobConstraintTypeEnum; -1 on failure
+            */
+            ADBJobConstraintTypeEnum WSF_CALL
+            getJobConstraintTypeEnum();
+            
+            /**
+            * Enum setter for JobConstraintType.
+            * @param arg_JobConstraintType ADBJobConstraintTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setJobConstraintTypeEnum(
+            const ADBJobConstraintTypeEnum arg_JobConstraintType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether JobConstraintType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobConstraintTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobConstraintType_om_node node to serialize from
+         * @param JobConstraintType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobConstraintType_om_node, axiom_element_t *JobConstraintType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobConstraintType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for JobConstraintType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* JOBCONSTRAINTTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobData.h b/src/condor_contrib/aviary/include/AviaryCommon_JobData.h
new file mode 100644
index 0000000..970bc6c
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobData.h
@@ -0,0 +1,255 @@
+
+
+        #ifndef AviaryCommon_JOBDATA_H
+        #define AviaryCommon_JOBDATA_H
+
+       /**
+        * JobData.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobData class
+        */
+
+        namespace AviaryCommon{
+            class JobData;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_JobDataType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobData {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::JobDataType* property_Type;
+
+                
+                bool isValidType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobData
+         */
+
+        JobData();
+
+        /**
+         * Destructor JobData
+         */
+        ~JobData();
+
+
+       
+
+        /**
+         * Constructor for creating JobData
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Type AviaryCommon::JobDataType*
+         * @return newly created JobData object
+         */
+        JobData(AviaryCommon::JobID* arg_Id,AviaryCommon::JobDataType* arg_Type);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for type. 
+         * @return AviaryCommon::JobDataType*
+         */
+        WSF_EXTERN AviaryCommon::JobDataType* WSF_CALL
+        getType();
+
+        /**
+         * Setter for type.
+         * @param arg_Type AviaryCommon::JobDataType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setType(AviaryCommon::JobDataType*  arg_Type);
+
+        /**
+         * Re setter for type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetType();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobData_om_node node to serialize from
+         * @param JobData_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobData_om_node, axiom_element_t *JobData_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobData is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for type by property number (2)
+         * @return AviaryCommon::JobDataType
+         */
+
+        AviaryCommon::JobDataType* WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* JOBDATA_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobDataType.h b/src/condor_contrib/aviary/include/AviaryCommon_JobDataType.h
new file mode 100644
index 0000000..94e2873
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobDataType.h
@@ -0,0 +1,246 @@
+
+
+        #ifndef AviaryCommon_JOBDATATYPE_H
+        #define AviaryCommon_JOBDATATYPE_H
+
+       /**
+        * JobDataType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobDataType class
+        */
+
+        namespace AviaryCommon{
+            class JobDataType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            JobDataType_ERR,
+            JobDataType_LOG,
+            JobDataType_OUT
+        } ADBJobDataTypeEnum;
+        
+        
+
+        class JobDataType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_JobDataType;
+
+                
+                bool isValidJobDataType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobDataTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobDataType
+         */
+
+        JobDataType();
+
+        /**
+         * Destructor JobDataType
+         */
+        ~JobDataType();
+
+
+       
+
+        /**
+         * Constructor for creating JobDataType
+         * @param 
+         * @param JobDataType std::string
+         * @return newly created JobDataType object
+         */
+        JobDataType(std::string arg_JobDataType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for JobDataType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getJobDataType();
+
+        /**
+         * Setter for JobDataType.
+         * @param arg_JobDataType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobDataType(const std::string  arg_JobDataType);
+
+        /**
+         * Re setter for JobDataType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobDataType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for JobDataType.
+            * @return ADBJobDataTypeEnum; -1 on failure
+            */
+            ADBJobDataTypeEnum WSF_CALL
+            getJobDataTypeEnum();
+            
+            /**
+            * Enum setter for JobDataType.
+            * @param arg_JobDataType ADBJobDataTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setJobDataTypeEnum(
+            const ADBJobDataTypeEnum arg_JobDataType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether JobDataType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobDataTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobDataType_om_node node to serialize from
+         * @param JobDataType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobDataType_om_node, axiom_element_t *JobDataType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobDataType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for JobDataType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* JOBDATATYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobDetails.h b/src/condor_contrib/aviary/include/AviaryCommon_JobDetails.h
new file mode 100644
index 0000000..6012bdb
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobDetails.h
@@ -0,0 +1,311 @@
+
+
+        #ifndef AviaryCommon_JOBDETAILS_H
+        #define AviaryCommon_JOBDETAILS_H
+
+       /**
+        * JobDetails.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobDetails class
+        */
+
+        namespace AviaryCommon{
+            class JobDetails;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+       #include "AviaryCommon_Attributes.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobDetails {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            AviaryCommon::Attributes* property_Details;
+
+                
+                bool isValidDetails;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setDetailsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobDetails
+         */
+
+        JobDetails();
+
+        /**
+         * Destructor JobDetails
+         */
+        ~JobDetails();
+
+
+       
+
+        /**
+         * Constructor for creating JobDetails
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Status AviaryCommon::Status*
+         * @param Details AviaryCommon::Attributes*
+         * @return newly created JobDetails object
+         */
+        JobDetails(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,AviaryCommon::Attributes* arg_Details);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for details. 
+         * @return AviaryCommon::Attributes*
+         */
+        WSF_EXTERN AviaryCommon::Attributes* WSF_CALL
+        getDetails();
+
+        /**
+         * Setter for details.
+         * @param arg_Details AviaryCommon::Attributes*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setDetails(AviaryCommon::Attributes*  arg_Details);
+
+        /**
+         * Re setter for details
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetDetails();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether details is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isDetailsNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobDetails_om_node node to serialize from
+         * @param JobDetails_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobDetails_om_node, axiom_element_t *JobDetails_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobDetails is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for details by property number (3)
+         * @return AviaryCommon::Attributes
+         */
+
+        AviaryCommon::Attributes* WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* JOBDETAILS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobID.h b/src/condor_contrib/aviary/include/AviaryCommon_JobID.h
new file mode 100644
index 0000000..4c62c81
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobID.h
@@ -0,0 +1,361 @@
+
+
+        #ifndef AviaryCommon_JOBID_H
+        #define AviaryCommon_JOBID_H
+
+       /**
+        * JobID.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobID class
+        */
+
+        namespace AviaryCommon{
+            class JobID;
+        }
+        
+
+        
+       #include "AviaryCommon_SubmissionID.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobID {
+
+        private:
+             std::string property_Job;
+
+                
+                bool isValidJob;
+            std::string property_Pool;
+
+                
+                bool isValidPool;
+            std::string property_Scheduler;
+
+                
+                bool isValidScheduler;
+            AviaryCommon::SubmissionID* property_Submission;
+
+                
+                bool isValidSubmission;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobNil();
+            
+
+        bool WSF_CALL
+        setPoolNil();
+            
+
+        bool WSF_CALL
+        setSchedulerNil();
+            
+
+        bool WSF_CALL
+        setSubmissionNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobID
+         */
+
+        JobID();
+
+        /**
+         * Destructor JobID
+         */
+        ~JobID();
+
+
+       
+
+        /**
+         * Constructor for creating JobID
+         * @param 
+         * @param Job std::string
+         * @param Pool std::string
+         * @param Scheduler std::string
+         * @param Submission AviaryCommon::SubmissionID*
+         * @return newly created JobID object
+         */
+        JobID(std::string arg_Job,std::string arg_Pool,std::string arg_Scheduler,AviaryCommon::SubmissionID* arg_Submission);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for job. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getJob();
+
+        /**
+         * Setter for job.
+         * @param arg_Job std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJob(const std::string  arg_Job);
+
+        /**
+         * Re setter for job
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJob();
+        
+        
+
+        /**
+         * Getter for pool. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getPool();
+
+        /**
+         * Setter for pool.
+         * @param arg_Pool std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPool(const std::string  arg_Pool);
+
+        /**
+         * Re setter for pool
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPool();
+        
+        
+
+        /**
+         * Getter for scheduler. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getScheduler();
+
+        /**
+         * Setter for scheduler.
+         * @param arg_Scheduler std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setScheduler(const std::string  arg_Scheduler);
+
+        /**
+         * Re setter for scheduler
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetScheduler();
+        
+        
+
+        /**
+         * Getter for submission. 
+         * @return AviaryCommon::SubmissionID*
+         */
+        WSF_EXTERN AviaryCommon::SubmissionID* WSF_CALL
+        getSubmission();
+
+        /**
+         * Setter for submission.
+         * @param arg_Submission AviaryCommon::SubmissionID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubmission(AviaryCommon::SubmissionID*  arg_Submission);
+
+        /**
+         * Re setter for submission
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSubmission();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether job is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobNil();
+
+
+        
+
+        /**
+         * Check whether pool is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPoolNil();
+
+
+        
+
+        /**
+         * Check whether scheduler is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSchedulerNil();
+
+
+        
+
+        /**
+         * Check whether submission is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSubmissionNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobID_om_node node to serialize from
+         * @param JobID_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobID_om_node, axiom_element_t *JobID_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobID is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for job by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for pool by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for scheduler by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for submission by property number (4)
+         * @return AviaryCommon::SubmissionID
+         */
+
+        AviaryCommon::SubmissionID* WSF_CALL
+        getProperty4();
+
+    
+
+};
+
+}        
+ #endif /* JOBID_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobStatus.h b/src/condor_contrib/aviary/include/AviaryCommon_JobStatus.h
new file mode 100644
index 0000000..999d200
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobStatus.h
@@ -0,0 +1,311 @@
+
+
+        #ifndef AviaryCommon_JOBSTATUS_H
+        #define AviaryCommon_JOBSTATUS_H
+
+       /**
+        * JobStatus.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobStatus class
+        */
+
+        namespace AviaryCommon{
+            class JobStatus;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+       #include "AviaryCommon_JobStatusType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobStatus {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            AviaryCommon::JobStatusType* property_Job_status;
+
+                
+                bool isValidJob_status;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setJob_statusNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobStatus
+         */
+
+        JobStatus();
+
+        /**
+         * Destructor JobStatus
+         */
+        ~JobStatus();
+
+
+       
+
+        /**
+         * Constructor for creating JobStatus
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Status AviaryCommon::Status*
+         * @param Job_status AviaryCommon::JobStatusType*
+         * @return newly created JobStatus object
+         */
+        JobStatus(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,AviaryCommon::JobStatusType* arg_Job_status);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for job_status. 
+         * @return AviaryCommon::JobStatusType*
+         */
+        WSF_EXTERN AviaryCommon::JobStatusType* WSF_CALL
+        getJob_status();
+
+        /**
+         * Setter for job_status.
+         * @param arg_Job_status AviaryCommon::JobStatusType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJob_status(AviaryCommon::JobStatusType*  arg_Job_status);
+
+        /**
+         * Re setter for job_status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJob_status();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether job_status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJob_statusNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobStatus_om_node node to serialize from
+         * @param JobStatus_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobStatus_om_node, axiom_element_t *JobStatus_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobStatus is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for job_status by property number (3)
+         * @return AviaryCommon::JobStatusType
+         */
+
+        AviaryCommon::JobStatusType* WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* JOBSTATUS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobStatusType.h b/src/condor_contrib/aviary/include/AviaryCommon_JobStatusType.h
new file mode 100644
index 0000000..076191a
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobStatusType.h
@@ -0,0 +1,248 @@
+
+
+        #ifndef AviaryCommon_JOBSTATUSTYPE_H
+        #define AviaryCommon_JOBSTATUSTYPE_H
+
+       /**
+        * JobStatusType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobStatusType class
+        */
+
+        namespace AviaryCommon{
+            class JobStatusType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            JobStatusType_IDLE,
+            JobStatusType_RUNNING,
+            JobStatusType_REMOVED,
+            JobStatusType_COMPLETED,
+            JobStatusType_HELD
+        } ADBJobStatusTypeEnum;
+        
+        
+
+        class JobStatusType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_JobStatusType;
+
+                
+                bool isValidJobStatusType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobStatusTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobStatusType
+         */
+
+        JobStatusType();
+
+        /**
+         * Destructor JobStatusType
+         */
+        ~JobStatusType();
+
+
+       
+
+        /**
+         * Constructor for creating JobStatusType
+         * @param 
+         * @param JobStatusType std::string
+         * @return newly created JobStatusType object
+         */
+        JobStatusType(std::string arg_JobStatusType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for JobStatusType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getJobStatusType();
+
+        /**
+         * Setter for JobStatusType.
+         * @param arg_JobStatusType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobStatusType(const std::string  arg_JobStatusType);
+
+        /**
+         * Re setter for JobStatusType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobStatusType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for JobStatusType.
+            * @return ADBJobStatusTypeEnum; -1 on failure
+            */
+            ADBJobStatusTypeEnum WSF_CALL
+            getJobStatusTypeEnum();
+            
+            /**
+            * Enum setter for JobStatusType.
+            * @param arg_JobStatusType ADBJobStatusTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setJobStatusTypeEnum(
+            const ADBJobStatusTypeEnum arg_JobStatusType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether JobStatusType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobStatusTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobStatusType_om_node node to serialize from
+         * @param JobStatusType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobStatusType_om_node, axiom_element_t *JobStatusType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobStatusType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for JobStatusType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* JOBSTATUSTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_JobSummary.h b/src/condor_contrib/aviary/include/AviaryCommon_JobSummary.h
new file mode 100644
index 0000000..b6128a6
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_JobSummary.h
@@ -0,0 +1,745 @@
+
+
+        #ifndef AviaryCommon_JOBSUMMARY_H
+        #define AviaryCommon_JOBSUMMARY_H
+
+       /**
+        * JobSummary.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  JobSummary class
+        */
+
+        namespace AviaryCommon{
+            class JobSummary;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+       #include "AviaryCommon_JobStatusType.h"
+          
+        #include <axutil_date_time.h>
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class JobSummary {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            axutil_date_time_t* property_Queued;
+
+                
+                bool isValidQueued;
+            axutil_date_time_t* property_Last_update;
+
+                
+                bool isValidLast_update;
+            AviaryCommon::JobStatusType* property_Job_status;
+
+                
+                bool isValidJob_status;
+            std::string property_Cmd;
+
+                
+                bool isValidCmd;
+            std::string property_Args1;
+
+                
+                bool isValidArgs1;
+            std::string property_Args2;
+
+                
+                bool isValidArgs2;
+            std::string property_Held;
+
+                
+                bool isValidHeld;
+            std::string property_Released;
+
+                
+                bool isValidReleased;
+            std::string property_Removed;
+
+                
+                bool isValidRemoved;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setQueuedNil();
+            
+
+        bool WSF_CALL
+        setLast_updateNil();
+            
+
+        bool WSF_CALL
+        setJob_statusNil();
+            
+
+        bool WSF_CALL
+        setCmdNil();
+            
+
+        bool WSF_CALL
+        setArgs1Nil();
+            
+
+        bool WSF_CALL
+        setArgs2Nil();
+            
+
+        bool WSF_CALL
+        setHeldNil();
+            
+
+        bool WSF_CALL
+        setReleasedNil();
+            
+
+        bool WSF_CALL
+        setRemovedNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class JobSummary
+         */
+
+        JobSummary();
+
+        /**
+         * Destructor JobSummary
+         */
+        ~JobSummary();
+
+
+       
+
+        /**
+         * Constructor for creating JobSummary
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Status AviaryCommon::Status*
+         * @param Queued axutil_date_time_t*
+         * @param Last_update axutil_date_time_t*
+         * @param Job_status AviaryCommon::JobStatusType*
+         * @param Cmd std::string
+         * @param Args1 std::string
+         * @param Args2 std::string
+         * @param Held std::string
+         * @param Released std::string
+         * @param Removed std::string
+         * @return newly created JobSummary object
+         */
+        JobSummary(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status,axutil_date_time_t* arg_Queued,axutil_date_time_t* arg_Last_update,AviaryCommon::JobStatusType* arg_Job_status,std::string arg_Cmd,std::string arg_Args1,std::string arg_Args2,std::string arg_Held,std::string arg_Released,std::string arg_Removed);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for queued. 
+         * @return axutil_date_time_t*
+         */
+        WSF_EXTERN axutil_date_time_t* WSF_CALL
+        getQueued();
+
+        /**
+         * Setter for queued.
+         * @param arg_Queued axutil_date_time_t*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setQueued(axutil_date_time_t*  arg_Queued);
+
+        /**
+         * Re setter for queued
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetQueued();
+        
+        
+
+        /**
+         * Getter for last_update. 
+         * @return axutil_date_time_t*
+         */
+        WSF_EXTERN axutil_date_time_t* WSF_CALL
+        getLast_update();
+
+        /**
+         * Setter for last_update.
+         * @param arg_Last_update axutil_date_time_t*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setLast_update(axutil_date_time_t*  arg_Last_update);
+
+        /**
+         * Re setter for last_update
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetLast_update();
+        
+        
+
+        /**
+         * Getter for job_status. 
+         * @return AviaryCommon::JobStatusType*
+         */
+        WSF_EXTERN AviaryCommon::JobStatusType* WSF_CALL
+        getJob_status();
+
+        /**
+         * Setter for job_status.
+         * @param arg_Job_status AviaryCommon::JobStatusType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJob_status(AviaryCommon::JobStatusType*  arg_Job_status);
+
+        /**
+         * Re setter for job_status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJob_status();
+        
+        
+
+        /**
+         * Getter for cmd. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getCmd();
+
+        /**
+         * Setter for cmd.
+         * @param arg_Cmd std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCmd(const std::string  arg_Cmd);
+
+        /**
+         * Re setter for cmd
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCmd();
+        
+        
+
+        /**
+         * Getter for args1. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getArgs1();
+
+        /**
+         * Setter for args1.
+         * @param arg_Args1 std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setArgs1(const std::string  arg_Args1);
+
+        /**
+         * Re setter for args1
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetArgs1();
+        
+        
+
+        /**
+         * Getter for args2. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getArgs2();
+
+        /**
+         * Setter for args2.
+         * @param arg_Args2 std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setArgs2(const std::string  arg_Args2);
+
+        /**
+         * Re setter for args2
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetArgs2();
+        
+        
+
+        /**
+         * Getter for held. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getHeld();
+
+        /**
+         * Setter for held.
+         * @param arg_Held std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setHeld(const std::string  arg_Held);
+
+        /**
+         * Re setter for held
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetHeld();
+        
+        
+
+        /**
+         * Getter for released. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getReleased();
+
+        /**
+         * Setter for released.
+         * @param arg_Released std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setReleased(const std::string  arg_Released);
+
+        /**
+         * Re setter for released
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetReleased();
+        
+        
+
+        /**
+         * Getter for removed. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getRemoved();
+
+        /**
+         * Setter for removed.
+         * @param arg_Removed std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRemoved(const std::string  arg_Removed);
+
+        /**
+         * Re setter for removed
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRemoved();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether queued is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isQueuedNil();
+
+
+        
+
+        /**
+         * Check whether last_update is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isLast_updateNil();
+
+
+        
+
+        /**
+         * Check whether job_status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJob_statusNil();
+
+
+        
+
+        /**
+         * Check whether cmd is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCmdNil();
+
+
+        
+
+        /**
+         * Check whether args1 is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isArgs1Nil();
+
+
+        
+
+        /**
+         * Check whether args2 is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isArgs2Nil();
+
+
+        
+
+        /**
+         * Check whether held is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isHeldNil();
+
+
+        
+
+        /**
+         * Check whether released is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isReleasedNil();
+
+
+        
+
+        /**
+         * Check whether removed is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRemovedNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param JobSummary_om_node node to serialize from
+         * @param JobSummary_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* JobSummary_om_node, axiom_element_t *JobSummary_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the JobSummary is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for queued by property number (3)
+         * @return axutil_date_time_t*
+         */
+
+        axutil_date_time_t* WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for last_update by property number (4)
+         * @return axutil_date_time_t*
+         */
+
+        axutil_date_time_t* WSF_CALL
+        getProperty4();
+
+    
+        
+
+        /**
+         * Getter for job_status by property number (5)
+         * @return AviaryCommon::JobStatusType
+         */
+
+        AviaryCommon::JobStatusType* WSF_CALL
+        getProperty5();
+
+    
+        
+
+        /**
+         * Getter for cmd by property number (6)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty6();
+
+    
+        
+
+        /**
+         * Getter for args1 by property number (7)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty7();
+
+    
+        
+
+        /**
+         * Getter for args2 by property number (8)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty8();
+
+    
+        
+
+        /**
+         * Getter for held by property number (9)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty9();
+
+    
+        
+
+        /**
+         * Getter for released by property number (10)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty10();
+
+    
+        
+
+        /**
+         * Getter for removed by property number (11)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty11();
+
+    
+
+};
+
+}        
+ #endif /* JOBSUMMARY_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_OSType.h b/src/condor_contrib/aviary/include/AviaryCommon_OSType.h
new file mode 100644
index 0000000..3322a71
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_OSType.h
@@ -0,0 +1,245 @@
+
+
+        #ifndef AviaryCommon_OSTYPE_H
+        #define AviaryCommon_OSTYPE_H
+
+       /**
+        * OSType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  OSType class
+        */
+
+        namespace AviaryCommon{
+            class OSType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            OSType_LINUX,
+            OSType_WINDOWS
+        } ADBOSTypeEnum;
+        
+        
+
+        class OSType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_OSType;
+
+                
+                bool isValidOSType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setOSTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class OSType
+         */
+
+        OSType();
+
+        /**
+         * Destructor OSType
+         */
+        ~OSType();
+
+
+       
+
+        /**
+         * Constructor for creating OSType
+         * @param 
+         * @param OSType std::string
+         * @return newly created OSType object
+         */
+        OSType(std::string arg_OSType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for OSType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getOSType();
+
+        /**
+         * Setter for OSType.
+         * @param arg_OSType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setOSType(const std::string  arg_OSType);
+
+        /**
+         * Re setter for OSType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetOSType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for OSType.
+            * @return ADBOSTypeEnum; -1 on failure
+            */
+            ADBOSTypeEnum WSF_CALL
+            getOSTypeEnum();
+            
+            /**
+            * Enum setter for OSType.
+            * @param arg_OSType ADBOSTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setOSTypeEnum(
+            const ADBOSTypeEnum arg_OSType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether OSType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isOSTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param OSType_om_node node to serialize from
+         * @param OSType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* OSType_om_node, axiom_element_t *OSType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the OSType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for OSType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* OSTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraint.h b/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraint.h
new file mode 100644
index 0000000..12557d8
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraint.h
@@ -0,0 +1,253 @@
+
+
+        #ifndef AviaryCommon_RESOURCECONSTRAINT_H
+        #define AviaryCommon_RESOURCECONSTRAINT_H
+
+       /**
+        * ResourceConstraint.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ResourceConstraint class
+        */
+
+        namespace AviaryCommon{
+            class ResourceConstraint;
+        }
+        
+
+        
+       #include "AviaryCommon_ResourceConstraintType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class ResourceConstraint {
+
+        private:
+             AviaryCommon::ResourceConstraintType* property_Type;
+
+                
+                bool isValidType;
+            std::string property_Value;
+
+                
+                bool isValidValue;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setTypeNil();
+            
+
+        bool WSF_CALL
+        setValueNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ResourceConstraint
+         */
+
+        ResourceConstraint();
+
+        /**
+         * Destructor ResourceConstraint
+         */
+        ~ResourceConstraint();
+
+
+       
+
+        /**
+         * Constructor for creating ResourceConstraint
+         * @param 
+         * @param Type AviaryCommon::ResourceConstraintType*
+         * @param Value std::string
+         * @return newly created ResourceConstraint object
+         */
+        ResourceConstraint(AviaryCommon::ResourceConstraintType* arg_Type,std::string arg_Value);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for type. 
+         * @return AviaryCommon::ResourceConstraintType*
+         */
+        WSF_EXTERN AviaryCommon::ResourceConstraintType* WSF_CALL
+        getType();
+
+        /**
+         * Setter for type.
+         * @param arg_Type AviaryCommon::ResourceConstraintType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setType(AviaryCommon::ResourceConstraintType*  arg_Type);
+
+        /**
+         * Re setter for type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetType();
+        
+        
+
+        /**
+         * Getter for value. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getValue();
+
+        /**
+         * Setter for value.
+         * @param arg_Value std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setValue(const std::string  arg_Value);
+
+        /**
+         * Re setter for value
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetValue();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTypeNil();
+
+
+        
+
+        /**
+         * Check whether value is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isValueNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ResourceConstraint_om_node node to serialize from
+         * @param ResourceConstraint_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ResourceConstraint_om_node, axiom_element_t *ResourceConstraint_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ResourceConstraint is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for type by property number (1)
+         * @return AviaryCommon::ResourceConstraintType
+         */
+
+        AviaryCommon::ResourceConstraintType* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for value by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* RESOURCECONSTRAINT_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraintType.h b/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraintType.h
new file mode 100644
index 0000000..1b90eb1
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ResourceConstraintType.h
@@ -0,0 +1,248 @@
+
+
+        #ifndef AviaryCommon_RESOURCECONSTRAINTTYPE_H
+        #define AviaryCommon_RESOURCECONSTRAINTTYPE_H
+
+       /**
+        * ResourceConstraintType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ResourceConstraintType class
+        */
+
+        namespace AviaryCommon{
+            class ResourceConstraintType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            ResourceConstraintType_OS,
+            ResourceConstraintType_ARCH,
+            ResourceConstraintType_MEMORY,
+            ResourceConstraintType_DISK,
+            ResourceConstraintType_FILESYSTEM
+        } ADBResourceConstraintTypeEnum;
+        
+        
+
+        class ResourceConstraintType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_ResourceConstraintType;
+
+                
+                bool isValidResourceConstraintType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setResourceConstraintTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ResourceConstraintType
+         */
+
+        ResourceConstraintType();
+
+        /**
+         * Destructor ResourceConstraintType
+         */
+        ~ResourceConstraintType();
+
+
+       
+
+        /**
+         * Constructor for creating ResourceConstraintType
+         * @param 
+         * @param ResourceConstraintType std::string
+         * @return newly created ResourceConstraintType object
+         */
+        ResourceConstraintType(std::string arg_ResourceConstraintType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ResourceConstraintType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getResourceConstraintType();
+
+        /**
+         * Setter for ResourceConstraintType.
+         * @param arg_ResourceConstraintType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setResourceConstraintType(const std::string  arg_ResourceConstraintType);
+
+        /**
+         * Re setter for ResourceConstraintType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetResourceConstraintType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for ResourceConstraintType.
+            * @return ADBResourceConstraintTypeEnum; -1 on failure
+            */
+            ADBResourceConstraintTypeEnum WSF_CALL
+            getResourceConstraintTypeEnum();
+            
+            /**
+            * Enum setter for ResourceConstraintType.
+            * @param arg_ResourceConstraintType ADBResourceConstraintTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setResourceConstraintTypeEnum(
+            const ADBResourceConstraintTypeEnum arg_ResourceConstraintType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ResourceConstraintType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isResourceConstraintTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ResourceConstraintType_om_node node to serialize from
+         * @param ResourceConstraintType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ResourceConstraintType_om_node, axiom_element_t *ResourceConstraintType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ResourceConstraintType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ResourceConstraintType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* RESOURCECONSTRAINTTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ResourceID.h b/src/condor_contrib/aviary/include/AviaryCommon_ResourceID.h
new file mode 100644
index 0000000..c900d7b
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ResourceID.h
@@ -0,0 +1,361 @@
+
+
+        #ifndef AviaryCommon_RESOURCEID_H
+        #define AviaryCommon_RESOURCEID_H
+
+       /**
+        * ResourceID.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ResourceID class
+        */
+
+        namespace AviaryCommon{
+            class ResourceID;
+        }
+        
+
+        
+       #include "AviaryCommon_ResourceType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class ResourceID {
+
+        private:
+             AviaryCommon::ResourceType* property_Subsystem_type;
+
+                
+                bool isValidSubsystem_type;
+            std::string property_Pool;
+
+                
+                bool isValidPool;
+            std::string property_Name;
+
+                
+                bool isValidName;
+            std::string property_Custom_name;
+
+                
+                bool isValidCustom_name;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setSubsystem_typeNil();
+            
+
+        bool WSF_CALL
+        setPoolNil();
+            
+
+        bool WSF_CALL
+        setNameNil();
+            
+
+        bool WSF_CALL
+        setCustom_nameNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ResourceID
+         */
+
+        ResourceID();
+
+        /**
+         * Destructor ResourceID
+         */
+        ~ResourceID();
+
+
+       
+
+        /**
+         * Constructor for creating ResourceID
+         * @param 
+         * @param Subsystem_type AviaryCommon::ResourceType*
+         * @param Pool std::string
+         * @param Name std::string
+         * @param Custom_name std::string
+         * @return newly created ResourceID object
+         */
+        ResourceID(AviaryCommon::ResourceType* arg_Subsystem_type,std::string arg_Pool,std::string arg_Name,std::string arg_Custom_name);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for subsystem_type. 
+         * @return AviaryCommon::ResourceType*
+         */
+        WSF_EXTERN AviaryCommon::ResourceType* WSF_CALL
+        getSubsystem_type();
+
+        /**
+         * Setter for subsystem_type.
+         * @param arg_Subsystem_type AviaryCommon::ResourceType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubsystem_type(AviaryCommon::ResourceType*  arg_Subsystem_type);
+
+        /**
+         * Re setter for subsystem_type
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSubsystem_type();
+        
+        
+
+        /**
+         * Getter for pool. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getPool();
+
+        /**
+         * Setter for pool.
+         * @param arg_Pool std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPool(const std::string  arg_Pool);
+
+        /**
+         * Re setter for pool
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPool();
+        
+        
+
+        /**
+         * Getter for name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getName();
+
+        /**
+         * Setter for name.
+         * @param arg_Name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setName(const std::string  arg_Name);
+
+        /**
+         * Re setter for name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetName();
+        
+        
+
+        /**
+         * Getter for custom_name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getCustom_name();
+
+        /**
+         * Setter for custom_name.
+         * @param arg_Custom_name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCustom_name(const std::string  arg_Custom_name);
+
+        /**
+         * Re setter for custom_name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCustom_name();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether subsystem_type is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSubsystem_typeNil();
+
+
+        
+
+        /**
+         * Check whether pool is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPoolNil();
+
+
+        
+
+        /**
+         * Check whether name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isNameNil();
+
+
+        
+
+        /**
+         * Check whether custom_name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCustom_nameNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ResourceID_om_node node to serialize from
+         * @param ResourceID_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ResourceID_om_node, axiom_element_t *ResourceID_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ResourceID is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for subsystem_type by property number (1)
+         * @return AviaryCommon::ResourceType
+         */
+
+        AviaryCommon::ResourceType* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for pool by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for name by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for custom_name by property number (4)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty4();
+
+    
+
+};
+
+}        
+ #endif /* RESOURCEID_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_ResourceType.h b/src/condor_contrib/aviary/include/AviaryCommon_ResourceType.h
new file mode 100644
index 0000000..dd42777
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_ResourceType.h
@@ -0,0 +1,252 @@
+
+
+        #ifndef AviaryCommon_RESOURCETYPE_H
+        #define AviaryCommon_RESOURCETYPE_H
+
+       /**
+        * ResourceType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ResourceType class
+        */
+
+        namespace AviaryCommon{
+            class ResourceType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            ResourceType_COLLECTOR,
+            ResourceType_EXECUTOR,
+            ResourceType_EVENT_SERVER,
+            ResourceType_JOB_SERVER,
+            ResourceType_LOW_LATENCY,
+            ResourceType_MASTER,
+            ResourceType_NEGOTIATOR,
+            ResourceType_SCHEDULER,
+            ResourceType_CUSTOM
+        } ADBResourceTypeEnum;
+        
+        
+
+        class ResourceType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_ResourceType;
+
+                
+                bool isValidResourceType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setResourceTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ResourceType
+         */
+
+        ResourceType();
+
+        /**
+         * Destructor ResourceType
+         */
+        ~ResourceType();
+
+
+       
+
+        /**
+         * Constructor for creating ResourceType
+         * @param 
+         * @param ResourceType std::string
+         * @return newly created ResourceType object
+         */
+        ResourceType(std::string arg_ResourceType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ResourceType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getResourceType();
+
+        /**
+         * Setter for ResourceType.
+         * @param arg_ResourceType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setResourceType(const std::string  arg_ResourceType);
+
+        /**
+         * Re setter for ResourceType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetResourceType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for ResourceType.
+            * @return ADBResourceTypeEnum; -1 on failure
+            */
+            ADBResourceTypeEnum WSF_CALL
+            getResourceTypeEnum();
+            
+            /**
+            * Enum setter for ResourceType.
+            * @param arg_ResourceType ADBResourceTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setResourceTypeEnum(
+            const ADBResourceTypeEnum arg_ResourceType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ResourceType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isResourceTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ResourceType_om_node node to serialize from
+         * @param ResourceType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ResourceType_om_node, axiom_element_t *ResourceType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ResourceType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ResourceType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* RESOURCETYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_Status.h b/src/condor_contrib/aviary/include/AviaryCommon_Status.h
new file mode 100644
index 0000000..6c72d49
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_Status.h
@@ -0,0 +1,253 @@
+
+
+        #ifndef AviaryCommon_STATUS_H
+        #define AviaryCommon_STATUS_H
+
+       /**
+        * Status.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  Status class
+        */
+
+        namespace AviaryCommon{
+            class Status;
+        }
+        
+
+        
+       #include "AviaryCommon_StatusCodeType.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class Status {
+
+        private:
+             AviaryCommon::StatusCodeType* property_Code;
+
+                
+                bool isValidCode;
+            std::string property_Text;
+
+                
+                bool isValidText;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setCodeNil();
+            
+
+        bool WSF_CALL
+        setTextNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class Status
+         */
+
+        Status();
+
+        /**
+         * Destructor Status
+         */
+        ~Status();
+
+
+       
+
+        /**
+         * Constructor for creating Status
+         * @param 
+         * @param Code AviaryCommon::StatusCodeType*
+         * @param Text std::string
+         * @return newly created Status object
+         */
+        Status(AviaryCommon::StatusCodeType* arg_Code,std::string arg_Text);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for code. 
+         * @return AviaryCommon::StatusCodeType*
+         */
+        WSF_EXTERN AviaryCommon::StatusCodeType* WSF_CALL
+        getCode();
+
+        /**
+         * Setter for code.
+         * @param arg_Code AviaryCommon::StatusCodeType*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCode(AviaryCommon::StatusCodeType*  arg_Code);
+
+        /**
+         * Re setter for code
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCode();
+        
+        
+
+        /**
+         * Getter for text. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getText();
+
+        /**
+         * Setter for text.
+         * @param arg_Text std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setText(const std::string  arg_Text);
+
+        /**
+         * Re setter for text
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetText();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether code is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCodeNil();
+
+
+        
+
+        /**
+         * Check whether text is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isTextNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param Status_om_node node to serialize from
+         * @param Status_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* Status_om_node, axiom_element_t *Status_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the Status is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for code by property number (1)
+         * @return AviaryCommon::StatusCodeType
+         */
+
+        AviaryCommon::StatusCodeType* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for text by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* STATUS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_StatusCodeType.h b/src/condor_contrib/aviary/include/AviaryCommon_StatusCodeType.h
new file mode 100644
index 0000000..bb71f9b
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_StatusCodeType.h
@@ -0,0 +1,249 @@
+
+
+        #ifndef AviaryCommon_STATUSCODETYPE_H
+        #define AviaryCommon_STATUSCODETYPE_H
+
+       /**
+        * StatusCodeType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  StatusCodeType class
+        */
+
+        namespace AviaryCommon{
+            class StatusCodeType;
+        }
+        
+
+        
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        /* Enumeration for this type */
+        typedef enum {
+            StatusCodeType_OK,
+            StatusCodeType_FAIL,
+            StatusCodeType_NO_MATCH,
+            StatusCodeType_INVALID_OFFSET,
+            StatusCodeType_UNIMPLEMENTED,
+            StatusCodeType_UNAVAILABLE
+        } ADBStatusCodeTypeEnum;
+        
+        
+
+        class StatusCodeType {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_StatusCodeType;
+
+                
+                bool isValidStatusCodeType;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setStatusCodeTypeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class StatusCodeType
+         */
+
+        StatusCodeType();
+
+        /**
+         * Destructor StatusCodeType
+         */
+        ~StatusCodeType();
+
+
+       
+
+        /**
+         * Constructor for creating StatusCodeType
+         * @param 
+         * @param StatusCodeType std::string
+         * @return newly created StatusCodeType object
+         */
+        StatusCodeType(std::string arg_StatusCodeType);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for StatusCodeType. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getStatusCodeType();
+
+        /**
+         * Setter for StatusCodeType.
+         * @param arg_StatusCodeType std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatusCodeType(const std::string  arg_StatusCodeType);
+
+        /**
+         * Re setter for StatusCodeType
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatusCodeType();
+        
+            
+            /************************** Getters and Setters For Enumerations ********************************/
+            /********************* Enumeration Specific Operations: get_enum, set_enum **********************/
+            
+            /**
+            * Enum getter for StatusCodeType.
+            * @return ADBStatusCodeTypeEnum; -1 on failure
+            */
+            ADBStatusCodeTypeEnum WSF_CALL
+            getStatusCodeTypeEnum();
+            
+            /**
+            * Enum setter for StatusCodeType.
+            * @param arg_StatusCodeType ADBStatusCodeTypeEnum
+            * @return AXIS2_SUCCESS on success, else AXIS2_FAILURE
+            */
+            bool WSF_CALL
+            setStatusCodeTypeEnum(
+            const ADBStatusCodeTypeEnum arg_StatusCodeType);
+            
+          
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether StatusCodeType is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusCodeTypeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the content from a string to an ADB object
+         * @param node_value to deserialize
+         * @param parent_element The parent element if it is an element, NULL otherwise
+         * @return true on success, false otherwise
+         */
+       bool WSF_CALL
+       deserializeFromString(const axis2_char_t *node_value, axiom_node_t *parent);
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+        /**
+         * Serialize ADB object to a string
+         * @param namespaces hash which contains a mapping of namespace uris to prefixes
+         * @return serialized string
+         */
+         char* WSF_CALL
+         serializeToString(axutil_hash_t *namespaces);
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param StatusCodeType_om_node node to serialize from
+         * @param StatusCodeType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* StatusCodeType_om_node, axiom_element_t *StatusCodeType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the StatusCodeType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for StatusCodeType by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* STATUSCODETYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_SubmissionID.h b/src/condor_contrib/aviary/include/AviaryCommon_SubmissionID.h
new file mode 100644
index 0000000..f4abae2
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_SubmissionID.h
@@ -0,0 +1,251 @@
+
+
+        #ifndef AviaryCommon_SUBMISSIONID_H
+        #define AviaryCommon_SUBMISSIONID_H
+
+       /**
+        * SubmissionID.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SubmissionID class
+        */
+
+        namespace AviaryCommon{
+            class SubmissionID;
+        }
+        
+
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class SubmissionID {
+
+        private:
+             std::string property_Name;
+
+                
+                bool isValidName;
+            std::string property_Owner;
+
+                
+                bool isValidOwner;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setNameNil();
+            
+
+        bool WSF_CALL
+        setOwnerNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SubmissionID
+         */
+
+        SubmissionID();
+
+        /**
+         * Destructor SubmissionID
+         */
+        ~SubmissionID();
+
+
+       
+
+        /**
+         * Constructor for creating SubmissionID
+         * @param 
+         * @param Name std::string
+         * @param Owner std::string
+         * @return newly created SubmissionID object
+         */
+        SubmissionID(std::string arg_Name,std::string arg_Owner);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getName();
+
+        /**
+         * Setter for name.
+         * @param arg_Name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setName(const std::string  arg_Name);
+
+        /**
+         * Re setter for name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetName();
+        
+        
+
+        /**
+         * Getter for owner. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getOwner();
+
+        /**
+         * Setter for owner.
+         * @param arg_Owner std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setOwner(const std::string  arg_Owner);
+
+        /**
+         * Re setter for owner
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetOwner();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isNameNil();
+
+
+        
+
+        /**
+         * Check whether owner is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isOwnerNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SubmissionID_om_node node to serialize from
+         * @param SubmissionID_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SubmissionID_om_node, axiom_element_t *SubmissionID_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SubmissionID is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for name by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for owner by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* SUBMISSIONID_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryCommon_SubmissionSummary.h b/src/condor_contrib/aviary/include/AviaryCommon_SubmissionSummary.h
new file mode 100644
index 0000000..f72562e
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryCommon_SubmissionSummary.h
@@ -0,0 +1,678 @@
+
+
+        #ifndef AviaryCommon_SUBMISSIONSUMMARY_H
+        #define AviaryCommon_SUBMISSIONSUMMARY_H
+
+       /**
+        * SubmissionSummary.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SubmissionSummary class
+        */
+
+        namespace AviaryCommon{
+            class SubmissionSummary;
+        }
+        
+
+        
+       #include "AviaryCommon_SubmissionID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+       #include "AviaryCommon_JobSummary.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryCommon
+{
+        
+        
+
+        class SubmissionSummary {
+
+        private:
+             AviaryCommon::SubmissionID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            int property_Completed;
+
+                
+                bool isValidCompleted;
+            int property_Held;
+
+                
+                bool isValidHeld;
+            int property_Idle;
+
+                
+                bool isValidIdle;
+            int property_Removed;
+
+                
+                bool isValidRemoved;
+            int property_Running;
+
+                
+                bool isValidRunning;
+            std::vector<AviaryCommon::JobSummary*>* property_Jobs;
+
+                
+                bool isValidJobs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setCompletedNil();
+            
+
+        bool WSF_CALL
+        setHeldNil();
+            
+
+        bool WSF_CALL
+        setIdleNil();
+            
+
+        bool WSF_CALL
+        setRemovedNil();
+            
+
+        bool WSF_CALL
+        setRunningNil();
+            
+
+        bool WSF_CALL
+        setJobsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SubmissionSummary
+         */
+
+        SubmissionSummary();
+
+        /**
+         * Destructor SubmissionSummary
+         */
+        ~SubmissionSummary();
+
+
+       
+
+        /**
+         * Constructor for creating SubmissionSummary
+         * @param 
+         * @param Id AviaryCommon::SubmissionID*
+         * @param Status AviaryCommon::Status*
+         * @param Completed int
+         * @param Held int
+         * @param Idle int
+         * @param Removed int
+         * @param Running int
+         * @param Jobs std::vector<AviaryCommon::JobSummary*>*
+         * @return newly created SubmissionSummary object
+         */
+        SubmissionSummary(AviaryCommon::SubmissionID* arg_Id,AviaryCommon::Status* arg_Status,int arg_Completed,int arg_Held,int arg_Idle,int arg_Removed,int arg_Running,std::vector<AviaryCommon::JobSummary*>* arg_Jobs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::SubmissionID*
+         */
+        WSF_EXTERN AviaryCommon::SubmissionID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::SubmissionID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::SubmissionID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for completed. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getCompleted();
+
+        /**
+         * Setter for completed.
+         * @param arg_Completed int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCompleted(const int  arg_Completed);
+
+        /**
+         * Re setter for completed
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCompleted();
+        
+        
+
+        /**
+         * Getter for held. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getHeld();
+
+        /**
+         * Setter for held.
+         * @param arg_Held int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setHeld(const int  arg_Held);
+
+        /**
+         * Re setter for held
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetHeld();
+        
+        
+
+        /**
+         * Getter for idle. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getIdle();
+
+        /**
+         * Setter for idle.
+         * @param arg_Idle int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdle(const int  arg_Idle);
+
+        /**
+         * Re setter for idle
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIdle();
+        
+        
+
+        /**
+         * Getter for removed. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getRemoved();
+
+        /**
+         * Setter for removed.
+         * @param arg_Removed int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRemoved(const int  arg_Removed);
+
+        /**
+         * Re setter for removed
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRemoved();
+        
+        
+
+        /**
+         * Getter for running. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getRunning();
+
+        /**
+         * Setter for running.
+         * @param arg_Running int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRunning(const int  arg_Running);
+
+        /**
+         * Re setter for running
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRunning();
+        
+        
+
+        /**
+         * Getter for jobs. Deprecated for array types, Use getJobsAt instead
+         * @return Array of AviaryCommon::JobSummary*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+        getJobs();
+
+        /**
+         * Setter for jobs.Deprecated for array types, Use setJobsAt
+         * or addJobs instead.
+         * @param arg_Jobs Array of AviaryCommon::JobSummary*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobs(std::vector<AviaryCommon::JobSummary*>*  arg_Jobs);
+
+        /**
+         * Re setter for jobs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of jobs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobSummary* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobSummary* WSF_CALL
+        getJobsAt(int i);
+
+        /**
+         * Set the ith element of jobs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Jobs element to set AviaryCommon::JobSummary* to the array
+         * @return ith AviaryCommon::JobSummary* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobsAt(int i,
+                AviaryCommon::JobSummary* arg_Jobs);
+
+
+        /**
+         * Add to jobs.
+         * @param arg_Jobs element to add AviaryCommon::JobSummary* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addJobs(
+            AviaryCommon::JobSummary* arg_Jobs);
+
+        /**
+         * Get the size of the jobs array.
+         * @return the size of the jobs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofJobs();
+
+        /**
+         * Remove the ith element of jobs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeJobsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether completed is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCompletedNil();
+
+
+        
+
+        /**
+         * Check whether held is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isHeldNil();
+
+
+        
+
+        /**
+         * Check whether idle is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdleNil();
+
+
+        
+
+        /**
+         * Check whether removed is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRemovedNil();
+
+
+        
+
+        /**
+         * Check whether running is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRunningNil();
+
+
+        
+
+        /**
+         * Check whether jobs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether jobs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNilAt(int i);
+ 
+       
+        /**
+         * Set jobs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setJobsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SubmissionSummary_om_node node to serialize from
+         * @param SubmissionSummary_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SubmissionSummary_om_node, axiom_element_t *SubmissionSummary_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SubmissionSummary is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::SubmissionID
+         */
+
+        AviaryCommon::SubmissionID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for completed by property number (3)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for held by property number (4)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty4();
+
+    
+        
+
+        /**
+         * Getter for idle by property number (5)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty5();
+
+    
+        
+
+        /**
+         * Getter for removed by property number (6)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty6();
+
+    
+        
+
+        /**
+         * Getter for running by property number (7)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty7();
+
+    
+        
+
+        /**
+         * Getter for jobs by property number (8)
+         * @return Array of AviaryCommon::JobSummarys.
+         */
+
+        std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+        getProperty8();
+
+    
+
+};
+
+}        
+ #endif /* SUBMISSIONSUMMARY_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_ControlJob.h b/src/condor_contrib/aviary/include/AviaryJob_ControlJob.h
new file mode 100644
index 0000000..381e631
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_ControlJob.h
@@ -0,0 +1,253 @@
+
+
+        #ifndef AviaryJob_CONTROLJOB_H
+        #define AviaryJob_CONTROLJOB_H
+
+       /**
+        * ControlJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ControlJob class
+        */
+
+        namespace AviaryJob{
+            class ControlJob;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class ControlJob {
+
+        private:
+             AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            std::string property_Reason;
+
+                
+                bool isValidReason;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setReasonNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ControlJob
+         */
+
+        ControlJob();
+
+        /**
+         * Destructor ControlJob
+         */
+        ~ControlJob();
+
+
+       
+
+        /**
+         * Constructor for creating ControlJob
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Reason std::string
+         * @return newly created ControlJob object
+         */
+        ControlJob(AviaryCommon::JobID* arg_Id,std::string arg_Reason);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for reason. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getReason();
+
+        /**
+         * Setter for reason.
+         * @param arg_Reason std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setReason(const std::string  arg_Reason);
+
+        /**
+         * Re setter for reason
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetReason();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether reason is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isReasonNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ControlJob_om_node node to serialize from
+         * @param ControlJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ControlJob_om_node, axiom_element_t *ControlJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ControlJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for reason by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* CONTROLJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_ControlJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_ControlJobResponse.h
new file mode 100644
index 0000000..cf03407
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_ControlJobResponse.h
@@ -0,0 +1,199 @@
+
+
+        #ifndef AviaryJob_CONTROLJOBRESPONSE_H
+        #define AviaryJob_CONTROLJOBRESPONSE_H
+
+       /**
+        * ControlJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ControlJobResponse class
+        */
+
+        namespace AviaryJob{
+            class ControlJobResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_Status.h"
+          
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class ControlJobResponse {
+
+        private:
+             AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ControlJobResponse
+         */
+
+        ControlJobResponse();
+
+        /**
+         * Destructor ControlJobResponse
+         */
+        ~ControlJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating ControlJobResponse
+         * @param 
+         * @param Status AviaryCommon::Status*
+         * @return newly created ControlJobResponse object
+         */
+        ControlJobResponse(AviaryCommon::Status* arg_Status);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ControlJobResponse_om_node node to serialize from
+         * @param ControlJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ControlJobResponse_om_node, axiom_element_t *ControlJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ControlJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for status by property number (1)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* CONTROLJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_HoldJob.h b/src/condor_contrib/aviary/include/AviaryJob_HoldJob.h
new file mode 100644
index 0000000..119d76f
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_HoldJob.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_HOLDJOB_H
+        #define AviaryJob_HOLDJOB_H
+
+       /**
+        * HoldJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  HoldJob class
+        */
+
+        namespace AviaryJob{
+            class HoldJob;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJob.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class HoldJob {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJob* property_HoldJob;
+
+                
+                bool isValidHoldJob;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setHoldJobNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class HoldJob
+         */
+
+        HoldJob();
+
+        /**
+         * Destructor HoldJob
+         */
+        ~HoldJob();
+
+
+       
+
+        /**
+         * Constructor for creating HoldJob
+         * @param 
+         * @param HoldJob AviaryJob::ControlJob*
+         * @return newly created HoldJob object
+         */
+        HoldJob(AviaryJob::ControlJob* arg_HoldJob);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for HoldJob. 
+         * @return AviaryJob::ControlJob*
+         */
+        WSF_EXTERN AviaryJob::ControlJob* WSF_CALL
+        getHoldJob();
+
+        /**
+         * Setter for HoldJob.
+         * @param arg_HoldJob AviaryJob::ControlJob*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setHoldJob(AviaryJob::ControlJob*  arg_HoldJob);
+
+        /**
+         * Re setter for HoldJob
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetHoldJob();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether HoldJob is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isHoldJobNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param HoldJob_om_node node to serialize from
+         * @param HoldJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* HoldJob_om_node, axiom_element_t *HoldJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the HoldJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for HoldJob by property number (1)
+         * @return AviaryJob::ControlJob
+         */
+
+        AviaryJob::ControlJob* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* HOLDJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_HoldJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_HoldJobResponse.h
new file mode 100644
index 0000000..3b8d1da
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_HoldJobResponse.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_HOLDJOBRESPONSE_H
+        #define AviaryJob_HOLDJOBRESPONSE_H
+
+       /**
+        * HoldJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  HoldJobResponse class
+        */
+
+        namespace AviaryJob{
+            class HoldJobResponse;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJobResponse.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class HoldJobResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJobResponse* property_HoldJobResponse;
+
+                
+                bool isValidHoldJobResponse;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setHoldJobResponseNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class HoldJobResponse
+         */
+
+        HoldJobResponse();
+
+        /**
+         * Destructor HoldJobResponse
+         */
+        ~HoldJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating HoldJobResponse
+         * @param 
+         * @param HoldJobResponse AviaryJob::ControlJobResponse*
+         * @return newly created HoldJobResponse object
+         */
+        HoldJobResponse(AviaryJob::ControlJobResponse* arg_HoldJobResponse);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for HoldJobResponse. 
+         * @return AviaryJob::ControlJobResponse*
+         */
+        WSF_EXTERN AviaryJob::ControlJobResponse* WSF_CALL
+        getHoldJobResponse();
+
+        /**
+         * Setter for HoldJobResponse.
+         * @param arg_HoldJobResponse AviaryJob::ControlJobResponse*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setHoldJobResponse(AviaryJob::ControlJobResponse*  arg_HoldJobResponse);
+
+        /**
+         * Re setter for HoldJobResponse
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetHoldJobResponse();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether HoldJobResponse is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isHoldJobResponseNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param HoldJobResponse_om_node node to serialize from
+         * @param HoldJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* HoldJobResponse_om_node, axiom_element_t *HoldJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the HoldJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for HoldJobResponse by property number (1)
+         * @return AviaryJob::ControlJobResponse
+         */
+
+        AviaryJob::ControlJobResponse* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* HOLDJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_ReleaseJob.h b/src/condor_contrib/aviary/include/AviaryJob_ReleaseJob.h
new file mode 100644
index 0000000..9fc3c14
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_ReleaseJob.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_RELEASEJOB_H
+        #define AviaryJob_RELEASEJOB_H
+
+       /**
+        * ReleaseJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ReleaseJob class
+        */
+
+        namespace AviaryJob{
+            class ReleaseJob;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJob.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class ReleaseJob {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJob* property_ReleaseJob;
+
+                
+                bool isValidReleaseJob;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setReleaseJobNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ReleaseJob
+         */
+
+        ReleaseJob();
+
+        /**
+         * Destructor ReleaseJob
+         */
+        ~ReleaseJob();
+
+
+       
+
+        /**
+         * Constructor for creating ReleaseJob
+         * @param 
+         * @param ReleaseJob AviaryJob::ControlJob*
+         * @return newly created ReleaseJob object
+         */
+        ReleaseJob(AviaryJob::ControlJob* arg_ReleaseJob);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ReleaseJob. 
+         * @return AviaryJob::ControlJob*
+         */
+        WSF_EXTERN AviaryJob::ControlJob* WSF_CALL
+        getReleaseJob();
+
+        /**
+         * Setter for ReleaseJob.
+         * @param arg_ReleaseJob AviaryJob::ControlJob*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setReleaseJob(AviaryJob::ControlJob*  arg_ReleaseJob);
+
+        /**
+         * Re setter for ReleaseJob
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetReleaseJob();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ReleaseJob is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isReleaseJobNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ReleaseJob_om_node node to serialize from
+         * @param ReleaseJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ReleaseJob_om_node, axiom_element_t *ReleaseJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ReleaseJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ReleaseJob by property number (1)
+         * @return AviaryJob::ControlJob
+         */
+
+        AviaryJob::ControlJob* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* RELEASEJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_ReleaseJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_ReleaseJobResponse.h
new file mode 100644
index 0000000..6247516
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_ReleaseJobResponse.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_RELEASEJOBRESPONSE_H
+        #define AviaryJob_RELEASEJOBRESPONSE_H
+
+       /**
+        * ReleaseJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  ReleaseJobResponse class
+        */
+
+        namespace AviaryJob{
+            class ReleaseJobResponse;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJobResponse.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class ReleaseJobResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJobResponse* property_ReleaseJobResponse;
+
+                
+                bool isValidReleaseJobResponse;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setReleaseJobResponseNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class ReleaseJobResponse
+         */
+
+        ReleaseJobResponse();
+
+        /**
+         * Destructor ReleaseJobResponse
+         */
+        ~ReleaseJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating ReleaseJobResponse
+         * @param 
+         * @param ReleaseJobResponse AviaryJob::ControlJobResponse*
+         * @return newly created ReleaseJobResponse object
+         */
+        ReleaseJobResponse(AviaryJob::ControlJobResponse* arg_ReleaseJobResponse);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for ReleaseJobResponse. 
+         * @return AviaryJob::ControlJobResponse*
+         */
+        WSF_EXTERN AviaryJob::ControlJobResponse* WSF_CALL
+        getReleaseJobResponse();
+
+        /**
+         * Setter for ReleaseJobResponse.
+         * @param arg_ReleaseJobResponse AviaryJob::ControlJobResponse*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setReleaseJobResponse(AviaryJob::ControlJobResponse*  arg_ReleaseJobResponse);
+
+        /**
+         * Re setter for ReleaseJobResponse
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetReleaseJobResponse();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ReleaseJobResponse is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isReleaseJobResponseNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param ReleaseJobResponse_om_node node to serialize from
+         * @param ReleaseJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* ReleaseJobResponse_om_node, axiom_element_t *ReleaseJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the ReleaseJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ReleaseJobResponse by property number (1)
+         * @return AviaryJob::ControlJobResponse
+         */
+
+        AviaryJob::ControlJobResponse* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* RELEASEJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_RemoveJob.h b/src/condor_contrib/aviary/include/AviaryJob_RemoveJob.h
new file mode 100644
index 0000000..7d66ddc
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_RemoveJob.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_REMOVEJOB_H
+        #define AviaryJob_REMOVEJOB_H
+
+       /**
+        * RemoveJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  RemoveJob class
+        */
+
+        namespace AviaryJob{
+            class RemoveJob;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJob.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class RemoveJob {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJob* property_RemoveJob;
+
+                
+                bool isValidRemoveJob;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setRemoveJobNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class RemoveJob
+         */
+
+        RemoveJob();
+
+        /**
+         * Destructor RemoveJob
+         */
+        ~RemoveJob();
+
+
+       
+
+        /**
+         * Constructor for creating RemoveJob
+         * @param 
+         * @param RemoveJob AviaryJob::ControlJob*
+         * @return newly created RemoveJob object
+         */
+        RemoveJob(AviaryJob::ControlJob* arg_RemoveJob);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for RemoveJob. 
+         * @return AviaryJob::ControlJob*
+         */
+        WSF_EXTERN AviaryJob::ControlJob* WSF_CALL
+        getRemoveJob();
+
+        /**
+         * Setter for RemoveJob.
+         * @param arg_RemoveJob AviaryJob::ControlJob*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRemoveJob(AviaryJob::ControlJob*  arg_RemoveJob);
+
+        /**
+         * Re setter for RemoveJob
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRemoveJob();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether RemoveJob is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRemoveJobNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param RemoveJob_om_node node to serialize from
+         * @param RemoveJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* RemoveJob_om_node, axiom_element_t *RemoveJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the RemoveJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for RemoveJob by property number (1)
+         * @return AviaryJob::ControlJob
+         */
+
+        AviaryJob::ControlJob* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* REMOVEJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_RemoveJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_RemoveJobResponse.h
new file mode 100644
index 0000000..eb67b57
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_RemoveJobResponse.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_REMOVEJOBRESPONSE_H
+        #define AviaryJob_REMOVEJOBRESPONSE_H
+
+       /**
+        * RemoveJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  RemoveJobResponse class
+        */
+
+        namespace AviaryJob{
+            class RemoveJobResponse;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJobResponse.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class RemoveJobResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJobResponse* property_RemoveJobResponse;
+
+                
+                bool isValidRemoveJobResponse;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setRemoveJobResponseNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class RemoveJobResponse
+         */
+
+        RemoveJobResponse();
+
+        /**
+         * Destructor RemoveJobResponse
+         */
+        ~RemoveJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating RemoveJobResponse
+         * @param 
+         * @param RemoveJobResponse AviaryJob::ControlJobResponse*
+         * @return newly created RemoveJobResponse object
+         */
+        RemoveJobResponse(AviaryJob::ControlJobResponse* arg_RemoveJobResponse);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for RemoveJobResponse. 
+         * @return AviaryJob::ControlJobResponse*
+         */
+        WSF_EXTERN AviaryJob::ControlJobResponse* WSF_CALL
+        getRemoveJobResponse();
+
+        /**
+         * Setter for RemoveJobResponse.
+         * @param arg_RemoveJobResponse AviaryJob::ControlJobResponse*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRemoveJobResponse(AviaryJob::ControlJobResponse*  arg_RemoveJobResponse);
+
+        /**
+         * Re setter for RemoveJobResponse
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRemoveJobResponse();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether RemoveJobResponse is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRemoveJobResponseNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param RemoveJobResponse_om_node node to serialize from
+         * @param RemoveJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* RemoveJobResponse_om_node, axiom_element_t *RemoveJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the RemoveJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for RemoveJobResponse by property number (1)
+         * @return AviaryJob::ControlJobResponse
+         */
+
+        AviaryJob::ControlJobResponse* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* REMOVEJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_SetJobAttribute.h b/src/condor_contrib/aviary/include/AviaryJob_SetJobAttribute.h
new file mode 100644
index 0000000..a046279
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_SetJobAttribute.h
@@ -0,0 +1,259 @@
+
+
+        #ifndef AviaryJob_SETJOBATTRIBUTE_H
+        #define AviaryJob_SETJOBATTRIBUTE_H
+
+       /**
+        * SetJobAttribute.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SetJobAttribute class
+        */
+
+        namespace AviaryJob{
+            class SetJobAttribute;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Attribute.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class SetJobAttribute {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Attribute* property_Attribute;
+
+                
+                bool isValidAttribute;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setAttributeNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SetJobAttribute
+         */
+
+        SetJobAttribute();
+
+        /**
+         * Destructor SetJobAttribute
+         */
+        ~SetJobAttribute();
+
+
+       
+
+        /**
+         * Constructor for creating SetJobAttribute
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Attribute AviaryCommon::Attribute*
+         * @return newly created SetJobAttribute object
+         */
+        SetJobAttribute(AviaryCommon::JobID* arg_Id,AviaryCommon::Attribute* arg_Attribute);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for attribute. 
+         * @return AviaryCommon::Attribute*
+         */
+        WSF_EXTERN AviaryCommon::Attribute* WSF_CALL
+        getAttribute();
+
+        /**
+         * Setter for attribute.
+         * @param arg_Attribute AviaryCommon::Attribute*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAttribute(AviaryCommon::Attribute*  arg_Attribute);
+
+        /**
+         * Re setter for attribute
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAttribute();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether attribute is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAttributeNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SetJobAttribute_om_node node to serialize from
+         * @param SetJobAttribute_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SetJobAttribute_om_node, axiom_element_t *SetJobAttribute_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SetJobAttribute is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for attribute by property number (2)
+         * @return AviaryCommon::Attribute
+         */
+
+        AviaryCommon::Attribute* WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* SETJOBATTRIBUTE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_SetJobAttributeResponse.h b/src/condor_contrib/aviary/include/AviaryJob_SetJobAttributeResponse.h
new file mode 100644
index 0000000..8d39178
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_SetJobAttributeResponse.h
@@ -0,0 +1,203 @@
+
+
+        #ifndef AviaryJob_SETJOBATTRIBUTERESPONSE_H
+        #define AviaryJob_SETJOBATTRIBUTERESPONSE_H
+
+       /**
+        * SetJobAttributeResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SetJobAttributeResponse class
+        */
+
+        namespace AviaryJob{
+            class SetJobAttributeResponse;
+        }
+        
+
+        
+       #include "AviaryJob_ControlJobResponse.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class SetJobAttributeResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryJob::ControlJobResponse* property_SetJobAttributeResponse;
+
+                
+                bool isValidSetJobAttributeResponse;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setSetJobAttributeResponseNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SetJobAttributeResponse
+         */
+
+        SetJobAttributeResponse();
+
+        /**
+         * Destructor SetJobAttributeResponse
+         */
+        ~SetJobAttributeResponse();
+
+
+       
+
+        /**
+         * Constructor for creating SetJobAttributeResponse
+         * @param 
+         * @param SetJobAttributeResponse AviaryJob::ControlJobResponse*
+         * @return newly created SetJobAttributeResponse object
+         */
+        SetJobAttributeResponse(AviaryJob::ControlJobResponse* arg_SetJobAttributeResponse);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for SetJobAttributeResponse. 
+         * @return AviaryJob::ControlJobResponse*
+         */
+        WSF_EXTERN AviaryJob::ControlJobResponse* WSF_CALL
+        getSetJobAttributeResponse();
+
+        /**
+         * Setter for SetJobAttributeResponse.
+         * @param arg_SetJobAttributeResponse AviaryJob::ControlJobResponse*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSetJobAttributeResponse(AviaryJob::ControlJobResponse*  arg_SetJobAttributeResponse);
+
+        /**
+         * Re setter for SetJobAttributeResponse
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSetJobAttributeResponse();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether SetJobAttributeResponse is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSetJobAttributeResponseNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SetJobAttributeResponse_om_node node to serialize from
+         * @param SetJobAttributeResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SetJobAttributeResponse_om_node, axiom_element_t *SetJobAttributeResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SetJobAttributeResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for SetJobAttributeResponse by property number (1)
+         * @return AviaryJob::ControlJobResponse
+         */
+
+        AviaryJob::ControlJobResponse* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* SETJOBATTRIBUTERESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_SubmitJob.h b/src/condor_contrib/aviary/include/AviaryJob_SubmitJob.h
new file mode 100644
index 0000000..e26d8ed
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_SubmitJob.h
@@ -0,0 +1,747 @@
+
+
+        #ifndef AviaryJob_SUBMITJOB_H
+        #define AviaryJob_SUBMITJOB_H
+
+       /**
+        * SubmitJob.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SubmitJob class
+        */
+
+        namespace AviaryJob{
+            class SubmitJob;
+        }
+        
+
+        
+       #include "AviaryCommon_ResourceConstraint.h"
+          
+       #include "AviaryCommon_Attribute.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class SubmitJob {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::string property_Cmd;
+
+                
+                bool isValidCmd;
+            std::string property_Args;
+
+                
+                bool isValidArgs;
+            std::string property_Owner;
+
+                
+                bool isValidOwner;
+            std::string property_Iwd;
+
+                
+                bool isValidIwd;
+            std::string property_Submission_name;
+
+                
+                bool isValidSubmission_name;
+            std::vector<AviaryCommon::ResourceConstraint*>* property_Requirements;
+
+                
+                bool isValidRequirements;
+            std::vector<AviaryCommon::Attribute*>* property_Extra;
+
+                
+                bool isValidExtra;
+            bool property_AllowOverrides;
+
+                
+                bool isValidAllowOverrides;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setCmdNil();
+            
+
+        bool WSF_CALL
+        setArgsNil();
+            
+
+        bool WSF_CALL
+        setOwnerNil();
+            
+
+        bool WSF_CALL
+        setIwdNil();
+            
+
+        bool WSF_CALL
+        setSubmission_nameNil();
+            
+
+        bool WSF_CALL
+        setRequirementsNil();
+            
+
+        bool WSF_CALL
+        setExtraNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SubmitJob
+         */
+
+        SubmitJob();
+
+        /**
+         * Destructor SubmitJob
+         */
+        ~SubmitJob();
+
+
+       
+
+        /**
+         * Constructor for creating SubmitJob
+         * @param 
+         * @param Cmd std::string
+         * @param Args std::string
+         * @param Owner std::string
+         * @param Iwd std::string
+         * @param Submission_name std::string
+         * @param Requirements std::vector<AviaryCommon::ResourceConstraint*>*
+         * @param Extra std::vector<AviaryCommon::Attribute*>*
+         * @param AllowOverrides bool
+         * @return newly created SubmitJob object
+         */
+        SubmitJob(std::string arg_Cmd,std::string arg_Args,std::string arg_Owner,std::string arg_Iwd,std::string arg_Submission_name,std::vector<AviaryCommon::ResourceConstraint*>* arg_Requirements,std::vector<AviaryCommon::Attribute*>* arg_Extra,bool arg_AllowOverrides);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for cmd. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getCmd();
+
+        /**
+         * Setter for cmd.
+         * @param arg_Cmd std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setCmd(const std::string  arg_Cmd);
+
+        /**
+         * Re setter for cmd
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetCmd();
+        
+        
+
+        /**
+         * Getter for args. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getArgs();
+
+        /**
+         * Setter for args.
+         * @param arg_Args std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setArgs(const std::string  arg_Args);
+
+        /**
+         * Re setter for args
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetArgs();
+        
+        
+
+        /**
+         * Getter for owner. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getOwner();
+
+        /**
+         * Setter for owner.
+         * @param arg_Owner std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setOwner(const std::string  arg_Owner);
+
+        /**
+         * Re setter for owner
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetOwner();
+        
+        
+
+        /**
+         * Getter for iwd. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getIwd();
+
+        /**
+         * Setter for iwd.
+         * @param arg_Iwd std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIwd(const std::string  arg_Iwd);
+
+        /**
+         * Re setter for iwd
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIwd();
+        
+        
+
+        /**
+         * Getter for submission_name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getSubmission_name();
+
+        /**
+         * Setter for submission_name.
+         * @param arg_Submission_name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubmission_name(const std::string  arg_Submission_name);
+
+        /**
+         * Re setter for submission_name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSubmission_name();
+        
+        
+
+        /**
+         * Getter for requirements. Deprecated for array types, Use getRequirementsAt instead
+         * @return Array of AviaryCommon::ResourceConstraint*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::ResourceConstraint*>* WSF_CALL
+        getRequirements();
+
+        /**
+         * Setter for requirements.Deprecated for array types, Use setRequirementsAt
+         * or addRequirements instead.
+         * @param arg_Requirements Array of AviaryCommon::ResourceConstraint*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRequirements(std::vector<AviaryCommon::ResourceConstraint*>*  arg_Requirements);
+
+        /**
+         * Re setter for requirements
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetRequirements();
+        
+        
+
+        /**
+         * Getter for extra. Deprecated for array types, Use getExtraAt instead
+         * @return Array of AviaryCommon::Attribute*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::Attribute*>* WSF_CALL
+        getExtra();
+
+        /**
+         * Setter for extra.Deprecated for array types, Use setExtraAt
+         * or addExtra instead.
+         * @param arg_Extra Array of AviaryCommon::Attribute*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setExtra(std::vector<AviaryCommon::Attribute*>*  arg_Extra);
+
+        /**
+         * Re setter for extra
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetExtra();
+        
+        
+
+        /**
+         * Getter for allowOverrides. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getAllowOverrides();
+
+        /**
+         * Setter for allowOverrides.
+         * @param arg_AllowOverrides bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAllowOverrides(bool  arg_AllowOverrides);
+
+        /**
+         * Re setter for allowOverrides
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAllowOverrides();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of requirements.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::ResourceConstraint* of the array
+         */
+        WSF_EXTERN AviaryCommon::ResourceConstraint* WSF_CALL
+        getRequirementsAt(int i);
+
+        /**
+         * Set the ith element of requirements. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Requirements element to set AviaryCommon::ResourceConstraint* to the array
+         * @return ith AviaryCommon::ResourceConstraint* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setRequirementsAt(int i,
+                AviaryCommon::ResourceConstraint* arg_Requirements);
+
+
+        /**
+         * Add to requirements.
+         * @param arg_Requirements element to add AviaryCommon::ResourceConstraint* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addRequirements(
+            AviaryCommon::ResourceConstraint* arg_Requirements);
+
+        /**
+         * Get the size of the requirements array.
+         * @return the size of the requirements array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofRequirements();
+
+        /**
+         * Remove the ith element of requirements.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeRequirementsAt(int i);
+
+        
+        
+        /**
+         * Get the ith element of extra.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::Attribute* of the array
+         */
+        WSF_EXTERN AviaryCommon::Attribute* WSF_CALL
+        getExtraAt(int i);
+
+        /**
+         * Set the ith element of extra. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Extra element to set AviaryCommon::Attribute* to the array
+         * @return ith AviaryCommon::Attribute* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setExtraAt(int i,
+                AviaryCommon::Attribute* arg_Extra);
+
+
+        /**
+         * Add to extra.
+         * @param arg_Extra element to add AviaryCommon::Attribute* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addExtra(
+            AviaryCommon::Attribute* arg_Extra);
+
+        /**
+         * Get the size of the extra array.
+         * @return the size of the extra array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofExtra();
+
+        /**
+         * Remove the ith element of extra.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeExtraAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether cmd is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isCmdNil();
+
+
+        
+
+        /**
+         * Check whether args is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isArgsNil();
+
+
+        
+
+        /**
+         * Check whether owner is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isOwnerNil();
+
+
+        
+
+        /**
+         * Check whether iwd is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIwdNil();
+
+
+        
+
+        /**
+         * Check whether submission_name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSubmission_nameNil();
+
+
+        
+
+        /**
+         * Check whether requirements is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isRequirementsNil();
+
+
+        
+
+        /**
+         * Check whether extra is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isExtraNil();
+
+
+        
+
+        /**
+         * Check whether allowOverrides is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAllowOverridesNil();
+
+
+        
+        /**
+         * Set allowOverrides to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setAllowOverridesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether requirements is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isRequirementsNilAt(int i);
+ 
+       
+        /**
+         * Set requirements to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setRequirementsNilAt(int i);
+
+        
+        /**
+         * Check whether extra is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isExtraNilAt(int i);
+ 
+       
+        /**
+         * Set extra to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setExtraNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SubmitJob_om_node node to serialize from
+         * @param SubmitJob_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SubmitJob_om_node, axiom_element_t *SubmitJob_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SubmitJob is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for cmd by property number (1)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for args by property number (2)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for owner by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for iwd by property number (4)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty4();
+
+    
+        
+
+        /**
+         * Getter for submission_name by property number (5)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty5();
+
+    
+        
+
+        /**
+         * Getter for requirements by property number (6)
+         * @return Array of AviaryCommon::ResourceConstraints.
+         */
+
+        std::vector<AviaryCommon::ResourceConstraint*>* WSF_CALL
+        getProperty6();
+
+    
+        
+
+        /**
+         * Getter for extra by property number (7)
+         * @return Array of AviaryCommon::Attributes.
+         */
+
+        std::vector<AviaryCommon::Attribute*>* WSF_CALL
+        getProperty7();
+
+    
+        
+
+        /**
+         * Getter for allowOverrides by property number (8)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty8();
+
+    
+
+};
+
+}        
+ #endif /* SUBMITJOB_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryJob_SubmitJobResponse.h b/src/condor_contrib/aviary/include/AviaryJob_SubmitJobResponse.h
new file mode 100644
index 0000000..42b32fd
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryJob_SubmitJobResponse.h
@@ -0,0 +1,259 @@
+
+
+        #ifndef AviaryJob_SUBMITJOBRESPONSE_H
+        #define AviaryJob_SUBMITJOBRESPONSE_H
+
+       /**
+        * SubmitJobResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  SubmitJobResponse class
+        */
+
+        namespace AviaryJob{
+            class SubmitJobResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryJob
+{
+        
+        
+
+        class SubmitJobResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryCommon::JobID* property_Id;
+
+                
+                bool isValidId;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class SubmitJobResponse
+         */
+
+        SubmitJobResponse();
+
+        /**
+         * Destructor SubmitJobResponse
+         */
+        ~SubmitJobResponse();
+
+
+       
+
+        /**
+         * Constructor for creating SubmitJobResponse
+         * @param 
+         * @param Id AviaryCommon::JobID*
+         * @param Status AviaryCommon::Status*
+         * @return newly created SubmitJobResponse object
+         */
+        SubmitJobResponse(AviaryCommon::JobID* arg_Id,AviaryCommon::Status* arg_Status);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for id. 
+         * @return AviaryCommon::JobID*
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getId();
+
+        /**
+         * Setter for id.
+         * @param arg_Id AviaryCommon::JobID*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setId(AviaryCommon::JobID*  arg_Id);
+
+        /**
+         * Re setter for id
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetId();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether id is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param SubmitJobResponse_om_node node to serialize from
+         * @param SubmitJobResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* SubmitJobResponse_om_node, axiom_element_t *SubmitJobResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the SubmitJobResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for id by property number (1)
+         * @return AviaryCommon::JobID
+         */
+
+        AviaryCommon::JobID* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* SUBMITJOBRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobData.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobData.h
new file mode 100644
index 0000000..9439d0a
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobData.h
@@ -0,0 +1,311 @@
+
+
+        #ifndef AviaryQuery_GETJOBDATA_H
+        #define AviaryQuery_GETJOBDATA_H
+
+       /**
+        * GetJobData.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobData class
+        */
+
+        namespace AviaryQuery{
+            class GetJobData;
+        }
+        
+
+        
+       #include "AviaryCommon_JobData.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobData {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryCommon::JobData* property_Data;
+
+                
+                bool isValidData;
+            int property_Max_bytes;
+
+                
+                bool isValidMax_bytes;
+            bool property_From_end;
+
+                
+                bool isValidFrom_end;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setDataNil();
+            
+
+        bool WSF_CALL
+        setMax_bytesNil();
+            
+
+        bool WSF_CALL
+        setFrom_endNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobData
+         */
+
+        GetJobData();
+
+        /**
+         * Destructor GetJobData
+         */
+        ~GetJobData();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobData
+         * @param 
+         * @param Data AviaryCommon::JobData*
+         * @param Max_bytes int
+         * @param From_end bool
+         * @return newly created GetJobData object
+         */
+        GetJobData(AviaryCommon::JobData* arg_Data,int arg_Max_bytes,bool arg_From_end);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for data. 
+         * @return AviaryCommon::JobData*
+         */
+        WSF_EXTERN AviaryCommon::JobData* WSF_CALL
+        getData();
+
+        /**
+         * Setter for data.
+         * @param arg_Data AviaryCommon::JobData*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setData(AviaryCommon::JobData*  arg_Data);
+
+        /**
+         * Re setter for data
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetData();
+        
+        
+
+        /**
+         * Getter for max_bytes. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getMax_bytes();
+
+        /**
+         * Setter for max_bytes.
+         * @param arg_Max_bytes int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setMax_bytes(const int  arg_Max_bytes);
+
+        /**
+         * Re setter for max_bytes
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetMax_bytes();
+        
+        
+
+        /**
+         * Getter for from_end. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getFrom_end();
+
+        /**
+         * Setter for from_end.
+         * @param arg_From_end bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setFrom_end(bool  arg_From_end);
+
+        /**
+         * Re setter for from_end
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetFrom_end();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether data is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isDataNil();
+
+
+        
+
+        /**
+         * Check whether max_bytes is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isMax_bytesNil();
+
+
+        
+
+        /**
+         * Check whether from_end is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isFrom_endNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobData_om_node node to serialize from
+         * @param GetJobData_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobData_om_node, axiom_element_t *GetJobData_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobData is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for data by property number (1)
+         * @return AviaryCommon::JobData
+         */
+
+        AviaryCommon::JobData* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for max_bytes by property number (2)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for from_end by property number (3)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBDATA_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobDataResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDataResponse.h
new file mode 100644
index 0000000..6acae59
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDataResponse.h
@@ -0,0 +1,421 @@
+
+
+        #ifndef AviaryQuery_GETJOBDATARESPONSE_H
+        #define AviaryQuery_GETJOBDATARESPONSE_H
+
+       /**
+        * GetJobDataResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobDataResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetJobDataResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobData.h"
+          
+       #include "AviaryCommon_Status.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobDataResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            AviaryCommon::JobData* property_Data;
+
+                
+                bool isValidData;
+            AviaryCommon::Status* property_Status;
+
+                
+                bool isValidStatus;
+            std::string property_File_name;
+
+                
+                bool isValidFile_name;
+            int property_File_size;
+
+                
+                bool isValidFile_size;
+            std::string property_Content;
+
+                
+                bool isValidContent;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setDataNil();
+            
+
+        bool WSF_CALL
+        setStatusNil();
+            
+
+        bool WSF_CALL
+        setFile_nameNil();
+            
+
+        bool WSF_CALL
+        setFile_sizeNil();
+            
+
+        bool WSF_CALL
+        setContentNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobDataResponse
+         */
+
+        GetJobDataResponse();
+
+        /**
+         * Destructor GetJobDataResponse
+         */
+        ~GetJobDataResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobDataResponse
+         * @param 
+         * @param Data AviaryCommon::JobData*
+         * @param Status AviaryCommon::Status*
+         * @param File_name std::string
+         * @param File_size int
+         * @param Content std::string
+         * @return newly created GetJobDataResponse object
+         */
+        GetJobDataResponse(AviaryCommon::JobData* arg_Data,AviaryCommon::Status* arg_Status,std::string arg_File_name,int arg_File_size,std::string arg_Content);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for data. 
+         * @return AviaryCommon::JobData*
+         */
+        WSF_EXTERN AviaryCommon::JobData* WSF_CALL
+        getData();
+
+        /**
+         * Setter for data.
+         * @param arg_Data AviaryCommon::JobData*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setData(AviaryCommon::JobData*  arg_Data);
+
+        /**
+         * Re setter for data
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetData();
+        
+        
+
+        /**
+         * Getter for status. 
+         * @return AviaryCommon::Status*
+         */
+        WSF_EXTERN AviaryCommon::Status* WSF_CALL
+        getStatus();
+
+        /**
+         * Setter for status.
+         * @param arg_Status AviaryCommon::Status*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setStatus(AviaryCommon::Status*  arg_Status);
+
+        /**
+         * Re setter for status
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetStatus();
+        
+        
+
+        /**
+         * Getter for file_name. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getFile_name();
+
+        /**
+         * Setter for file_name.
+         * @param arg_File_name std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setFile_name(const std::string  arg_File_name);
+
+        /**
+         * Re setter for file_name
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetFile_name();
+        
+        
+
+        /**
+         * Getter for file_size. 
+         * @return int*
+         */
+        WSF_EXTERN int WSF_CALL
+        getFile_size();
+
+        /**
+         * Setter for file_size.
+         * @param arg_File_size int*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setFile_size(const int  arg_File_size);
+
+        /**
+         * Re setter for file_size
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetFile_size();
+        
+        
+
+        /**
+         * Getter for content. 
+         * @return std::string*
+         */
+        WSF_EXTERN std::string WSF_CALL
+        getContent();
+
+        /**
+         * Setter for content.
+         * @param arg_Content std::string*
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setContent(const std::string  arg_Content);
+
+        /**
+         * Re setter for content
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetContent();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether data is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isDataNil();
+
+
+        
+
+        /**
+         * Check whether status is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isStatusNil();
+
+
+        
+
+        /**
+         * Check whether file_name is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isFile_nameNil();
+
+
+        
+
+        /**
+         * Check whether file_size is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isFile_sizeNil();
+
+
+        
+
+        /**
+         * Check whether content is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isContentNil();
+
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobDataResponse_om_node node to serialize from
+         * @param GetJobDataResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobDataResponse_om_node, axiom_element_t *GetJobDataResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobDataResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for data by property number (1)
+         * @return AviaryCommon::JobData
+         */
+
+        AviaryCommon::JobData* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for status by property number (2)
+         * @return AviaryCommon::Status
+         */
+
+        AviaryCommon::Status* WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for file_name by property number (3)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty3();
+
+    
+        
+
+        /**
+         * Getter for file_size by property number (4)
+         * @return int
+         */
+
+        int WSF_CALL
+        getProperty4();
+
+    
+        
+
+        /**
+         * Getter for content by property number (5)
+         * @return std::string
+         */
+
+        std::string WSF_CALL
+        getProperty5();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBDATARESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetails.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetails.h
new file mode 100644
index 0000000..adcb87a
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetails.h
@@ -0,0 +1,357 @@
+
+
+        #ifndef AviaryQuery_GETJOBDETAILS_H
+        #define AviaryQuery_GETJOBDETAILS_H
+
+       /**
+        * GetJobDetails.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobDetails class
+        */
+
+        namespace AviaryQuery{
+            class GetJobDetails;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobDetails {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobID*>* property_Ids;
+
+                
+                bool isValidIds;
+            bool property_PartialMatches;
+
+                
+                bool isValidPartialMatches;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobDetails
+         */
+
+        GetJobDetails();
+
+        /**
+         * Destructor GetJobDetails
+         */
+        ~GetJobDetails();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobDetails
+         * @param 
+         * @param Ids std::vector<AviaryCommon::JobID*>*
+         * @param PartialMatches bool
+         * @return newly created GetJobDetails object
+         */
+        GetJobDetails(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for ids. Deprecated for array types, Use getIdsAt instead
+         * @return Array of AviaryCommon::JobID*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getIds();
+
+        /**
+         * Setter for ids.Deprecated for array types, Use setIdsAt
+         * or addIds instead.
+         * @param arg_Ids Array of AviaryCommon::JobID*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIds(std::vector<AviaryCommon::JobID*>*  arg_Ids);
+
+        /**
+         * Re setter for ids
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIds();
+        
+        
+
+        /**
+         * Getter for partialMatches. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getPartialMatches();
+
+        /**
+         * Setter for partialMatches.
+         * @param arg_PartialMatches bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPartialMatches(bool  arg_PartialMatches);
+
+        /**
+         * Re setter for partialMatches
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPartialMatches();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of ids.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getIdsAt(int i);
+
+        /**
+         * Set the ith element of ids. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Ids element to set AviaryCommon::JobID* to the array
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdsAt(int i,
+                AviaryCommon::JobID* arg_Ids);
+
+
+        /**
+         * Add to ids.
+         * @param arg_Ids element to add AviaryCommon::JobID* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addIds(
+            AviaryCommon::JobID* arg_Ids);
+
+        /**
+         * Get the size of the ids array.
+         * @return the size of the ids array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofIds();
+
+        /**
+         * Remove the ith element of ids.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeIdsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ids is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNil();
+
+
+        
+
+        /**
+         * Check whether partialMatches is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPartialMatchesNil();
+
+
+        
+        /**
+         * Set partialMatches to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setPartialMatchesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether ids is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNilAt(int i);
+ 
+       
+        /**
+         * Set ids to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIdsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobDetails_om_node node to serialize from
+         * @param GetJobDetails_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobDetails_om_node, axiom_element_t *GetJobDetails_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobDetails is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ids by property number (1)
+         * @return Array of AviaryCommon::JobIDs.
+         */
+
+        std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for partialMatches by property number (2)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBDETAILS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetailsResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetailsResponse.h
new file mode 100644
index 0000000..d8bfb23
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobDetailsResponse.h
@@ -0,0 +1,300 @@
+
+
+        #ifndef AviaryQuery_GETJOBDETAILSRESPONSE_H
+        #define AviaryQuery_GETJOBDETAILSRESPONSE_H
+
+       /**
+        * GetJobDetailsResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobDetailsResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetJobDetailsResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobDetails.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobDetailsResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobDetails*>* property_Jobs;
+
+                
+                bool isValidJobs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobDetailsResponse
+         */
+
+        GetJobDetailsResponse();
+
+        /**
+         * Destructor GetJobDetailsResponse
+         */
+        ~GetJobDetailsResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobDetailsResponse
+         * @param 
+         * @param Jobs std::vector<AviaryCommon::JobDetails*>*
+         * @return newly created GetJobDetailsResponse object
+         */
+        GetJobDetailsResponse(std::vector<AviaryCommon::JobDetails*>* arg_Jobs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for jobs. Deprecated for array types, Use getJobsAt instead
+         * @return Array of AviaryCommon::JobDetails*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobDetails*>* WSF_CALL
+        getJobs();
+
+        /**
+         * Setter for jobs.Deprecated for array types, Use setJobsAt
+         * or addJobs instead.
+         * @param arg_Jobs Array of AviaryCommon::JobDetails*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobs(std::vector<AviaryCommon::JobDetails*>*  arg_Jobs);
+
+        /**
+         * Re setter for jobs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of jobs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobDetails* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobDetails* WSF_CALL
+        getJobsAt(int i);
+
+        /**
+         * Set the ith element of jobs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Jobs element to set AviaryCommon::JobDetails* to the array
+         * @return ith AviaryCommon::JobDetails* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobsAt(int i,
+                AviaryCommon::JobDetails* arg_Jobs);
+
+
+        /**
+         * Add to jobs.
+         * @param arg_Jobs element to add AviaryCommon::JobDetails* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addJobs(
+            AviaryCommon::JobDetails* arg_Jobs);
+
+        /**
+         * Get the size of the jobs array.
+         * @return the size of the jobs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofJobs();
+
+        /**
+         * Remove the ith element of jobs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeJobsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether jobs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether jobs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNilAt(int i);
+ 
+       
+        /**
+         * Set jobs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setJobsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobDetailsResponse_om_node node to serialize from
+         * @param GetJobDetailsResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobDetailsResponse_om_node, axiom_element_t *GetJobDetailsResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobDetailsResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for jobs by property number (1)
+         * @return Array of AviaryCommon::JobDetailss.
+         */
+
+        std::vector<AviaryCommon::JobDetails*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBDETAILSRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatus.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatus.h
new file mode 100644
index 0000000..aa9142f
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatus.h
@@ -0,0 +1,357 @@
+
+
+        #ifndef AviaryQuery_GETJOBSTATUS_H
+        #define AviaryQuery_GETJOBSTATUS_H
+
+       /**
+        * GetJobStatus.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobStatus class
+        */
+
+        namespace AviaryQuery{
+            class GetJobStatus;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobStatus {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobID*>* property_Ids;
+
+                
+                bool isValidIds;
+            bool property_PartialMatches;
+
+                
+                bool isValidPartialMatches;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobStatus
+         */
+
+        GetJobStatus();
+
+        /**
+         * Destructor GetJobStatus
+         */
+        ~GetJobStatus();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobStatus
+         * @param 
+         * @param Ids std::vector<AviaryCommon::JobID*>*
+         * @param PartialMatches bool
+         * @return newly created GetJobStatus object
+         */
+        GetJobStatus(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for ids. Deprecated for array types, Use getIdsAt instead
+         * @return Array of AviaryCommon::JobID*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getIds();
+
+        /**
+         * Setter for ids.Deprecated for array types, Use setIdsAt
+         * or addIds instead.
+         * @param arg_Ids Array of AviaryCommon::JobID*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIds(std::vector<AviaryCommon::JobID*>*  arg_Ids);
+
+        /**
+         * Re setter for ids
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIds();
+        
+        
+
+        /**
+         * Getter for partialMatches. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getPartialMatches();
+
+        /**
+         * Setter for partialMatches.
+         * @param arg_PartialMatches bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPartialMatches(bool  arg_PartialMatches);
+
+        /**
+         * Re setter for partialMatches
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPartialMatches();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of ids.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getIdsAt(int i);
+
+        /**
+         * Set the ith element of ids. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Ids element to set AviaryCommon::JobID* to the array
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdsAt(int i,
+                AviaryCommon::JobID* arg_Ids);
+
+
+        /**
+         * Add to ids.
+         * @param arg_Ids element to add AviaryCommon::JobID* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addIds(
+            AviaryCommon::JobID* arg_Ids);
+
+        /**
+         * Get the size of the ids array.
+         * @return the size of the ids array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofIds();
+
+        /**
+         * Remove the ith element of ids.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeIdsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ids is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNil();
+
+
+        
+
+        /**
+         * Check whether partialMatches is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPartialMatchesNil();
+
+
+        
+        /**
+         * Set partialMatches to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setPartialMatchesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether ids is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNilAt(int i);
+ 
+       
+        /**
+         * Set ids to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIdsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobStatus_om_node node to serialize from
+         * @param GetJobStatus_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobStatus_om_node, axiom_element_t *GetJobStatus_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobStatus is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ids by property number (1)
+         * @return Array of AviaryCommon::JobIDs.
+         */
+
+        std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for partialMatches by property number (2)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBSTATUS_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatusResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatusResponse.h
new file mode 100644
index 0000000..d75adb5
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobStatusResponse.h
@@ -0,0 +1,300 @@
+
+
+        #ifndef AviaryQuery_GETJOBSTATUSRESPONSE_H
+        #define AviaryQuery_GETJOBSTATUSRESPONSE_H
+
+       /**
+        * GetJobStatusResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobStatusResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetJobStatusResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobStatus.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobStatusResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobStatus*>* property_Jobs;
+
+                
+                bool isValidJobs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobStatusResponse
+         */
+
+        GetJobStatusResponse();
+
+        /**
+         * Destructor GetJobStatusResponse
+         */
+        ~GetJobStatusResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobStatusResponse
+         * @param 
+         * @param Jobs std::vector<AviaryCommon::JobStatus*>*
+         * @return newly created GetJobStatusResponse object
+         */
+        GetJobStatusResponse(std::vector<AviaryCommon::JobStatus*>* arg_Jobs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for jobs. Deprecated for array types, Use getJobsAt instead
+         * @return Array of AviaryCommon::JobStatus*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobStatus*>* WSF_CALL
+        getJobs();
+
+        /**
+         * Setter for jobs.Deprecated for array types, Use setJobsAt
+         * or addJobs instead.
+         * @param arg_Jobs Array of AviaryCommon::JobStatus*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobs(std::vector<AviaryCommon::JobStatus*>*  arg_Jobs);
+
+        /**
+         * Re setter for jobs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of jobs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobStatus* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobStatus* WSF_CALL
+        getJobsAt(int i);
+
+        /**
+         * Set the ith element of jobs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Jobs element to set AviaryCommon::JobStatus* to the array
+         * @return ith AviaryCommon::JobStatus* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobsAt(int i,
+                AviaryCommon::JobStatus* arg_Jobs);
+
+
+        /**
+         * Add to jobs.
+         * @param arg_Jobs element to add AviaryCommon::JobStatus* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addJobs(
+            AviaryCommon::JobStatus* arg_Jobs);
+
+        /**
+         * Get the size of the jobs array.
+         * @return the size of the jobs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofJobs();
+
+        /**
+         * Remove the ith element of jobs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeJobsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether jobs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether jobs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNilAt(int i);
+ 
+       
+        /**
+         * Set jobs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setJobsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobStatusResponse_om_node node to serialize from
+         * @param GetJobStatusResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobStatusResponse_om_node, axiom_element_t *GetJobStatusResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobStatusResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for jobs by property number (1)
+         * @return Array of AviaryCommon::JobStatuss.
+         */
+
+        std::vector<AviaryCommon::JobStatus*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBSTATUSRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummary.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummary.h
new file mode 100644
index 0000000..9751a88
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummary.h
@@ -0,0 +1,357 @@
+
+
+        #ifndef AviaryQuery_GETJOBSUMMARY_H
+        #define AviaryQuery_GETJOBSUMMARY_H
+
+       /**
+        * GetJobSummary.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobSummary class
+        */
+
+        namespace AviaryQuery{
+            class GetJobSummary;
+        }
+        
+
+        
+       #include "AviaryCommon_JobID.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobSummary {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobID*>* property_Ids;
+
+                
+                bool isValidIds;
+            bool property_PartialMatches;
+
+                
+                bool isValidPartialMatches;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobSummary
+         */
+
+        GetJobSummary();
+
+        /**
+         * Destructor GetJobSummary
+         */
+        ~GetJobSummary();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobSummary
+         * @param 
+         * @param Ids std::vector<AviaryCommon::JobID*>*
+         * @param PartialMatches bool
+         * @return newly created GetJobSummary object
+         */
+        GetJobSummary(std::vector<AviaryCommon::JobID*>* arg_Ids,bool arg_PartialMatches);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for ids. Deprecated for array types, Use getIdsAt instead
+         * @return Array of AviaryCommon::JobID*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getIds();
+
+        /**
+         * Setter for ids.Deprecated for array types, Use setIdsAt
+         * or addIds instead.
+         * @param arg_Ids Array of AviaryCommon::JobID*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIds(std::vector<AviaryCommon::JobID*>*  arg_Ids);
+
+        /**
+         * Re setter for ids
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIds();
+        
+        
+
+        /**
+         * Getter for partialMatches. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getPartialMatches();
+
+        /**
+         * Setter for partialMatches.
+         * @param arg_PartialMatches bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPartialMatches(bool  arg_PartialMatches);
+
+        /**
+         * Re setter for partialMatches
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPartialMatches();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of ids.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobID* WSF_CALL
+        getIdsAt(int i);
+
+        /**
+         * Set the ith element of ids. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Ids element to set AviaryCommon::JobID* to the array
+         * @return ith AviaryCommon::JobID* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdsAt(int i,
+                AviaryCommon::JobID* arg_Ids);
+
+
+        /**
+         * Add to ids.
+         * @param arg_Ids element to add AviaryCommon::JobID* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addIds(
+            AviaryCommon::JobID* arg_Ids);
+
+        /**
+         * Get the size of the ids array.
+         * @return the size of the ids array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofIds();
+
+        /**
+         * Remove the ith element of ids.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeIdsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ids is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNil();
+
+
+        
+
+        /**
+         * Check whether partialMatches is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPartialMatchesNil();
+
+
+        
+        /**
+         * Set partialMatches to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setPartialMatchesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether ids is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNilAt(int i);
+ 
+       
+        /**
+         * Set ids to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIdsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobSummary_om_node node to serialize from
+         * @param GetJobSummary_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobSummary_om_node, axiom_element_t *GetJobSummary_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobSummary is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ids by property number (1)
+         * @return Array of AviaryCommon::JobIDs.
+         */
+
+        std::vector<AviaryCommon::JobID*>* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for partialMatches by property number (2)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty2();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBSUMMARY_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummaryResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummaryResponse.h
new file mode 100644
index 0000000..5946d52
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetJobSummaryResponse.h
@@ -0,0 +1,300 @@
+
+
+        #ifndef AviaryQuery_GETJOBSUMMARYRESPONSE_H
+        #define AviaryQuery_GETJOBSUMMARYRESPONSE_H
+
+       /**
+        * GetJobSummaryResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetJobSummaryResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetJobSummaryResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_JobSummary.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetJobSummaryResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::JobSummary*>* property_Jobs;
+
+                
+                bool isValidJobs;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setJobsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetJobSummaryResponse
+         */
+
+        GetJobSummaryResponse();
+
+        /**
+         * Destructor GetJobSummaryResponse
+         */
+        ~GetJobSummaryResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetJobSummaryResponse
+         * @param 
+         * @param Jobs std::vector<AviaryCommon::JobSummary*>*
+         * @return newly created GetJobSummaryResponse object
+         */
+        GetJobSummaryResponse(std::vector<AviaryCommon::JobSummary*>* arg_Jobs);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for jobs. Deprecated for array types, Use getJobsAt instead
+         * @return Array of AviaryCommon::JobSummary*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+        getJobs();
+
+        /**
+         * Setter for jobs.Deprecated for array types, Use setJobsAt
+         * or addJobs instead.
+         * @param arg_Jobs Array of AviaryCommon::JobSummary*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobs(std::vector<AviaryCommon::JobSummary*>*  arg_Jobs);
+
+        /**
+         * Re setter for jobs
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetJobs();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of jobs.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::JobSummary* of the array
+         */
+        WSF_EXTERN AviaryCommon::JobSummary* WSF_CALL
+        getJobsAt(int i);
+
+        /**
+         * Set the ith element of jobs. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Jobs element to set AviaryCommon::JobSummary* to the array
+         * @return ith AviaryCommon::JobSummary* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setJobsAt(int i,
+                AviaryCommon::JobSummary* arg_Jobs);
+
+
+        /**
+         * Add to jobs.
+         * @param arg_Jobs element to add AviaryCommon::JobSummary* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addJobs(
+            AviaryCommon::JobSummary* arg_Jobs);
+
+        /**
+         * Get the size of the jobs array.
+         * @return the size of the jobs array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofJobs();
+
+        /**
+         * Remove the ith element of jobs.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeJobsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether jobs is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether jobs is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isJobsNilAt(int i);
+ 
+       
+        /**
+         * Set jobs to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setJobsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetJobSummaryResponse_om_node node to serialize from
+         * @param GetJobSummaryResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetJobSummaryResponse_om_node, axiom_element_t *GetJobSummaryResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetJobSummaryResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for jobs by property number (1)
+         * @return Array of AviaryCommon::JobSummarys.
+         */
+
+        std::vector<AviaryCommon::JobSummary*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* GETJOBSUMMARYRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummary.h b/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummary.h
new file mode 100644
index 0000000..0085561
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummary.h
@@ -0,0 +1,414 @@
+
+
+        #ifndef AviaryQuery_GETSUBMISSIONSUMMARY_H
+        #define AviaryQuery_GETSUBMISSIONSUMMARY_H
+
+       /**
+        * GetSubmissionSummary.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetSubmissionSummary class
+        */
+
+        namespace AviaryQuery{
+            class GetSubmissionSummary;
+        }
+        
+
+        
+       #include "AviaryCommon_SubmissionID.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetSubmissionSummary {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::SubmissionID*>* property_Ids;
+
+                
+                bool isValidIds;
+            bool property_PartialMatches;
+
+                
+                bool isValidPartialMatches;
+            bool property_IncludeJobSummaries;
+
+                
+                bool isValidIncludeJobSummaries;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setIdsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetSubmissionSummary
+         */
+
+        GetSubmissionSummary();
+
+        /**
+         * Destructor GetSubmissionSummary
+         */
+        ~GetSubmissionSummary();
+
+
+       
+
+        /**
+         * Constructor for creating GetSubmissionSummary
+         * @param 
+         * @param Ids std::vector<AviaryCommon::SubmissionID*>*
+         * @param PartialMatches bool
+         * @param IncludeJobSummaries bool
+         * @return newly created GetSubmissionSummary object
+         */
+        GetSubmissionSummary(std::vector<AviaryCommon::SubmissionID*>* arg_Ids,bool arg_PartialMatches,bool arg_IncludeJobSummaries);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for ids. Deprecated for array types, Use getIdsAt instead
+         * @return Array of AviaryCommon::SubmissionID*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::SubmissionID*>* WSF_CALL
+        getIds();
+
+        /**
+         * Setter for ids.Deprecated for array types, Use setIdsAt
+         * or addIds instead.
+         * @param arg_Ids Array of AviaryCommon::SubmissionID*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIds(std::vector<AviaryCommon::SubmissionID*>*  arg_Ids);
+
+        /**
+         * Re setter for ids
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIds();
+        
+        
+
+        /**
+         * Getter for partialMatches. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getPartialMatches();
+
+        /**
+         * Setter for partialMatches.
+         * @param arg_PartialMatches bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setPartialMatches(bool  arg_PartialMatches);
+
+        /**
+         * Re setter for partialMatches
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetPartialMatches();
+        
+        
+
+        /**
+         * Getter for includeJobSummaries. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getIncludeJobSummaries();
+
+        /**
+         * Setter for includeJobSummaries.
+         * @param arg_IncludeJobSummaries bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIncludeJobSummaries(bool  arg_IncludeJobSummaries);
+
+        /**
+         * Re setter for includeJobSummaries
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetIncludeJobSummaries();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of ids.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::SubmissionID* of the array
+         */
+        WSF_EXTERN AviaryCommon::SubmissionID* WSF_CALL
+        getIdsAt(int i);
+
+        /**
+         * Set the ith element of ids. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Ids element to set AviaryCommon::SubmissionID* to the array
+         * @return ith AviaryCommon::SubmissionID* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setIdsAt(int i,
+                AviaryCommon::SubmissionID* arg_Ids);
+
+
+        /**
+         * Add to ids.
+         * @param arg_Ids element to add AviaryCommon::SubmissionID* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addIds(
+            AviaryCommon::SubmissionID* arg_Ids);
+
+        /**
+         * Get the size of the ids array.
+         * @return the size of the ids array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofIds();
+
+        /**
+         * Remove the ith element of ids.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeIdsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether ids is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNil();
+
+
+        
+
+        /**
+         * Check whether partialMatches is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isPartialMatchesNil();
+
+
+        
+        /**
+         * Set partialMatches to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setPartialMatchesNil();
+        
+
+        /**
+         * Check whether includeJobSummaries is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isIncludeJobSummariesNil();
+
+
+        
+        /**
+         * Set includeJobSummaries to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIncludeJobSummariesNil();
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether ids is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isIdsNilAt(int i);
+ 
+       
+        /**
+         * Set ids to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setIdsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetSubmissionSummary_om_node node to serialize from
+         * @param GetSubmissionSummary_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetSubmissionSummary_om_node, axiom_element_t *GetSubmissionSummary_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetSubmissionSummary is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for ids by property number (1)
+         * @return Array of AviaryCommon::SubmissionIDs.
+         */
+
+        std::vector<AviaryCommon::SubmissionID*>* WSF_CALL
+        getProperty1();
+
+    
+        
+
+        /**
+         * Getter for partialMatches by property number (2)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty2();
+
+    
+        
+
+        /**
+         * Getter for includeJobSummaries by property number (3)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty3();
+
+    
+
+};
+
+}        
+ #endif /* GETSUBMISSIONSUMMARY_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummaryResponse.h b/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummaryResponse.h
new file mode 100644
index 0000000..36b5a9e
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_GetSubmissionSummaryResponse.h
@@ -0,0 +1,300 @@
+
+
+        #ifndef AviaryQuery_GETSUBMISSIONSUMMARYRESPONSE_H
+        #define AviaryQuery_GETSUBMISSIONSUMMARYRESPONSE_H
+
+       /**
+        * GetSubmissionSummaryResponse.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  GetSubmissionSummaryResponse class
+        */
+
+        namespace AviaryQuery{
+            class GetSubmissionSummaryResponse;
+        }
+        
+
+        
+       #include "AviaryCommon_SubmissionSummary.h"
+          
+        #include <axutil_qname.h>
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class GetSubmissionSummaryResponse {
+
+        private:
+             
+                axutil_qname_t* qname;
+            std::vector<AviaryCommon::SubmissionSummary*>* property_Submissions;
+
+                
+                bool isValidSubmissions;
+            
+
+        /*** Private methods ***/
+          
+
+        bool WSF_CALL
+        setSubmissionsNil();
+            
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class GetSubmissionSummaryResponse
+         */
+
+        GetSubmissionSummaryResponse();
+
+        /**
+         * Destructor GetSubmissionSummaryResponse
+         */
+        ~GetSubmissionSummaryResponse();
+
+
+       
+
+        /**
+         * Constructor for creating GetSubmissionSummaryResponse
+         * @param 
+         * @param Submissions std::vector<AviaryCommon::SubmissionSummary*>*
+         * @return newly created GetSubmissionSummaryResponse object
+         */
+        GetSubmissionSummaryResponse(std::vector<AviaryCommon::SubmissionSummary*>* arg_Submissions);
+        
+        
+        /********************************** Class get set methods **************************************/
+        /******** Deprecated for array types, Use 'Getters and Setters for Arrays' instead ***********/
+        
+
+        /**
+         * Getter for submissions. Deprecated for array types, Use getSubmissionsAt instead
+         * @return Array of AviaryCommon::SubmissionSummary*s.
+         */
+        WSF_EXTERN std::vector<AviaryCommon::SubmissionSummary*>* WSF_CALL
+        getSubmissions();
+
+        /**
+         * Setter for submissions.Deprecated for array types, Use setSubmissionsAt
+         * or addSubmissions instead.
+         * @param arg_Submissions Array of AviaryCommon::SubmissionSummary*s.
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubmissions(std::vector<AviaryCommon::SubmissionSummary*>*  arg_Submissions);
+
+        /**
+         * Re setter for submissions
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetSubmissions();
+        
+        /****************************** Get Set methods for Arrays **********************************/
+        /************ Array Specific Operations: get_at, set_at, add, remove_at, sizeof *****************/
+
+        /**
+         * E.g. use of get_at, set_at, add and sizeof
+         *
+         * for(i = 0; i < adb_element->sizeofProperty(); i ++ )
+         * {
+         *     // Getting ith value to property_object variable
+         *     property_object = adb_element->getPropertyAt(i);
+         *
+         *     // Setting ith value from property_object variable
+         *     adb_element->setPropertyAt(i, property_object);
+         *
+         *     // Appending the value to the end of the array from property_object variable
+         *     adb_element->addProperty(property_object);
+         *
+         *     // Removing the ith value from an array
+         *     adb_element->removePropertyAt(i);
+         *     
+         * }
+         *
+         */
+
+        
+        
+        /**
+         * Get the ith element of submissions.
+        * @param i index of the item to be obtained
+         * @return ith AviaryCommon::SubmissionSummary* of the array
+         */
+        WSF_EXTERN AviaryCommon::SubmissionSummary* WSF_CALL
+        getSubmissionsAt(int i);
+
+        /**
+         * Set the ith element of submissions. (If the ith already exist, it will be replaced)
+         * @param i index of the item to return
+         * @param arg_Submissions element to set AviaryCommon::SubmissionSummary* to the array
+         * @return ith AviaryCommon::SubmissionSummary* of the array
+         */
+        WSF_EXTERN bool WSF_CALL
+        setSubmissionsAt(int i,
+                AviaryCommon::SubmissionSummary* arg_Submissions);
+
+
+        /**
+         * Add to submissions.
+         * @param arg_Submissions element to add AviaryCommon::SubmissionSummary* to the array
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        addSubmissions(
+            AviaryCommon::SubmissionSummary* arg_Submissions);
+
+        /**
+         * Get the size of the submissions array.
+         * @return the size of the submissions array.
+         */
+        WSF_EXTERN int WSF_CALL
+        sizeofSubmissions();
+
+        /**
+         * Remove the ith element of submissions.
+         * @param i index of the item to remove
+         * @return true on success, false otherwise.
+         */
+        WSF_EXTERN bool WSF_CALL
+        removeSubmissionsAt(int i);
+
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        /* Use 'Checking and Setting NIL values for Arrays' to check and set nil for individual elements */
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether submissions is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isSubmissionsNil();
+
+
+        
+
+        /*************************** Checking and Setting 'NIL' values in Arrays *****************************/
+
+        /**
+         * NOTE: You may set this to remove specific elements in the array
+         *       But you can not remove elements, if the specific property is declared to be non-nillable or sizeof(array) < minOccurs
+         */
+        
+        /**
+         * Check whether submissions is Nill at position i
+         * @param i index of the item to return.
+         * @return true if the value is Nil at position i, false otherwise
+         */
+        bool WSF_CALL
+        isSubmissionsNilAt(int i);
+ 
+       
+        /**
+         * Set submissions to NILL at the  position i.
+         * @param i . The index of the item to be set Nill.
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setSubmissionsNilAt(int i);
+
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param GetSubmissionSummaryResponse_om_node node to serialize from
+         * @param GetSubmissionSummaryResponse_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* GetSubmissionSummaryResponse_om_node, axiom_element_t *GetSubmissionSummaryResponse_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the GetSubmissionSummaryResponse is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for submissions by property number (1)
+         * @return Array of AviaryCommon::SubmissionSummarys.
+         */
+
+        std::vector<AviaryCommon::SubmissionSummary*>* WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* GETSUBMISSIONSUMMARYRESPONSE_H */
+    
+
diff --git a/src/condor_contrib/aviary/include/AviaryQuery_QueryRequestType.h b/src/condor_contrib/aviary/include/AviaryQuery_QueryRequestType.h
new file mode 100644
index 0000000..40de943
--- /dev/null
+++ b/src/condor_contrib/aviary/include/AviaryQuery_QueryRequestType.h
@@ -0,0 +1,200 @@
+
+
+        #ifndef AviaryQuery_QUERYREQUESTTYPE_H
+        #define AviaryQuery_QUERYREQUESTTYPE_H
+
+       /**
+        * QueryRequestType.h
+        *
+        * This file was auto-generated from WSDL
+        * by the Apache Axis2/Java version: 1.0  Built on : Mar 02, 2011 (11:54:00 EST)
+        */
+
+       /**
+        *  QueryRequestType class
+        */
+
+        namespace AviaryQuery{
+            class QueryRequestType;
+        }
+        
+
+        
+
+        #include <stdio.h>
+        #include <OMElement.h>
+        #include <ServiceClient.h>
+        #include <ADBDefines.h>
+
+namespace AviaryQuery
+{
+        
+        
+
+        class QueryRequestType {
+
+        private:
+             bool property_AllowPartialMatching;
+
+                
+                bool isValidAllowPartialMatching;
+            
+
+        /*** Private methods ***/
+          
+
+
+
+        /******************************* public functions *********************************/
+
+        public:
+
+        /**
+         * Constructor for class QueryRequestType
+         */
+
+        QueryRequestType();
+
+        /**
+         * Destructor QueryRequestType
+         */
+        ~QueryRequestType();
+
+
+       
+
+        /**
+         * Constructor for creating QueryRequestType
+         * @param 
+         * @param AllowPartialMatching bool
+         * @return newly created QueryRequestType object
+         */
+        QueryRequestType(bool arg_AllowPartialMatching);
+        
+        
+        /********************************** Class get set methods **************************************/
+        
+        
+
+        /**
+         * Getter for allowPartialMatching. 
+         * @return bool
+         */
+        WSF_EXTERN bool WSF_CALL
+        getAllowPartialMatching();
+
+        /**
+         * Setter for allowPartialMatching.
+         * @param arg_AllowPartialMatching bool
+         * @return true on success, false otherwise
+         */
+        WSF_EXTERN bool WSF_CALL
+        setAllowPartialMatching(bool  arg_AllowPartialMatching);
+
+        /**
+         * Re setter for allowPartialMatching
+         * @return true on success, false
+         */
+        WSF_EXTERN bool WSF_CALL
+        resetAllowPartialMatching();
+        
+
+
+        /******************************* Checking and Setting NIL values *********************************/
+        
+
+        /**
+         * NOTE: set_nil is only available for nillable properties
+         */
+
+        
+
+        /**
+         * Check whether allowPartialMatching is Nill
+         * @return true if the element is Nil, false otherwise
+         */
+        bool WSF_CALL
+        isAllowPartialMatchingNil();
+
+
+        
+        /**
+         * Set allowPartialMatching to Nill (same as using reset)
+         * @return true on success, false otherwise.
+         */
+        bool WSF_CALL
+        setAllowPartialMatchingNil();
+        
+
+        /**************************** Serialize and De serialize functions ***************************/
+        /*********** These functions are for use only inside the generated code *********************/
+
+        
+        /**
+         * Deserialize the ADB object to an XML
+         * @param dp_parent double pointer to the parent node to be deserialized
+         * @param dp_is_early_node_valid double pointer to a flag (is_early_node_valid?)
+         * @param dont_care_minoccurs Dont set errors on validating minoccurs, 
+         *              (Parent will order this in a case of choice)
+         * @return true on success, false otherwise
+         */
+        bool WSF_CALL
+        deserialize(axiom_node_t** omNode, bool *isEarlyNodeValid, bool dontCareMinoccurs);
+                         
+            
+
+       /**
+         * Declare namespace in the most parent node 
+         * @param parent_element parent element
+         * @param namespaces hash of namespace uri to prefix
+         * @param next_ns_index pointer to an int which contain the next namespace index
+         */
+        void WSF_CALL
+        declareParentNamespaces(axiom_element_t *parent_element, axutil_hash_t *namespaces, int *next_ns_index);
+
+
+        
+
+        /**
+         * Serialize the ADB object to an xml
+         * @param QueryRequestType_om_node node to serialize from
+         * @param QueryRequestType_om_element parent element to serialize from
+         * @param tag_closed Whether the parent tag is closed or not
+         * @param namespaces hash of namespace uris to prefixes
+         * @param next_ns_index an int which contains the next namespace index
+         * @return axiom_node_t on success,NULL otherwise.
+         */
+        axiom_node_t* WSF_CALL
+        serialize(axiom_node_t* QueryRequestType_om_node, axiom_element_t *QueryRequestType_om_element, int tag_closed, axutil_hash_t *namespaces, int *next_ns_index);
+
+        /**
+         * Check whether the QueryRequestType is a particle class (E.g. group, inner sequence)
+         * @return true if this is a particle class, false otherwise.
+         */
+        bool WSF_CALL
+        isParticle();
+
+
+
+        /******************************* get the value by the property number  *********************************/
+        /************NOTE: This method is introduced to resolve a problem in unwrapping mode *******************/
+
+      
+        
+
+        /**
+         * Getter for allowPartialMatching by property number (1)
+         * @return bool
+         */
+
+        bool WSF_CALL
+        getProperty1();
+
+    
+
+};
+
+}        
+ #endif /* QUERYREQUESTTYPE_H */
+    
+
diff --git a/src/condor_contrib/aviary/license.txt b/src/condor_contrib/aviary/license.txt
new file mode 100644
index 0000000..046ad71
--- /dev/null
+++ b/src/condor_contrib/aviary/license.txt
@@ -0,0 +1,14 @@
+Copyright 2009-2011 Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
diff --git a/src/condor_contrib/aviary/services/job/services.xml b/src/condor_contrib/aviary/services/job/services.xml
new file mode 100644
index 0000000..ab94581
--- /dev/null
+++ b/src/condor_contrib/aviary/services/job/services.xml
@@ -0,0 +1,26 @@
+<!-- This file was auto-generated from WSDL -->
+<!-- by the Apache Axis2 version: 1.0  Built on : Jan 09, 2011 (11:40:28 EST) -->
+<service name="AviaryJobService">
+<parameter name="ServiceClass" locked="xsd:false">aviary_job_axis</parameter>
+<description>AviaryJobServiceService</description>
+<operation name="submitJob" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#submit</parameter>
+</operation>
+<operation name="holdJob" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#hold</parameter>
+</operation>
+<operation name="releaseJob" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#release</parameter>
+</operation>
+<operation name="removeJob" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#remove</parameter>
+</operation>
+<operation name="setJobAttribute" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">job#setattr</parameter>
+</operation>
+</service>
diff --git a/src/condor_contrib/aviary/services/query/services.xml b/src/condor_contrib/aviary/services/query/services.xml
new file mode 100644
index 0000000..b516976a
--- /dev/null
+++ b/src/condor_contrib/aviary/services/query/services.xml
@@ -0,0 +1,26 @@
+<!-- This file was auto-generated from WSDL -->
+<!-- by the Apache Axis2 version: 1.0  Built on : Mar 02, 2011 (11:53:41 EST) -->
+<service name="AviaryQueryService">
+<parameter name="ServiceClass" locked="xsd:false">aviary_query_axis</parameter>
+<description>AviaryQueryServiceService</description>
+<operation name="getJobSummary" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#summary</parameter>
+</operation>
+<operation name="getJobStatus" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#status</parameter>
+</operation>
+<operation name="getJobDetails" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#details</parameter>
+</operation>
+<operation name="getJobData" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#data</parameter>
+</operation>
+<operation name="getSubmissionSummary" mep="http://www.w3.org/2004/08/wsdl/in-out">
+<messageReceiver class="libwsf_cpp_msg_recv.so.0"/>
+<parameter name="wsamapping">query#submission</parameter>
+</operation>
+</service>
diff --git a/src/condor_contrib/aviary/src/AviaryConversionMacros.h b/src/condor_contrib/aviary/src/AviaryConversionMacros.h
new file mode 100644
index 0000000..f809e75
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryConversionMacros.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVIARY_CONVERSION_MACROS_H
+#define AVIARY_CONVERSION_MACROS_H
+
+#define MGMT_DECLARATIONS	\
+ExprTree *expr;				\
+int num;					\
+float flt;					\
+char *str;					\
+(void)expr;(void)num;(void)flt;(void)str;
+
+
+#define BASE(attr,type,lookup_var,set_var,extra)					\
+if (ad.Lookup##type(#attr, lookup_var)) {							\
+	m_stats.attr = ((set_var) extra);						\
+} else {															\
+	dprintf(D_FULLDEBUG, "Warning: Could not find " #attr "\n");		\
+}
+
+#define OPT_BASE(attr,type,lookup_var,set_var,extra)				\
+if (ad.Lookup##type(#attr, lookup_var)) {							\
+	m_stats.attr = ((set_var) extra);						\
+} else {															\
+	m_stats.attr = "";										\
+}
+
+#define STRING(attr)												\
+if (ad.LookupString(#attr, &str)) {									\
+	m_stats.attr = str;									\
+	free(str);														\
+} else {															\
+	dprintf(D_FULLDEBUG, "Warning: Could not find " #attr "\n");		\
+}
+
+#define OPT_STRING(attr)												\
+if (ad.LookupString(#attr, &str)) {									\
+	m_stats.attr = str;									\
+	free(str);														\
+} else {															\
+	m_stats.attr = "";										\
+}
+
+#define INTEGER(attr) BASE(attr,Integer,num,(uint32_t) num,)
+#define OPT_INTEGER(attr) OPT_BASE(attr,Integer,num,(uint32_t) num,)
+#define DOUBLE(attr) BASE(attr,Float,flt,(double) flt,)
+#define OPT_DOUBLE(attr) OPT_BASE(attr,Float,flt,(double) flt,)
+#define TIME_INTEGER(attr) BASE(attr,Integer,num,(uint64_t) num,* 1000000000)
+#define OPT_TIME_INTEGER(attr) OPT_BASE(attr,Integer,num,(uint64_t) num,* 1000000000)
+
+#define EXPR(attr)													\
+	EXPR_BASE(attr,													\
+			  dprintf(D_FULLDEBUG, "Warning: " #attr " not found\n"))
+
+#define OPT_EXPR(attr)											 	\
+	EXPR_BASE(attr,													\
+			  m_stats.attr = "")
+
+#define EXPR_BASE(attr,else_action)									\
+expr = ad.Lookup(#attr);											\
+if (expr) {                                                         \
+      str = const_cast<char*>(ExprTreeToString(expr));              \
+      m_stats.attr = str;                             \
+} else {                                                         \
+      dprintf(D_FULLDEBUG, "Warning: " #attr " has no value\n");    	\
+}
+
+#endif /* AVIARY_CONVERSION_MACROS_H */
diff --git a/src/condor_contrib/aviary/src/AviaryJobService.cpp b/src/condor_contrib/aviary/src/AviaryJobService.cpp
new file mode 100644
index 0000000..ee80c5e
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobService.cpp
@@ -0,0 +1,356 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+        #include "AviaryJobServiceSkeleton.h"
+        #include "AviaryJobService.h"  
+        #include <ServiceSkeleton.h>
+        #include <stdio.h>
+        #include <axis2_svc.h>
+        #include <Environment.h>
+        #include <axiom_soap.h>
+
+
+        using namespace wso2wsf;
+        
+        using namespace AviaryJob;
+        
+
+        /** Load the service into axis2 engine */
+        WSF_SERVICE_INIT(AviaryJobService)
+
+          
+         /**
+          * function to free any soap input headers
+          */
+         AviaryJobService::AviaryJobService()
+	{
+          skel = wsfGetAviaryJobServiceSkeleton();
+    }
+
+
+	void WSF_CALL
+	AviaryJobService::init()
+	{
+
+      return;
+	}
+
+
+	AviaryJobService::~AviaryJobService()
+	{
+    }
+
+
+     
+
+     
+
+
+
+
+	/*
+	 * This method invokes the right service method
+	 */
+	OMElement* WSF_CALL
+	AviaryJobService::invoke(OMElement *omEle, MessageContext *msgCtx)
+	{
+         /* Using the function name, invoke the corresponding method
+          */
+
+          axis2_op_ctx_t *operation_ctx = NULL;
+          axis2_op_t *operation = NULL;
+          axutil_qname_t *op_qname = NULL;
+          axis2_char_t *op_name = NULL;
+          axis2_msg_ctx_t *in_msg_ctx = NULL;
+          
+          axiom_soap_envelope_t *req_soap_env = NULL;
+          axiom_soap_header_t *req_soap_header = NULL;
+          axiom_soap_envelope_t *res_soap_env = NULL;
+          axiom_soap_header_t *res_soap_header = NULL;
+
+          axiom_node_t *ret_node = NULL;
+          axiom_node_t *input_header = NULL;
+          axiom_node_t *output_header = NULL;
+          axiom_node_t *header_base_node = NULL;
+          axis2_msg_ctx_t *msg_ctx = NULL;
+          axiom_node_t* content_node = omEle->getAxiomNode();
+
+          
+            AviaryJob::RemoveJobResponse* ret_val1;
+            AviaryJob::RemoveJob* input_val1;
+            
+            AviaryJob::ReleaseJobResponse* ret_val2;
+            AviaryJob::ReleaseJob* input_val2;
+            
+            AviaryJob::SubmitJobResponse* ret_val3;
+            AviaryJob::SubmitJob* input_val3;
+            
+            AviaryJob::HoldJobResponse* ret_val4;
+            AviaryJob::HoldJob* input_val4;
+            
+            AviaryJob::SetJobAttributeResponse* ret_val5;
+            AviaryJob::SetJobAttribute* input_val5;
+            
+       
+          msg_ctx = msgCtx->getAxis2MessageContext();
+          operation_ctx = axis2_msg_ctx_get_op_ctx(msg_ctx, Environment::getEnv());
+          operation = axis2_op_ctx_get_op(operation_ctx, Environment::getEnv());
+          op_qname = (axutil_qname_t *)axis2_op_get_qname(operation, Environment::getEnv());
+          op_name = axutil_qname_get_localpart(op_qname, Environment::getEnv());
+
+          if (op_name)
+          {
+               
+
+                if ( axutil_strcmp(op_name, "removeJob") == 0 )
+                {
+
+                    
+                    input_val1 =
+                        
+                        new AviaryJob::RemoveJob();
+                        if( AXIS2_FAILURE ==  input_val1->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::RemoveJob_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val1 =  skel->removeJob(msgCtx ,input_val1);
+                    
+                        if ( NULL == ret_val1 )
+                        {
+                            
+                                delete input_val1;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val1->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val1;
+                                        
+                                            delete input_val1;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "releaseJob") == 0 )
+                {
+
+                    
+                    input_val2 =
+                        
+                        new AviaryJob::ReleaseJob();
+                        if( AXIS2_FAILURE ==  input_val2->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::ReleaseJob_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val2 =  skel->releaseJob(msgCtx ,input_val2);
+                    
+                        if ( NULL == ret_val2 )
+                        {
+                            
+                                delete input_val2;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val2->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val2;
+                                        
+                                            delete input_val2;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "submitJob") == 0 )
+                {
+
+                    
+                    input_val3 =
+                        
+                        new AviaryJob::SubmitJob();
+                        if( AXIS2_FAILURE ==  input_val3->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::SubmitJob_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val3 =  skel->submitJob(msgCtx ,input_val3);
+                    
+                        if ( NULL == ret_val3 )
+                        {
+                            
+                                delete input_val3;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val3->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val3;
+                                        
+                                            delete input_val3;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "holdJob") == 0 )
+                {
+
+                    
+                    input_val4 =
+                        
+                        new AviaryJob::HoldJob();
+                        if( AXIS2_FAILURE ==  input_val4->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::HoldJob_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val4 =  skel->holdJob(msgCtx ,input_val4);
+                    
+                        if ( NULL == ret_val4 )
+                        {
+                            
+                                delete input_val4;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val4->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val4;
+                                        
+                                            delete input_val4;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "setJobAttribute") == 0 )
+                {
+
+                    
+                    input_val5 =
+                        
+                        new AviaryJob::SetJobAttribute();
+                        if( AXIS2_FAILURE ==  input_val5->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryJob::SetJobAttribute_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryJobServiceSkeleton skel;
+                        ret_val5 =  skel->setJobAttribute(msgCtx ,input_val5);
+                    
+                        if ( NULL == ret_val5 )
+                        {
+                            
+                                delete input_val5;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val5->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val5;
+                                        
+                                            delete input_val5;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+             }
+            
+          AXIS2_LOG_ERROR(Environment::getEnv()->log, AXIS2_LOG_SI, "AviaryJobService service ERROR: invalid OM parameters in request\n");
+          return NULL;
+    }
+
+    OMElement* WSF_CALL
+    AviaryJobService::onFault(OMElement* omEle)
+	{
+		axiom_node_t *error_node = NULL;
+		axiom_element_t *error_ele = NULL;
+        axutil_error_codes_t error_code;
+        axiom_node_t *node = omEle->getAxiomNode();
+        error_code = (axutil_error_codes_t)Environment::getEnv()->error->error_number;
+
+        if(error_code <= AVIARYJOBSERVICESKELETON_ERROR_NONE ||
+                error_code >= AVIARYJOBSERVICESKELETON_ERROR_LAST )
+        {
+            error_ele = axiom_element_create(Environment::getEnv(), node, "fault", NULL,
+                            &error_node);
+            axiom_element_set_text(error_ele, Environment::getEnv(), "AviaryJobService|http://grid.redhat.com/aviary-job/ failed",
+                            error_node);
+        }
+        
+
+		return new OMElement(NULL,error_node);
+	}
+
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryJobService.h b/src/condor_contrib/aviary/src/AviaryJobService.h
new file mode 100644
index 0000000..7e0be8b
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobService.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+          #ifndef AVIARYJOBSERVICE_H
+          #define AVIARYJOBSERVICE_H
+
+#include <ServiceSkeleton.h>
+#include <stdio.h>
+#include <axis2_svc.h>
+
+using namespace wso2wsf;
+
+
+using namespace AviaryJob;
+
+
+
+#define WSF_SERVICE_SKEL_INIT(class_name) \
+AviaryJobServiceSkeleton* wsfGetAviaryJobServiceSkeleton(){ return new class_name(); }
+
+AviaryJobServiceSkeleton* wsfGetAviaryJobServiceSkeleton(); 
+
+
+
+        class AviaryJobService : public ServiceSkeleton
+        {
+            private:
+                AviaryJobServiceSkeleton *skel;
+
+            public:
+
+               union {
+                     
+               } fault;
+
+
+              WSF_EXTERN WSF_CALL AviaryJobService();
+
+              OMElement* WSF_CALL invoke(OMElement *message, MessageContext *msgCtx);
+
+              OMElement* WSF_CALL onFault(OMElement *message);
+
+              void WSF_CALL init();
+
+              ~AviaryJobService(); 
+      };
+
+
+
+#endif    //     AVIARYJOBSERVICE_H
+
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryJobServiceMacro.cpp b/src/condor_contrib/aviary/src/AviaryJobServiceMacro.cpp
new file mode 100644
index 0000000..76fc6cb
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobServiceMacro.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include "AviaryJobServiceSkeleton.h"
+#include "AviaryJobService.h"
+#include <ServiceSkeleton.h>
+#include <stdio.h>
+#include <axis2_svc.h>
+#include <Environment.h>
+
+using namespace wso2wsf;
+
+using namespace AviaryJob;
+
+
+
+/** Load the service into engine
+Note:- If you are extending from the Generated Skeleton class,you need is to change the argument provided to the
+macro to your derived class name.
+Example
+If your service is Calculator, you will have the business logic implementation class as CalculatorSkeleton.
+If the extended class is CalculatorSkeletonImpl, then you change the argument to the macro WSF_SERVICE_SKEL_INIT as
+WSF_SERVICE_SKEL_INIT(CalculatorSkeletonImpl). Also include the header file of the derived class, in this case CalculatorSkeletonImpl.h
+
+*/
+
+WSF_SERVICE_SKEL_INIT(AviaryJobServiceSkeleton)
+
+
+
diff --git a/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.cpp b/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.cpp
new file mode 100644
index 0000000..3b768d8
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.cpp
@@ -0,0 +1,361 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// the implementation class for AviaryJob methods
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_attributes.h"
+
+extern bool qmgmt_all_users_trusted;
+
+// local includes
+#include "AviaryJobServiceSkeleton.h"
+#include <AviaryJob_RemoveJob.h>
+#include <AviaryJob_RemoveJobResponse.h>
+#include <AviaryJob_ReleaseJob.h>
+#include <AviaryJob_ReleaseJobResponse.h>
+#include <AviaryJob_SubmitJob.h>
+#include <AviaryJob_SubmitJobResponse.h>
+#include <AviaryJob_HoldJob.h>
+#include <AviaryJob_HoldJobResponse.h>
+#include <AviaryJob_SetJobAttribute.h>
+#include <AviaryJob_SetJobAttributeResponse.h>
+#include "Codec.h"
+#include "SchedulerObject.h"
+#include "stl_string_utils.h"
+
+using namespace std;
+using namespace AviaryJob;
+using namespace AviaryCommon;
+using namespace aviary::codec;
+using namespace aviary::job;
+using namespace compat_classad;
+
+const char* BASIC_REQ_FORMAT = 
+"\
+( TARGET.Arch %s ) && \
+( %s ) && \
+( TARGET.Disk %s ) && \
+( ( TARGET.Memory * 1024 ) %s ) && \
+( TARGET.FileSystemDomain %s )";
+
+const char* BASIC_OS_FORMAT = "TARGET.OpSys == \"%s\"";
+const char* BASIC_WINOS_FORMAT = "TARGET.OpSys==\"WINNT51\" || TARGET.OpSys==\"WINNT52\" || TARGET.OpSys==\"WINNT60\"";
+const char* REQ_UNDEFINED = " =!= undefined ";
+const char* REQ_GTE_ZERO = " >= 0 ";
+
+//
+// Utility methods START
+//
+
+typedef vector<AviaryCommon::Attribute*> CommonAttributeCollection;
+
+void
+checkForSchedulerID(AviaryCommon::JobID* _jobId, string& _text)
+{
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+	if (!(_jobId->getPool() == schedulerObj->getPool()) ||
+		!(_jobId->getScheduler() == schedulerObj->getName())) {
+	_text = "WARNING: the pool and scheduler names of the requested jobid were empty or did not match this scheduler!";
+	}
+}
+
+void
+buildBasicRequirements(ResourceConstraintVectorType* _constraints, string& _reqs) {
+	// scan through these and build TARGET.<constraint> like string
+	string arch = REQ_UNDEFINED;
+	string opsys = REQ_UNDEFINED;
+	string disk = REQ_GTE_ZERO;
+	string memory = REQ_GTE_ZERO;
+	string filesystem = REQ_UNDEFINED;
+	for ( ResourceConstraintVectorType::const_iterator it = _constraints->begin(); it != _constraints->end();
+		 it++ ) {
+		ResourceConstraint* rc = *it;
+		ADBResourceConstraintTypeEnum rct = rc->getType()->getResourceConstraintTypeEnum();
+		switch (rct) {
+			case ResourceConstraintType_ARCH:
+				arch = " == \"" + rc->getValue() + "\"";
+				break;
+			case ResourceConstraintType_OS:
+				if (rc->getValue() == "WINDOWS") {
+					opsys = BASIC_WINOS_FORMAT;
+				}
+				else {
+					sprintf(opsys,BASIC_OS_FORMAT,rc->getValue().c_str());
+				}
+				break;
+            case ResourceConstraintType_DISK:
+				disk = " >= " + rc->getValue();
+				break;
+			case ResourceConstraintType_MEMORY:
+				memory = " >= " + rc->getValue();
+				break;
+            case ResourceConstraintType_FILESYSTEM:
+				filesystem = " == \"" + rc->getValue() + "\"";
+				break;
+			default:
+				dprintf(D_ALWAYS,"Ignoring unknown resource constraint submitted: %s:%s\n",
+						rc->getType()->getResourceConstraintType().c_str(),rc->getValue().c_str());
+		}
+	}
+	// order is important! see BASIC_REQ_FORMAT above
+	sprintf(_reqs, BASIC_REQ_FORMAT, arch.c_str(), opsys.c_str(), disk.c_str(), memory.c_str(), filesystem.c_str());
+}
+
+bool
+isBasicAttribute(const string& attr_name) {
+	return (
+		attr_name == ATTR_JOB_CMD ||
+		attr_name == ATTR_REQUIREMENTS ||
+		attr_name == ATTR_OWNER ||
+		attr_name == ATTR_JOB_IWD ||
+		attr_name == ATTR_JOB_ARGUMENTS1
+	);
+}
+
+void
+addExtraAttributes(const CommonAttributeCollection* extra_attrs, AttributeMapType& attr_map, bool override_basic) {
+	// add in the extras
+	for (CommonAttributeCollection::const_iterator i = extra_attrs->begin();i < extra_attrs->end();i++) {
+		AviaryCommon::Attribute* attr = *i;
+		const string& attr_key = attr->getName();
+
+		// Are we overriding our basic attributes?
+		if (!override_basic && isBasicAttribute(attr_key)) {
+			// exclude this attribute from the submission map
+			continue;
+		}
+
+		const char* attr_value = attr->getValue().c_str();
+		switch (attr->getType()->getAttributeTypeEnum()) {
+			case AviaryCommon::AttributeType_INTEGER:
+				attr_map[attr_key.c_str()] =
+					new AviaryAttribute(AviaryAttribute::INTEGER_TYPE,attr_value);
+			break;
+			case AviaryCommon::AttributeType_FLOAT:
+				attr_map[attr_key.c_str()] =
+					new AviaryAttribute(AviaryAttribute::FLOAT_TYPE,attr_value);
+			break;
+			case AviaryCommon::AttributeType_STRING:
+				attr_map[attr_key.c_str()] =
+					new AviaryAttribute(AviaryAttribute::STRING_TYPE,attr_value);
+			break;
+			case AviaryCommon::AttributeType_BOOLEAN:
+			case AviaryCommon::AttributeType_EXPRESSION:
+				attr_map[attr_key.c_str()] =
+					new AviaryAttribute(AviaryAttribute::EXPR_TYPE,attr_value);
+			break;
+			// probably shouldn't get here unless axis2 fails us
+			case AviaryCommon::AttributeType_ERROR:
+			case AviaryCommon::AttributeType_UNDEFINED:
+			default:
+				dprintf(D_FULLDEBUG,"Unknown type supplied for attribute '%s=%s'\n",
+						attr_key.c_str(),attr_value);
+		}
+	}
+}
+
+//
+// Utility methods END
+//
+
+//
+// Interface implementation START
+//
+
+
+AviaryJob::SubmitJobResponse*
+AviaryJobServiceSkeleton::submitJob(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::SubmitJob* _submitJob)
+{
+    AviaryJob::SubmitJobResponse* submitJobResponse = new AviaryJob::SubmitJobResponse();
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    AttributeMapType reqsMap, attrMap;
+	const char* submissionName = NULL;
+
+    // add the simple stuff first
+    attrMap[ATTR_JOB_CMD] = new AviaryAttribute(AviaryAttribute::STRING_TYPE, _submitJob->getCmd().c_str());
+    if (!(_submitJob->isArgsNil() || _submitJob->getArgs().empty())) {
+        attrMap[ATTR_JOB_ARGUMENTS1] = new AviaryAttribute(AviaryAttribute::STRING_TYPE, _submitJob->getArgs().c_str());
+    }
+    attrMap[ATTR_OWNER] = new AviaryAttribute(AviaryAttribute::STRING_TYPE, _submitJob->getOwner().c_str());
+    attrMap[ATTR_JOB_IWD] = new AviaryAttribute(AviaryAttribute::STRING_TYPE, _submitJob->getIwd().c_str());
+	if (!(_submitJob->isSubmission_nameNil() || _submitJob->getSubmission_name().empty())) {
+		submissionName = _submitJob->getSubmission_name().c_str();
+        attrMap[ATTR_JOB_SUBMISSION] = new AviaryAttribute(AviaryAttribute::STRING_TYPE,submissionName);
+    }
+
+    // build a requirements string and add to it
+    string reqBuilder;
+    if (!(_submitJob->isRequirementsNil() || _submitJob->getRequirements()->empty())) {
+        // build from resource constraints
+		buildBasicRequirements(_submitJob->getRequirements(), reqBuilder);
+    }
+    else {
+        // default
+        reqBuilder = "TRUE";
+    }
+    attrMap[ATTR_REQUIREMENTS] = new AviaryAttribute(AviaryAttribute::EXPR_TYPE, reqBuilder.c_str());
+
+    // need to add extras attrs also
+	// wso2 doesn't seem to make true nil checking easy
+	// might remove the Attributes element
+	CommonAttributeCollection* attrs = NULL;
+	if (!_submitJob->isExtraNil()) {
+		attrs = _submitJob->getExtra();
+		if (attrs && !attrs->empty()) {			
+			if (attrs && !attrs->empty()) {
+				addExtraAttributes(attrs, attrMap,_submitJob->getAllowOverrides());
+			}
+		}
+	}
+	
+    // invoke submit
+    string jobId, error;
+    // we need this since we don't have a trusted socket to the schedd,
+    // without it basically the schedd won't accept whatever we claim
+    // is Owner and the job will be pseudo-pruned
+    qmgmt_all_users_trusted = true;
+    if (!schedulerObj->submit(attrMap,jobId, error)) {
+        submitJobResponse->setStatus(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+    }
+    else {
+        string submissionId;
+        if (submissionName) {
+			submissionId = submissionName;
+		}
+		else {
+			submissionId = schedulerObj->getName();
+			submissionId.append("#");
+			submissionId.append(jobId);
+		}
+        submitJobResponse->setId(new AviaryCommon::JobID(
+				jobId,schedulerObj->getPool(),schedulerObj->getName(),
+				new AviaryCommon::SubmissionID(submissionId,_submitJob->getOwner().c_str())));
+        submitJobResponse->setStatus(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),""));
+    }
+    qmgmt_all_users_trusted = false;
+
+    return submitJobResponse;
+}
+
+
+// TODO: would be nice to template these next 3
+AviaryJob::HoldJobResponse*
+AviaryJobServiceSkeleton::holdJob(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::HoldJob* _holdJob)
+{
+	AviaryJob::HoldJobResponse* holdJobResponse = new HoldJobResponse;
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    string error;
+
+	AviaryCommon::JobID* jobId = _holdJob->getHoldJob()->getId();
+	string reason = _holdJob->getHoldJob()->getReason();
+	string cluster_proc = jobId->getJob();
+	ControlJobResponse* controlJobResponse = NULL;
+
+	checkForSchedulerID(jobId, error);
+	if (!schedulerObj->hold(cluster_proc,reason,error)) {
+		dprintf(D_FULLDEBUG, "SchedulerObject Hold failed: %s\n", error.c_str());
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+	}
+	else {
+		// in this case, error may hve been the result of the pool/schedd check
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),error));
+	}
+
+	holdJobResponse->setHoldJobResponse(controlJobResponse);
+    return holdJobResponse;
+}
+
+
+AviaryJob::ReleaseJobResponse*
+AviaryJobServiceSkeleton::releaseJob(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::ReleaseJob* _releaseJob)
+{
+	AviaryJob::ReleaseJobResponse* releaseJobResponse = new ReleaseJobResponse;
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    string error;
+
+	AviaryCommon::JobID* jobId = _releaseJob->getReleaseJob()->getId();
+	string reason = _releaseJob->getReleaseJob()->getReason();
+	string cluster_proc = jobId->getJob();
+	ControlJobResponse* controlJobResponse = NULL;
+
+	checkForSchedulerID(jobId, error);
+	if (!schedulerObj->release(cluster_proc,reason,error)) {
+		dprintf(D_FULLDEBUG, "SchedulerObject Release failed: %s\n", error.c_str());
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+	}
+	else {
+		// in this case, error may hve been the result of the pool/schedd check
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),error));
+	}
+
+	releaseJobResponse->setReleaseJobResponse(controlJobResponse);
+    return releaseJobResponse;
+}
+
+AviaryJob::RemoveJobResponse*
+AviaryJobServiceSkeleton::removeJob(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::RemoveJob* _removeJob)
+{
+	AviaryJob::RemoveJobResponse* removeJobResponse = new RemoveJobResponse;
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    string error;
+
+	AviaryCommon::JobID* jobId = _removeJob->getRemoveJob()->getId();
+	string reason = _removeJob->getRemoveJob()->getReason();
+	string cluster_proc = jobId->getJob();
+	ControlJobResponse* controlJobResponse = NULL;
+
+	checkForSchedulerID(jobId, error);
+	if (!schedulerObj->remove(cluster_proc,reason,error)) {
+		dprintf(D_FULLDEBUG, "SchedulerObject Remove failed: %s\n", error.c_str());
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+	}
+	else {
+		// in this case, error may hve been the result of the pool/schedd check
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),error));
+	}
+
+	removeJobResponse->setRemoveJobResponse(controlJobResponse);
+    return removeJobResponse;
+}
+
+AviaryJob::SetJobAttributeResponse*
+AviaryJobServiceSkeleton::setJobAttribute(wso2wsf::MessageContext* /*outCtx*/ ,AviaryJob::SetJobAttribute* _setJobAttribute)
+{
+	AviaryJob::SetJobAttributeResponse* setAttrResponse = new SetJobAttributeResponse;
+	SchedulerObject* schedulerObj = SchedulerObject::getInstance();
+    string error;
+
+	AviaryCommon::JobID* jobId = _setJobAttribute->getId();
+	AviaryCommon::Attribute* attr = _setJobAttribute->getAttribute();
+	string cluster_proc = jobId->getJob();
+	ControlJobResponse* controlJobResponse = NULL;
+
+	checkForSchedulerID(jobId, error);
+	if (!schedulerObj->setAttribute(cluster_proc,attr->getName(),attr->getValue(),error)) {
+		dprintf(D_FULLDEBUG, "SchedulerObject SetAttribute failed: %s\n", error.c_str());
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("FAIL"),error));
+	}
+	else {
+		// in this case, error may hve been the result of the pool/schedd check
+		controlJobResponse = new ControlJobResponse(new AviaryCommon::Status(new AviaryCommon::StatusCodeType("OK"),error));
+	}
+
+	setAttrResponse->setSetJobAttributeResponse(controlJobResponse);
+    return setAttrResponse;
+}
diff --git a/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.h b/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.h
new file mode 100644
index 0000000..12bddc3
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryJobServiceSkeleton.h
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVIARYJOBSERVICESKELETON_H
+#define AVIARYJOBSERVICESKELETON_H
+
+    #include <OMElement.h>
+    #include <MessageContext.h>
+   
+     #include <AviaryJob_RemoveJob.h>
+    
+     #include <AviaryJob_RemoveJobResponse.h>
+    
+     #include <AviaryJob_ReleaseJob.h>
+    
+     #include <AviaryJob_ReleaseJobResponse.h>
+    
+     #include <AviaryJob_SubmitJob.h>
+    
+     #include <AviaryJob_SubmitJobResponse.h>
+    
+     #include <AviaryJob_HoldJob.h>
+    
+     #include <AviaryJob_HoldJobResponse.h>
+    
+     #include <AviaryJob_SetJobAttribute.h>
+    
+     #include <AviaryJob_SetJobAttributeResponse.h>
+
+typedef std::vector<AviaryCommon::ResourceConstraint*> ResourceConstraintVectorType;
+    
+namespace AviaryJob {
+    
+
+   /** we have to reserve some error codes for adb and for custom messages */
+    #define AVIARYJOBSERVICESKELETON_ERROR_CODES_START (AXIS2_ERROR_LAST + 2500)
+
+    typedef enum
+    {
+        AVIARYJOBSERVICESKELETON_ERROR_NONE = AVIARYJOBSERVICESKELETON_ERROR_CODES_START,
+
+        AVIARYJOBSERVICESKELETON_ERROR_LAST
+    } AviaryJobServiceSkeleton_error_codes;
+
+    
+
+
+class AviaryJobServiceSkeleton
+{
+
+        public:
+            AviaryJobServiceSkeleton(){}
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "removeJob|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _removeJob of the AviaryJob::RemoveJob
+         *
+         * @return AviaryJob::RemoveJobResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::RemoveJobResponse* removeJob(wso2wsf::MessageContext *outCtx ,AviaryJob::RemoveJob* _removeJob);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "releaseJob|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _releaseJob of the AviaryJob::ReleaseJob
+         *
+         * @return AviaryJob::ReleaseJobResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::ReleaseJobResponse* releaseJob(wso2wsf::MessageContext *outCtx ,AviaryJob::ReleaseJob* _releaseJob);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "submitJob|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _submitJob of the AviaryJob::SubmitJob
+         *
+         * @return AviaryJob::SubmitJobResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::SubmitJobResponse* submitJob(wso2wsf::MessageContext *outCtx ,AviaryJob::SubmitJob* _submitJob);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "holdJob|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _holdJob of the AviaryJob::HoldJob
+         *
+         * @return AviaryJob::HoldJobResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::HoldJobResponse* holdJob(wso2wsf::MessageContext *outCtx ,AviaryJob::HoldJob* _holdJob);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "setJobAttribute|http://grid.redhat.com/aviary-job/" operation.
+         * 
+         * @param _setJobAttribute of the AviaryJob::SetJobAttribute
+         *
+         * @return AviaryJob::SetJobAttributeResponse*
+         */
+        
+
+         virtual 
+        AviaryJob::SetJobAttributeResponse* setJobAttribute(wso2wsf::MessageContext *outCtx ,AviaryJob::SetJobAttribute* _setJobAttribute);
+
+
+     
+
+
+
+};
+
+
+}
+
+
+
+        
+#endif // AVIARYJOBSERVICESKELETON_H
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryService.cpp b/src/condor_contrib/aviary/src/AviaryQueryService.cpp
new file mode 100644
index 0000000..242c4e0
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryService.cpp
@@ -0,0 +1,358 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+        #include "AviaryQueryServiceSkeleton.h"
+        #include "AviaryQueryService.h"  
+        #include <ServiceSkeleton.h>
+        #include <stdio.h>
+        #include <axis2_svc.h>
+        #include <Environment.h>
+        #include <axiom_soap.h>
+
+
+        using namespace wso2wsf;
+        
+        using namespace AviaryQuery;
+        
+
+        /** Load the service into axis2 engine */
+        WSF_SERVICE_INIT(AviaryQueryService)
+
+          
+         /**
+          * function to free any soap input headers
+          */
+         AviaryQueryService::AviaryQueryService()
+	{
+          skel = wsfGetAviaryQueryServiceSkeleton();
+    }
+
+
+	void WSF_CALL
+	AviaryQueryService::init()
+	{
+
+      return;
+	}
+
+
+	AviaryQueryService::~AviaryQueryService()
+	{
+    }
+
+
+     
+
+     
+
+
+
+
+	/*
+	 * This method invokes the right service method
+	 */
+	OMElement* WSF_CALL
+	AviaryQueryService::invoke(OMElement *omEle, MessageContext *msgCtx)
+	{
+         /* Using the function name, invoke the corresponding method
+          */
+
+          axis2_op_ctx_t *operation_ctx = NULL;
+          axis2_op_t *operation = NULL;
+          axutil_qname_t *op_qname = NULL;
+          axis2_char_t *op_name = NULL;
+          axis2_msg_ctx_t *in_msg_ctx = NULL;
+          
+          axiom_soap_envelope_t *req_soap_env = NULL;
+          axiom_soap_header_t *req_soap_header = NULL;
+          axiom_soap_envelope_t *res_soap_env = NULL;
+          axiom_soap_header_t *res_soap_header = NULL;
+
+          axiom_node_t *ret_node = NULL;
+          axiom_node_t *input_header = NULL;
+          axiom_node_t *output_header = NULL;
+          axiom_node_t *header_base_node = NULL;
+          axis2_msg_ctx_t *msg_ctx = NULL;
+          axiom_node_t* content_node = omEle->getAxiomNode();
+
+          
+            AviaryQuery::GetJobDataResponse* ret_val1;
+            AviaryQuery::GetJobData* input_val1;
+            
+            AviaryQuery::GetJobStatusResponse* ret_val2;
+            AviaryQuery::GetJobStatus* input_val2;
+            
+            AviaryQuery::GetSubmissionSummaryResponse* ret_val3;
+            AviaryQuery::GetSubmissionSummary* input_val3;
+            
+            AviaryQuery::GetJobDetailsResponse* ret_val4;
+            AviaryQuery::GetJobDetails* input_val4;
+
+			AviaryQuery::GetJobSummaryResponse* ret_val5;
+            AviaryQuery::GetJobSummary* input_val5;
+            
+            
+       
+          msg_ctx = msgCtx->getAxis2MessageContext();
+          operation_ctx = axis2_msg_ctx_get_op_ctx(msg_ctx, Environment::getEnv());
+          operation = axis2_op_ctx_get_op(operation_ctx, Environment::getEnv());
+          op_qname = (axutil_qname_t *)axis2_op_get_qname(operation, Environment::getEnv());
+          op_name = axutil_qname_get_localpart(op_qname, Environment::getEnv());
+
+          if (op_name)
+          {
+               
+
+                if ( axutil_strcmp(op_name, "getJobData") == 0 )
+                {
+
+                    
+                    input_val1 =
+                        
+                        new AviaryQuery::GetJobData();
+                        if( AXIS2_FAILURE ==  input_val1->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetJobData_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val1 =  skel->getJobData(msgCtx ,input_val1);
+                    
+                        if ( NULL == ret_val1 )
+                        {
+                            
+                                delete input_val1;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val1->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val1;
+                                        
+                                            delete input_val1;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "getJobStatus") == 0 )
+                {
+
+                    
+                    input_val2 =
+                        
+                        new AviaryQuery::GetJobStatus();
+                        if( AXIS2_FAILURE ==  input_val2->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetJobStatus_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val2 =  skel->getJobStatus(msgCtx ,input_val2);
+                    
+                        if ( NULL == ret_val2 )
+                        {
+                            
+                                delete input_val2;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val2->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val2;
+                                        
+                                            delete input_val2;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "getSubmissionSummary") == 0 )
+                {
+
+                    
+                    input_val3 =
+                        
+                        new AviaryQuery::GetSubmissionSummary();
+                        if( AXIS2_FAILURE ==  input_val3->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetSubmissionSummary_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val3 =  skel->getSubmissionSummary(msgCtx ,input_val3);
+                    
+                        if ( NULL == ret_val3 )
+                        {
+                            
+                                delete input_val3;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val3->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val3;
+                                        
+                                            delete input_val3;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+             
+
+                if ( axutil_strcmp(op_name, "getJobDetails") == 0 )
+                {
+
+                    
+                    input_val4 =
+                        
+                        new AviaryQuery::GetJobDetails();
+                        if( AXIS2_FAILURE ==  input_val4->deserialize(&content_node, NULL, false))
+                        {
+                                        
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetJobDetails_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;      
+                        }
+                        
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val4 =  skel->getJobDetails(msgCtx ,input_val4);
+                    
+                        if ( NULL == ret_val4 )
+                        {
+                            
+                                delete input_val4;
+                            
+                            return NULL; 
+                        }
+                        ret_node = 
+                                            ret_val4->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val4;
+                                        
+                                            delete input_val4;
+                                        
+
+                        return new OMElement(NULL,ret_node);
+                    
+
+                    /* since this has no output params it just returns NULL */                    
+                    
+
+                }
+
+
+                if ( axutil_strcmp(op_name, "getJobSummary") == 0 )
+                {
+
+
+                    input_val5 =
+
+                        new AviaryQuery::GetJobSummary();
+                        if( AXIS2_FAILURE ==  input_val5->deserialize(&content_node, NULL, false))
+                        {
+
+                            AXIS2_ERROR_SET(Environment::getEnv()->error, AXIS2_ERROR_DATA_ELEMENT_IS_NULL, AXIS2_FAILURE);
+                            AXIS2_LOG_ERROR( Environment::getEnv()->log, AXIS2_LOG_SI, "NULL returned from the AviaryQuery::GetJobSummary_deserialize: "
+                                        "This should be due to an invalid XML");
+                            return NULL;
+                        }
+
+                        //AviaryQueryServiceSkeleton skel;
+                        ret_val5 =  skel->getJobSummary(msgCtx ,input_val5);
+
+                        if ( NULL == ret_val5 )
+                        {
+
+                                delete input_val5;
+
+                            return NULL;
+                        }
+                        ret_node =
+                                            ret_val5->serialize(NULL, NULL, AXIS2_TRUE, NULL, NULL);
+                                            delete ret_val5;
+
+                                            delete input_val5;
+
+
+                        return new OMElement(NULL,ret_node);
+
+
+                    /* since this has no output params it just returns NULL */
+
+
+                }
+
+             
+             }
+            
+          AXIS2_LOG_ERROR(Environment::getEnv()->log, AXIS2_LOG_SI, "AviaryQueryService service ERROR: invalid OM parameters in request\n");
+          return NULL;
+    }
+
+    OMElement* WSF_CALL
+    AviaryQueryService::onFault(OMElement* omEle)
+	{
+		axiom_node_t *error_node = NULL;
+		axiom_element_t *error_ele = NULL;
+        axutil_error_codes_t error_code;
+        axiom_node_t *node = omEle->getAxiomNode();
+        error_code = (axutil_error_codes_t)Environment::getEnv()->error->error_number;
+
+        if(error_code <= AVIARYQUERYSERVICESKELETON_ERROR_NONE ||
+                error_code >= AVIARYQUERYSERVICESKELETON_ERROR_LAST )
+        {
+            error_ele = axiom_element_create(Environment::getEnv(), node, "fault", NULL,
+                            &error_node);
+            axiom_element_set_text(error_ele, Environment::getEnv(), "AviaryQueryService|http://grid.redhat.com/aviary-query/ failed",
+                            error_node);
+        }
+        
+
+		return new OMElement(NULL,error_node);
+	}
+
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryService.h b/src/condor_contrib/aviary/src/AviaryQueryService.h
new file mode 100644
index 0000000..18be684
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryService.h
@@ -0,0 +1,67 @@
+
+
+          #ifndef AVIARYQUERYSERVICE_H
+          #define AVIARYQUERYSERVICE_H
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <ServiceSkeleton.h>
+#include <stdio.h>
+#include <axis2_svc.h>
+
+using namespace wso2wsf;
+
+
+using namespace AviaryQuery;
+
+
+
+#define WSF_SERVICE_SKEL_INIT(class_name) \
+AviaryQueryServiceSkeleton* wsfGetAviaryQueryServiceSkeleton(){ return new class_name(); }
+
+AviaryQueryServiceSkeleton* wsfGetAviaryQueryServiceSkeleton(); 
+
+
+
+        class AviaryQueryService : public ServiceSkeleton
+        {
+            private:
+                AviaryQueryServiceSkeleton *skel;
+
+            public:
+
+               union {
+                     
+               } fault;
+
+
+              WSF_EXTERN WSF_CALL AviaryQueryService();
+
+              OMElement* WSF_CALL invoke(OMElement *message, MessageContext *msgCtx);
+
+              OMElement* WSF_CALL onFault(OMElement *message);
+
+              void WSF_CALL init();
+
+              ~AviaryQueryService(); 
+      };
+
+
+
+#endif    //     AVIARYQUERYSERVICE_H
+
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryServiceMacro.cpp b/src/condor_contrib/aviary/src/AviaryQueryServiceMacro.cpp
new file mode 100644
index 0000000..d8cae4c
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryServiceMacro.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include "AviaryQueryServiceSkeleton.h"
+#include "AviaryQueryService.h"
+#include <ServiceSkeleton.h>
+#include <stdio.h>
+#include <axis2_svc.h>
+#include <Environment.h>
+
+using namespace wso2wsf;
+
+using namespace AviaryQuery;
+
+
+
+/** Load the service into engine
+Note:- If you are extending from the Generated Skeleton class,you need is to change the argument provided to the
+macro to your derived class name.
+Example
+If your service is Calculator, you will have the business logic implementation class as CalculatorSkeleton.
+If the extended class is CalculatorSkeletonImpl, then you change the argument to the macro WSF_SERVICE_SKEL_INIT as
+WSF_SERVICE_SKEL_INIT(CalculatorSkeletonImpl). Also include the header file of the derived class, in this case CalculatorSkeletonImpl.h
+
+*/
+
+WSF_SERVICE_SKEL_INIT(AviaryQueryServiceSkeleton)
+
+
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.cpp b/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.cpp
new file mode 100644
index 0000000..4d52d48
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.cpp
@@ -0,0 +1,475 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// the implementation methods for AviaryQueryService methods
+
+//local includes
+#include "Globals.h"
+#include "JobServerObject.h"
+#include "AviaryQueryServiceSkeleton.h"
+#include <AviaryQuery_GetJobData.h>
+#include <AviaryQuery_GetJobDataResponse.h>
+#include <AviaryQuery_GetJobStatus.h>
+#include <AviaryQuery_GetJobStatusResponse.h>
+#include <AviaryQuery_GetSubmissionSummary.h>
+#include <AviaryQuery_GetSubmissionSummaryResponse.h>
+#include <AviaryQuery_GetJobDetails.h>
+#include <AviaryQuery_GetJobDetailsResponse.h>
+#include <AviaryQuery_GetJobSummary.h>
+#include <AviaryQuery_GetJobSummaryResponse.h>
+#include <Axis2SoapProvider.h>
+
+// condor includes
+#include "stl_string_utils.h"
+#include "proc.h"
+#include "condor_attributes.h"
+
+// axis includes
+#include "axutil_date_time.h"
+
+using namespace std;
+using namespace AviaryQuery;
+using namespace AviaryCommon;
+using namespace aviary::query;
+
+struct cmpid {
+	bool operator()(const char *a, const char *b) const {
+		return strcmp(a, b) < 0;
+	}
+};
+
+typedef vector<JobID*> JobIdCollection;
+typedef vector<SubmissionID*> SubmissionIdCollection;
+typedef vector<JobStatus*> JobStatusCollection;
+typedef vector<JobDetails*> JobDetailsCollection;
+typedef vector<JobSummary*> JobSummaryCollection;
+typedef vector<SubmissionSummary*> SubmissionSummaryCollection;
+typedef set<const char*, cmpid> IdCollection;
+
+// TODO: singleton this...
+extern aviary::soap::Axis2SoapProvider* provider;
+
+//
+// Utility section START
+//
+
+// Any key that begins with the '0' char is either the
+// header or a cluster, i.e. not a job
+#define IS_JOB(key) ((key) && '0' != (key)[0])
+
+// NOTE #1: unfortunately the Axis2/C generated code is inconsistent in its
+// internal checking of nillable (i.e., minOccurs=0) elements
+// so we have to use default ctors and build the element object using setters
+// otherwise segvs await us in generated code
+
+// NOTE #2: using template functions since WSO2 codegen won't give us
+// XSD extension->C++ inheritance
+template <class JobBase>
+void createGoodJobResponse(JobBase& jb, const char* job_id) {
+	JobServerObject* jso = JobServerObject::getInstance();
+	JobID* jid = new JobID;
+	jid->setJob(job_id);
+	jid->setPool(jso->getPool());
+	jid->setScheduler(jso->getName());
+	jb.setId(jid);
+	Status* js = new Status;
+	js->setCode(new StatusCodeType("OK"));
+	jb.setStatus(js);
+}
+
+template <class JobBase>
+void createBadJobResponse(JobBase& jb, const char* job_id, const AviaryStatus& error) {
+	JobID* jid = new JobID;
+	jid->setJob(job_id);
+	jb.setId(jid);
+	StatusCodeType* jst = new StatusCodeType;
+	jst->setStatusCodeTypeEnum(ADBStatusCodeTypeEnum(error.type));
+	Status* js = new Status(jst,error.text);
+	jb.setStatus(js);
+}
+
+// unfortunately no convenience functions from WS02 for dateTime
+axutil_date_time_t* encodeDateTime(const time_t* _time) {
+	struct tm _tm;
+
+	// need the re-entrant version because axutil_date_time_create
+	// calls time() again and overwrites static tm
+	localtime_r(_time,&_tm);
+	// get our Axis2 env for the allocator
+	const axutil_env_t* _env = provider->getEnv();
+
+	axutil_date_time_t* _value = NULL;
+	_value = axutil_date_time_create(_env);
+
+    if (!_value)
+    {
+        AXIS2_ERROR_SET(_env->error, AXIS2_ERROR_NO_MEMORY, AXIS2_FAILURE);
+        AXIS2_LOG_ERROR(_env->log, AXIS2_LOG_SI, "Out of memory");
+        return NULL;
+    }
+
+	// play their game with adjusting the year and month offset
+	axutil_date_time_set_date_time(_value,_env,
+								   _tm.tm_year+1900,
+								   _tm.tm_mon+1,
+								   _tm.tm_mday,
+								   _tm.tm_hour,
+								   _tm.tm_min,
+								   _tm.tm_sec,
+								   0);
+	return _value;
+};
+
+void mapFieldsToSummary(const JobSummaryFields& fields, JobSummary* _summary) {
+
+	// JobID should already been in our summary
+	SubmissionID* sid = new SubmissionID;
+	sid->setName(fields.submission_id);
+	sid->setOwner(fields.owner);
+	_summary->getId()->setSubmission(sid);
+	// do date/time conversion
+	_summary->setQueued(encodeDateTime((const time_t*)&fields.queued));
+	_summary->setLast_update(encodeDateTime((const time_t*)&fields.last_update));
+	JobStatusType* jst = new JobStatusType;
+	jst->setJobStatusType(getJobStatusString(fields.status));
+	_summary->setJob_status(jst);
+	_summary->setCmd(fields.cmd);
+	if (!fields.args1.empty()) {
+		_summary->setArgs1(fields.args1);
+	}
+	if (!fields.args2.empty()) {
+		_summary->setArgs2(fields.args2);
+	}
+	if (!fields.hold_reason.empty()) {
+		_summary->setHeld(fields.hold_reason);
+	}
+	if (!fields.release_reason.empty()) {
+		_summary->setReleased(fields.release_reason);
+	}
+	if (!fields.remove_reason.empty()) {
+		_summary->setRemoved(fields.remove_reason);
+	}
+}
+
+void mapToXsdAttributes(const aviary::codec::AttributeMapType& _map, AviaryCommon::Attributes* _attrs) {
+	for (AttributeMapIterator i = _map.begin(); _map.end() != i; i++) {
+		AviaryAttribute* codec_attr = (AviaryAttribute*)(*i).second;
+		AviaryCommon::Attribute* attr = new AviaryCommon::Attribute;
+		attr->setName((*i).first);
+		AviaryCommon::AttributeType* attr_type = new AviaryCommon::AttributeType;
+		switch (codec_attr->getType()) {
+			case AviaryAttribute::INTEGER_TYPE:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_INTEGER);
+				break;
+			case AviaryAttribute::FLOAT_TYPE:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_FLOAT);
+				break;
+			case AviaryAttribute::STRING_TYPE:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_STRING);
+				break;
+			case AviaryAttribute::EXPR_TYPE:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_EXPRESSION);
+				break;
+			default:
+				attr_type->setAttributeTypeEnum(AviaryCommon::AttributeType_UNDEFINED);
+		}
+		attr->setType(attr_type);
+		attr->setValue(codec_attr->getValue());
+		_attrs->addAttrs(attr);
+	}
+}
+
+//
+// Utility section END
+//
+
+//
+// Interface implementation START
+//
+GetSubmissionSummaryResponse* AviaryQueryServiceSkeleton::getSubmissionSummary(wso2wsf::MessageContext* /*outCtx*/
+	,GetSubmissionSummary* _getSubmissionSummary)
+{
+	GetSubmissionSummaryResponse* getSummaryResponse = new GetSubmissionSummaryResponse;
+
+	SubmissionCollectionType::const_iterator element = g_submissions.begin();
+	SubmissionSummaryCollection* submissions = new SubmissionSummaryCollection;
+
+	SubmissionCollectionType sub_map;
+
+	if (_getSubmissionSummary->isIdsNil() || _getSubmissionSummary->getIds()->size() == 0) {
+		// no ids supplied...they get them all
+		for (SubmissionCollectionType::iterator i = g_submissions.begin(); g_submissions.end() != i; i++) {
+			sub_map[(*i).first] = (*i).second;
+		}
+	}
+	else {
+		// fast track...client has supplied ids to scan
+		SubmissionIdCollection* id_list = _getSubmissionSummary->getIds();
+		for (SubmissionIdCollection::iterator sic_it = id_list->begin(); id_list->end() != sic_it; sic_it++) {
+			const char* sid_str = (*sic_it)->getName().c_str();
+			SubmissionCollectionType::iterator sct_it = g_submissions.find(sid_str);
+			if (sct_it != g_submissions.end()) {
+				sub_map[(*sct_it).first] = (*sct_it).second;
+			}
+			else {
+				// mark this as not matched when returning our results
+				sub_map[(*sct_it).first] = NULL;
+			}
+		}
+	}
+
+	for (SubmissionCollectionType::iterator i = sub_map.begin(); sub_map.end() != i; i++) {
+		SubmissionSummary* summary = new SubmissionSummary;
+		SubmissionObject *submission = (*i).second;
+
+		if (submission) {
+			SubmissionID* sid = new SubmissionID;
+			sid->setName(submission->getName());
+			sid->setOwner(submission->getOwner());
+			summary->setId(sid);
+			summary->setCompleted(submission->getCompleted().size());
+			summary->setHeld(submission->getHeld().size());
+			summary->setIdle(submission->getIdle().size());
+			summary->setRemoved(submission->getRemoved().size());
+			summary->setRunning(submission->getRunning().size());
+			Status* ss = new Status;
+			ss->setCode(new StatusCodeType("OK"));
+			summary->setStatus(ss);
+
+			if (!_getSubmissionSummary->isIncludeJobSummariesNil() && _getSubmissionSummary->getIncludeJobSummaries()) {
+				// client wants the job summaries also
+				JobSummaryPairCollection jobs;
+				submission->getJobSummaries(jobs);
+				for (JobSummaryPairCollection::const_iterator it = jobs.begin(); jobs.end() != it; it++) {
+					JobSummary* js = new JobSummary;
+					createGoodJobResponse<JobSummary>(*js,(*it).first);
+					mapFieldsToSummary(*((*it).second),js);
+					summary->addJobs(js);
+				}
+			}
+
+		}
+		else {
+			SubmissionID* sid = new SubmissionID;
+			summary->setId(sid);
+			StatusCodeType* sst = new StatusCodeType;
+			sst->setStatusCodeType("NO_MATCH");
+			Status* ss = new Status(sst,"Unable to locate submission");
+			summary->setStatus(ss);
+		}
+		submissions->push_back(summary);
+	}
+
+	getSummaryResponse->setSubmissions(submissions);
+
+    return getSummaryResponse;
+}
+
+GetJobStatusResponse* AviaryQueryServiceSkeleton::getJobStatus(wso2wsf::MessageContext* /*outCtx*/
+	,GetJobStatus* _getJobStatus)
+{
+	GetJobStatusResponse* jobStatusResponse = new GetJobStatusResponse;
+	JobServerObject* jso = JobServerObject::getInstance();
+	JobStatusCollection* job_results = new JobStatusCollection;
+
+	IdCollection id_set;
+
+	if (_getJobStatus->isIdsNil() || _getJobStatus->getIds()->size() == 0) {
+		// no ids supplied...they get them all
+		for (JobCollectionType::iterator i = g_jobs.begin(); g_jobs.end() != i; i++) {
+			const char* job_id = (*i).first;
+			if (IS_JOB(job_id)) {
+				id_set.insert(job_id);
+			}
+		}
+	}
+	else {
+		// fast track...client has supplied ids to scan
+		JobIdCollection* id_list = _getJobStatus->getIds();
+		for (JobIdCollection::iterator i = id_list->begin(); id_list->end() != i; i++) {
+			id_set.insert((*i)->getJob().c_str());
+		}
+	}
+
+	for (IdCollection::const_iterator i = id_set.begin(); id_set.end() != i; i++) {
+		JobStatus* js = new JobStatus;
+		const char* job = *i;
+		AviaryStatus status;
+		int job_status = JOB_STATUS_MIN;
+		if (jso->getStatus(job,job_status,status)) {
+			createGoodJobResponse<JobStatus>(*js,job);
+			JobStatusType* jst = new JobStatusType;
+			jst->setJobStatusType(getJobStatusString(job_status));
+			js->setJob_status(jst);
+		}
+		else {
+			// problem...report to client
+			createBadJobResponse<JobStatus>(*js,job,status);
+		}
+		job_results->push_back(js);
+	}
+
+	jobStatusResponse->setJobs(job_results);
+
+    return jobStatusResponse;
+}
+
+GetJobSummaryResponse* AviaryQueryServiceSkeleton::getJobSummary(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobSummary* _getJobSummary)
+{
+	GetJobSummaryResponse* jobSummaryResponse = new GetJobSummaryResponse;
+	JobServerObject* jso = JobServerObject::getInstance();
+	JobSummaryCollection* job_results = new JobSummaryCollection;
+	
+	IdCollection id_set;
+
+	if (_getJobSummary->isIdsNil() || _getJobSummary->getIds()->size() == 0) {
+		// no ids supplied...they get them all
+		for (JobCollectionType::iterator i = g_jobs.begin(); g_jobs.end() != i; i++) {
+			const char* job_id = (*i).first;
+			if (IS_JOB(job_id)) {
+				id_set.insert(job_id);
+			}
+		}
+	}
+	else {
+		// fast track...client has supplied ids to scan
+		JobIdCollection* id_list = _getJobSummary->getIds();
+		for (JobIdCollection::iterator i = id_list->begin(); id_list->end() != i; i++) {
+			id_set.insert((*i)->getJob().c_str());
+		}
+	}
+	
+	for (IdCollection::const_iterator i = id_set.begin(); id_set.end() != i; i++) {
+		JobSummary* js = new JobSummary;
+		const char* job = *i;
+		JobSummaryFields jsf;
+		AviaryStatus status;
+		if (jso->getSummary(job,jsf,status)) {
+			createGoodJobResponse<JobSummary>(*js,job);
+			mapFieldsToSummary(jsf,js);
+		}
+		else {
+			// problem...report to client
+			createBadJobResponse<JobSummary>(*js, job, status);
+		}
+		job_results->push_back(js);
+	}
+
+	jobSummaryResponse->setJobs(job_results);
+
+    return jobSummaryResponse;
+}
+
+GetJobDetailsResponse* AviaryQueryServiceSkeleton::getJobDetails(wso2wsf::MessageContext* /* outCtx*/
+	,GetJobDetails* _getJobDetails)
+{
+	GetJobDetailsResponse* jobDetailsResponse = new GetJobDetailsResponse;
+	JobServerObject* jso = JobServerObject::getInstance();
+	JobDetailsCollection* job_results = new JobDetailsCollection;
+
+	IdCollection id_set;
+
+	if (_getJobDetails->isIdsNil() || _getJobDetails->getIds()->size() == 0) {
+		// no ids supplied...they get them all
+		for (JobCollectionType::iterator i = g_jobs.begin(); g_jobs.end() != i; i++) {
+			const char* job_id = (*i).first;
+			if (IS_JOB(job_id)) {
+				id_set.insert(job_id);
+			}
+		}
+	}
+	else {
+		// fast track...client has supplied ids to scan
+		JobIdCollection* id_list = _getJobDetails->getIds();
+		for (JobIdCollection::iterator i = id_list->begin(); id_list->end() != i; i++) {
+			id_set.insert((*i)->getJob().c_str());
+		}
+	}
+
+	for (IdCollection::const_iterator i = id_set.begin(); id_set.end() != i; i++) {
+		JobDetails* jd = new JobDetails;
+		const char* job = *i;
+		aviary::codec::AttributeMapType attr_map;
+		AviaryStatus status;
+		if (jso->getJobAd(job,attr_map,status)) {
+			createGoodJobResponse<JobDetails>(*jd,job);
+			// load attributes
+			AviaryCommon::Attributes* attrs = new AviaryCommon::Attributes;
+			mapToXsdAttributes(attr_map,attrs);
+			jd->setDetails(attrs);
+		}
+		else {
+			// problem...report to client
+			createBadJobResponse<JobDetails>(*jd, job, status);
+		}
+		job_results->push_back(jd);
+	}
+
+	jobDetailsResponse->setJobs(job_results);
+
+    return jobDetailsResponse;
+}
+
+// NOTE: getJobData is the rare case (?) where someone wants to pull the job output
+// thus, we don't batch this - just one at a time
+GetJobDataResponse* AviaryQueryServiceSkeleton::getJobData(wso2wsf::MessageContext* /* outCtx */
+	,GetJobData* _getJobData)
+{
+    GetJobDataResponse* jobDataResponse = new  GetJobDataResponse;
+	JobServerObject* jso = JobServerObject::getInstance();
+
+	const char* job = _getJobData->getData()->getId()->getJob().c_str();
+	AviaryCommon::JobDataType* jdt = _getJobData->getData()->getType();
+	ADBJobDataTypeEnum file_type = jdt->getJobDataTypeEnum();
+	AviaryStatus status;
+	status.type = AviaryStatus::FAIL;
+	string fname, content;
+	int fsize;
+	if (jso->fetchJobData(job,UserFileType(file_type),fname,_getJobData->getMax_bytes(),_getJobData->getFrom_end(),fsize,content,status)) {
+		JobID* jid = new JobID;
+		jid->setJob(job);
+		jid->setPool(jso->getPool());
+		jid->setScheduler(jso->getName());
+		JobData* jd = new JobData;
+		jd->setId(jid);
+		jd->setType(jdt);
+		jobDataResponse->setData(jd);
+		Status* js = new Status;
+		js->setCode(new StatusCodeType("OK"));
+		jobDataResponse->setStatus(js);
+
+		// load requested file data
+		jobDataResponse->setContent(content);
+		jobDataResponse->setFile_name(fname);
+		jobDataResponse->setFile_size(fsize);
+	}
+	else {
+		// problem...report to client
+		JobID* jid = new JobID;
+		jid->setJob(job);
+		JobData* jd = new JobData;
+		jd->setId(jid);
+		jd->setType(jdt);
+		jobDataResponse->setData(jd);
+		StatusCodeType* jst = new StatusCodeType;
+		jst->setStatusCodeTypeEnum(ADBStatusCodeTypeEnum(status.type));
+		Status* js = new Status(jst,status.text);
+		jobDataResponse->setStatus(js);
+	}
+
+    return jobDataResponse;
+}
+
diff --git a/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.h b/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.h
new file mode 100644
index 0000000..e400201
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryQueryServiceSkeleton.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AVIARYQUERYSERVICESKELETON_H
+#define AVIARYQUERYSERVICESKELETON_H
+
+    #include <OMElement.h>
+    #include <MessageContext.h>
+   
+     #include <AviaryQuery_GetJobData.h>
+    
+     #include <AviaryQuery_GetJobDataResponse.h>
+    
+     #include <AviaryQuery_GetJobStatus.h>
+    
+     #include <AviaryQuery_GetJobStatusResponse.h>
+    
+     #include <AviaryQuery_GetSubmissionSummary.h>
+    
+     #include <AviaryQuery_GetSubmissionSummaryResponse.h>
+    
+     #include <AviaryQuery_GetJobDetails.h>
+    
+     #include <AviaryQuery_GetJobDetailsResponse.h>
+
+     #include <AviaryQuery_GetJobSummary.h>
+
+     #include <AviaryQuery_GetJobSummaryResponse.h>
+    
+    
+namespace AviaryQuery {
+    
+
+   /** we have to reserve some error codes for adb and for custom messages */
+    #define AVIARYQUERYSERVICESKELETON_ERROR_CODES_START (AXIS2_ERROR_LAST + 2500)
+
+    typedef enum
+    {
+        AVIARYQUERYSERVICESKELETON_ERROR_NONE = AVIARYQUERYSERVICESKELETON_ERROR_CODES_START,
+
+        AVIARYQUERYSERVICESKELETON_ERROR_LAST
+    } AviaryQueryServiceSkeleton_error_codes;
+
+    
+
+
+class AviaryQueryServiceSkeleton
+{
+        public:
+            AviaryQueryServiceSkeleton(){}
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "getJobData|http://grid.redhat.com/aviary-query/" operation.
+         * 
+         * @param _getJobData of the AviaryQuery::GetJobData
+         *
+         * @return AviaryQuery::GetJobDataResponse*
+         */
+        
+
+         virtual 
+        AviaryQuery::GetJobDataResponse* getJobData(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobData* _getJobData);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "getJobStatus|http://grid.redhat.com/aviary-query/" operation.
+         * 
+         * @param _getJobStatus of the AviaryQuery::GetJobStatus
+         *
+         * @return AviaryQuery::GetJobStatusResponse*
+         */
+        
+
+         virtual 
+        AviaryQuery::GetJobStatusResponse* getJobStatus(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobStatus* _getJobStatus);
+
+
+     
+
+
+
+
+		 
+
+
+        /**
+         * Auto generated method declaration
+         * for "getSubmissionSummary|http://grid.redhat.com/aviary-query/" operation.
+         * 
+         * @param _getSubmissionSummary of the AviaryQuery::GetSubmissionSummary
+         *
+         * @return AviaryQuery::GetSubmissionSummaryResponse*
+         */
+        
+
+         virtual 
+        AviaryQuery::GetSubmissionSummaryResponse* getSubmissionSummary(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetSubmissionSummary* _getSubmissionSummary);
+
+
+     
+
+
+
+
+		 
+
+        /**
+         * Auto generated method declaration
+         * for "getJobDetails|http://grid.redhat.com/aviary-query/" operation.
+         * 
+         * @param _getJobDetails of the AviaryQuery::GetJobDetails
+         *
+         * @return AviaryQuery::GetJobDetailsResponse*
+         */
+        
+
+         virtual 
+        AviaryQuery::GetJobDetailsResponse* getJobDetails(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobDetails* _getJobDetails);
+
+
+         /**
+         * Auto generated method declaration
+         * for "getJobSummary|http://grid.redhat.com/aviary-query/" operation.
+         *
+         * @param _getJobSummary of the AviaryQuery::GetJobSummary
+         *
+         * @return AviaryQuery::GetJobSummaryResponse*
+         */
+
+
+         virtual
+        AviaryQuery::GetJobSummaryResponse* getJobSummary(wso2wsf::MessageContext *outCtx ,AviaryQuery::GetJobSummary* _getJobSummary);
+
+
+};
+
+
+}
+
+
+
+        
+#endif // AVIARYQUERYSERVICESKELETON_H
+    
+
diff --git a/src/condor_contrib/aviary/src/AviaryScheddPlugin.cpp b/src/condor_contrib/aviary/src/AviaryScheddPlugin.cpp
new file mode 100644
index 0000000..ec1ceaf
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryScheddPlugin.cpp
@@ -0,0 +1,366 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_qmgr.h"
+#include "condor_config.h"
+
+// local includes
+#include "AviaryScheddPlugin.h"
+#include "Axis2SoapProvider.h"
+#include "SchedulerObject.h"
+
+// Global from the condor_schedd, it's name
+extern char * Name;
+
+// Any key that begins with the '0' char is either the
+// header or a cluster, i.e. not a job
+#define IS_JOB(key) ((key) && '0' != (key)[0])
+
+using namespace std;
+using namespace aviary::job;
+using namespace aviary::soap;
+
+// global SchedulerObject
+// TODO: convert to singleton
+Axis2SoapProvider* provider = NULL;
+SchedulerObject* schedulerObj = NULL;
+
+void
+AviaryScheddPlugin::earlyInitialize()
+{
+
+    // Since this plugin is registered with multiple
+    // PluginManagers it may be initialized more than once,
+    // and we don't want that
+	static bool skip = false;
+	if (skip) return; skip = true;
+
+	// config then env for our all-important axis2 repo dir
+    const char* log_file = "./aviary_job.axis2.log";
+	string repo_path;
+	char *tmp = NULL;
+	if (tmp = param("WSFCPP_HOME")) {
+		repo_path = tmp;
+		free(tmp);
+	}
+	else if (tmp = getenv("WSFCPP_HOME")) {
+		repo_path = tmp;
+	}
+	else {
+		EXCEPT("No WSFCPP_HOME in config or env");
+	}
+
+	int port = param_integer("HTTP_PORT",9090);
+	int level = param_integer("AXIS2_DEBUG_LEVEL",AXIS2_LOG_LEVEL_CRITICAL);
+
+    // init transport here
+    provider = new Axis2SoapProvider(level,log_file,repo_path.c_str());
+    string axis_error;
+    if (!provider->init(port,AXIS2_HTTP_DEFAULT_SO_TIMEOUT,axis_error)) {
+		dprintf(D_ALWAYS, "%s\n",axis_error.c_str());
+        EXCEPT("Failed to initialize Axis2SoapProvider");
+    }
+
+	schedulerObj = SchedulerObject::getInstance();
+
+	dirtyJobs = new DirtyJobsType();
+
+	isHandlerRegistered = false;
+
+	ReliSock *sock = new ReliSock;
+	if (!sock) {
+		EXCEPT("Failed to allocate transport socket");
+	}
+	if (!sock->assign(provider->getHttpListenerSocket())) {
+		EXCEPT("Failed to bind transport socket");
+	}
+	int index;
+	if (-1 == (index =
+			   daemonCore->Register_Socket((Stream *) sock,
+										   "Aviary Method Socket",
+										   (SocketHandlercpp) ( &AviaryScheddPlugin::HandleTransportSocket ),
+										   "Handler for Aviary Methods.",
+										   this))) {
+		EXCEPT("Failed to register transport socket");
+	}
+
+	dprintf(D_ALWAYS,"Axis2 listener on http port: %d\n",port);
+
+	m_initialized = false;
+}
+
+void
+AviaryScheddPlugin::initialize()
+{
+		// Since this plugin is registered with multiple
+		// PluginManagers it may be initialized more than once,
+		// and we don't want that
+	static bool skip = false;
+	if (skip) return; skip = true;
+
+		// WalkJobQueue(int (*func)(ClassAd *))
+	ClassAd *ad = GetNextJob(1);
+	while (ad != NULL) {
+		MyString key;
+		PROC_ID id;
+		int value;
+
+		if (!ad->LookupInteger(ATTR_CLUSTER_ID, id.cluster)) {
+			EXCEPT("%s on job is missing or not an integer", ATTR_CLUSTER_ID);
+		}
+		if (!ad->LookupInteger(ATTR_PROC_ID, id.proc)) {
+			EXCEPT("%s on job is missing or not an integer", ATTR_PROC_ID);
+		}
+		if (!ad->LookupInteger(ATTR_JOB_STATUS, value)) {
+			EXCEPT("%s on job is missing or not an integer", ATTR_JOB_STATUS);
+		}
+
+		key.sprintf("%d.%d", id.cluster, id.proc);
+
+		processJob(key.Value(), ATTR_JOB_STATUS, value);
+
+		FreeJobAd(ad);
+		ad = GetNextJob(0);
+	}
+ 
+	m_initialized = true;
+}
+
+
+void
+AviaryScheddPlugin::shutdown()
+{
+		// Since this plugin is registered with multiple
+		// PluginManagers (eg, shadow) it may be shutdown
+		// more than once, and we don't want that
+	static bool skip = false;
+	if (skip) return; skip = true;
+
+	dprintf(D_FULLDEBUG, "AviaryScheddPlugin: shutting down...\n");
+
+	if (schedulerObj) {
+		delete schedulerObj;
+		schedulerObj = NULL;
+	}
+}
+
+
+void
+AviaryScheddPlugin::update(int cmd, const ClassAd *ad)
+{
+	MyString hashKey;
+
+	switch (cmd) {
+	case UPDATE_SCHEDD_AD:
+		dprintf(D_FULLDEBUG, "Received UPDATE_SCHEDD_AD\n");
+		schedulerObj->update(*ad);
+		break;
+	default:
+		dprintf(D_FULLDEBUG, "Unsupported command: %s\n",
+				getCollectorCommandString(cmd));
+	}
+}
+
+
+void
+AviaryScheddPlugin::archive(const ClassAd */*ad*/) { };
+
+
+void
+AviaryScheddPlugin::newClassAd(const char */*key*/) { };
+
+
+void
+AviaryScheddPlugin::setAttribute(const char *key,
+							   const char *name,
+							   const char *value)
+{
+	if (!m_initialized) return;
+
+//	dprintf(D_FULLDEBUG, "setAttribute: %s[%s] = %s\n", key, name, value);
+
+	markDirty(key, name, value);
+}
+
+
+void
+AviaryScheddPlugin::destroyClassAd(const char *_key)
+{
+	if (!m_initialized) return;
+
+//	dprintf(D_FULLDEBUG, "destroyClassAd: %s\n", key);
+
+	if (!IS_JOB(_key)) return;
+
+		// If we wait to process the deletion the job ad will be gone
+		// and we won't be able to lookup the Submission. So, we must
+		// process the job immediately, but that also means we need to
+		// process all pending changes for the job as well.
+	DirtyJobsType::iterator entry = dirtyJobs->begin();
+	while (dirtyJobs->end() != entry) {
+		string key = (*entry).first;
+		string name = (*entry).second.first;
+		int value = (*entry).second.second;
+
+		if (key == _key) {
+			processJob(key.c_str(), name.c_str(), value);
+
+				// No need to process this entry again later
+			entry = dirtyJobs->erase(entry);
+		} else {
+			entry++;
+		}
+	}
+}
+
+
+void
+AviaryScheddPlugin::deleteAttribute(const char */*key*/,
+								  const char */*name*/) { }
+
+int
+AviaryScheddPlugin::HandleTransportSocket(Stream *)
+{
+    // TODO: respond to a transport callback here?
+    string provider_error;
+    if (!provider->processHttpRequest(provider_error)) {
+        dprintf (D_ALWAYS,"Error processing request: %s\n",provider_error.c_str());
+    }
+
+    return KEEP_STREAM;
+}
+
+void
+AviaryScheddPlugin::processDirtyJobs()
+{
+	BeginTransaction();
+
+	while (!dirtyJobs->empty()) {
+		DirtyJobEntry entry = dirtyJobs->front(); dirtyJobs->pop_front();
+		string key = entry.first;
+		string name = entry.second.first;
+		int value = entry.second.second;
+
+		processJob(key.c_str(), name.c_str(), value);
+	}
+
+	CommitTransaction();
+
+	isHandlerRegistered = false;
+}
+
+
+bool
+AviaryScheddPlugin::processJob(const char *key,
+							 const char *name,
+							 int value)
+{
+	PROC_ID id;
+	ClassAd *jobAd;
+
+		// Skip any key that doesn't point to an actual job
+	if (!IS_JOB(key)) return false;
+
+//	dprintf(D_FULLDEBUG, "Processing: %s\n", key);
+
+	id = getProcByString(key);
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "Failed to parse key: %s - skipping\n", key);
+		return false;
+	}
+
+		// Lookup the job ad assocaited with the key. If it is not
+		// present, skip the key
+	if (NULL == (jobAd = ::GetJobAd(id.cluster, id.proc, false))) {
+		dprintf(D_ALWAYS,
+				"NOTICE: Failed to lookup ad for %s - maybe deleted\n",
+				key);
+		return false;
+	}
+
+		// Store two pieces of information in the Job, 1. the
+		// Submission's name, 2. the Submission's id
+		//
+		// Submissions indexed on their name, the id is present
+		// for reconstruction of the Submission
+
+		// XXX: Use the jobAd instead of GetAttribute below, gets us $$() expansion
+
+	MyString submissionName;
+	if (GetAttributeString(id.cluster, id.proc,
+						   ATTR_JOB_SUBMISSION,
+						   submissionName) < 0) {
+			// Provide a default name for the Submission
+
+			// If we are a DAG node, we default to our DAG group
+		PROC_ID dagman;
+		if (GetAttributeInt(id.cluster, id.proc,
+							ATTR_DAGMAN_JOB_ID,
+							&dagman.cluster) >= 0) {
+			dagman.proc = 0;
+
+			if (GetAttributeString(dagman.cluster, dagman.proc,
+								   ATTR_JOB_SUBMISSION,
+								   submissionName) < 0) {
+					// This can only happen if the DAGMan job was
+					// removed, and we remained, which should not
+					// happen, but could. In such a case we are
+					// orphaned, and we'll make a guess. We'll be
+					// wrong if the DAGMan job didn't use the
+					// default, but it is better to be wrong than
+					// to fail entirely, which is the alternative.
+				submissionName.sprintf("%s#%d", Name, dagman.cluster);
+			}
+		} else {
+			submissionName.sprintf("%s#%d", Name, id.cluster);
+		}
+
+		MyString tmp;
+		tmp += "\"";
+		tmp += submissionName;
+		tmp += "\"";
+		SetAttribute(id.cluster, id.proc,
+					 ATTR_JOB_SUBMISSION,
+					 tmp.Value());
+	}
+}
+
+void
+AviaryScheddPlugin::markDirty(const char *key,
+							const char *name,
+							const char *value)
+{
+	if (!IS_JOB(key)) return;
+	if (!(strcasecmp(name, ATTR_JOB_STATUS) == 0 ||
+		  strcasecmp(name, ATTR_LAST_JOB_STATUS) == 0)) return;
+
+	DirtyJobStatus status(name, atoi(value));
+	DirtyJobEntry entry(key, status);
+	dirtyJobs->push_back(DirtyJobEntry(key, DirtyJobStatus(name, atoi(value))));
+
+	if (!isHandlerRegistered) {
+			// To test destroyClassAd, set the timeout here to a few
+			// seconds, submit a job and immediately delete it.
+		daemonCore->Register_Timer(0,
+								   (TimerHandlercpp)
+								   &AviaryScheddPlugin::processDirtyJobs,
+								   "Process Dirty",
+								   this);
+		isHandlerRegistered = true;
+	}
+}
diff --git a/src/condor_contrib/aviary/src/AviaryScheddPlugin.h b/src/condor_contrib/aviary/src/AviaryScheddPlugin.h
new file mode 100644
index 0000000..ad247ac
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryScheddPlugin.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AVIARYSCHEDDPLUGIN_H
+#define _AVIARYSCHEDDPLUGIN_H
+
+// c++ includes
+#include <list>
+#include <string>
+
+// condor includes
+#include "condor_qmgr.h"
+#include "../condor_schedd.V6/ScheddPlugin.h"
+#include "ClassAdLogPlugin.h"
+#include "../condor_daemon_core.V6/condor_daemon_core.h"
+
+// local includes
+#include "SchedulerObject.h"
+#include "PROC_ID_comparator.h"
+
+
+namespace aviary {
+namespace job {
+
+// BIG NOTE: If Service is not first in the parent list the
+//           processDirtyJobs handler will segfault when using the
+//           dirtyJobs list
+class AviaryScheddPlugin : public Service, ClassAdLogPlugin, ScheddPlugin
+{
+
+public:
+
+	void earlyInitialize();
+
+	void initialize();
+
+	void shutdown();
+
+	void update(int cmd, const ClassAd *ad);
+
+	void archive(const ClassAd *ad);
+
+	void newClassAd(const char */*key*/);
+
+	void setAttribute(const char *key,
+					  const char *name,
+					  const char *value);
+
+	void destroyClassAd(const char *key);
+
+	void deleteAttribute(const char *key,
+						 const char *name);
+
+private:
+
+	typedef std::pair<std::string, int> DirtyJobStatus;
+	typedef std::pair<std::string, DirtyJobStatus> DirtyJobEntry;
+	typedef std::list<DirtyJobEntry> DirtyJobsType;
+	DirtyJobsType *dirtyJobs;
+
+
+	bool isHandlerRegistered;
+
+	bool m_initialized;
+
+	bool m_isPublishing;
+
+	int HandleTransportSocket(Stream *);
+
+	void processDirtyJobs();
+
+	bool processJob(const char *key, const char *name, int value);
+
+	void markDirty(const char *key, const char *name, const char *value);
+
+};
+
+}} /* aviary::job */
+
+#endif /* _AVIARYSCHEDDPLUGIN_H */
diff --git a/src/condor_contrib/aviary/src/AviaryScheddPluginInstantiation.cpp b/src/condor_contrib/aviary/src/AviaryScheddPluginInstantiation.cpp
new file mode 100644
index 0000000..71c40c6
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryScheddPluginInstantiation.cpp
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "condor_common.h"
+
+#include "AviaryScheddPlugin.h"
+
+using namespace aviary::job;
+
+AviaryScheddPlugin *scheddPluginInstance;
+
+#ifndef WIN32
+
+void
+__attribute__ ((constructor))
+init(void)
+{
+    scheddPluginInstance = new AviaryScheddPlugin();
+}
+
+#endif
+
diff --git a/src/condor_contrib/aviary/src/AviaryUtils.cpp b/src/condor_contrib/aviary/src/AviaryUtils.cpp
new file mode 100644
index 0000000..61e0693
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryUtils.cpp
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_classad.h"
+#include "condor_debug.h"
+#include "compat_classad_util.h"
+#include "condor_qmgr.h"
+#include "get_daemon_name.h"
+
+// c++ includes
+#include <map>
+
+// local includes
+#include "AviaryUtils.h"
+
+using namespace std;
+using namespace compat_classad;
+
+string
+aviary::util::getPoolName()
+{
+    string poolName;
+    char *tmp = NULL;
+
+    tmp = param("COLLECTOR_HOST");
+    if (!tmp) {
+        tmp = strdup("NO COLLECTOR_HOST, NOT GOOD");
+    }
+    poolName = tmp;
+    free(tmp); tmp = NULL;
+
+    return poolName;
+}
+
+string
+aviary::util::getScheddName() {
+	string scheddName;
+	char* tmp = NULL;
+
+	tmp = param("SCHEDD_NAME");
+	if (!tmp) {
+		scheddName = default_daemon_name();
+	} else {
+		scheddName = build_valid_daemon_name(tmp);
+		free(tmp); tmp = NULL;
+	}
+
+	return scheddName;
+}
+
+// cleans up the quoted values from the job log reader
+string aviary::util::trimQuotes(const char* str) {
+	string val = str;
+
+	size_t endpos = val.find_last_not_of("\\\"");
+	if( string::npos != endpos ) {
+		val = val.substr( 0, endpos+1 );
+	}
+	size_t startpos = val.find_first_not_of("\\\"");
+	if( string::npos != startpos ) {
+		val = val.substr( startpos );
+	}
+
+	return val;
+}
+
+// validate that an incoming group/user name is
+// alphanumeric, underscores, or a dot separator
+bool aviary::util::isValidGroupUserName(const string& _name, string& _text) {
+	const char* ptr = _name.c_str();
+	while( *ptr ) {
+		char c = *ptr++;
+		if (	('a' > c || c > 'z') &&
+			('A' > c || c > 'Z') &&
+			('0' > c || c > '9') &&
+			(c != '_' ) &&
+			(c != '.' ) ) {
+			_text = "Invalid name for group/user - alphanumeric, underscore and dot characters only";
+			return false;
+		}
+	}
+	return true;
+}
+
+// validate that an incoming attribute name is
+// alphanumeric, or underscores
+bool aviary::util::isValidAttributeName(const string& _name, string& _text) {
+	const char* ptr = _name.c_str();
+	while( *ptr ) {
+		char c = *ptr++;
+		if (	('a' > c || c > 'z') &&
+			('A' > c || c > 'Z') &&
+			('0' > c || c > '9') &&
+			(c != '_' ) ) {
+			_text = "Invalid name for attribute - alphanumeric and underscore characters only";
+			return false;
+		}
+	}
+	return true;
+}
+
+bool aviary::util::checkRequiredAttrs(compat_classad::ClassAd& ad, const char* attrs[], string& missing) {
+	bool status = true;
+	int i = 0;
+
+        while (NULL != attrs[i]) {
+		if (!ad.Lookup(attrs[i])) {
+			missing += " "; missing += attrs[i];
+			status = false;
+		}
+		i++;
+	}
+	return status;
+}
diff --git a/src/condor_contrib/aviary/src/AviaryUtils.h b/src/condor_contrib/aviary/src/AviaryUtils.h
new file mode 100644
index 0000000..b13314d
--- /dev/null
+++ b/src/condor_contrib/aviary/src/AviaryUtils.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AVIARYUTILS_H
+#define _AVIARYUTILS_H
+
+// condor includes
+#include "condor_classad.h"
+
+using namespace std;
+using namespace compat_classad;
+
+namespace aviary {
+namespace util {
+
+string getPoolName();
+
+string getScheddName();
+
+string trimQuotes(const char* value);
+
+bool isValidGroupUserName(const string& _name, string& _text);
+
+bool isValidAttributeName(const string& _name, string& _text);
+
+bool checkRequiredAttrs(ClassAd& ad, const char* attrs[], string& missing);
+
+}}
+
+#endif /* _AVIARYUTILS_H */
diff --git a/src/condor_contrib/aviary/src/Axis2SoapProvider.cpp b/src/condor_contrib/aviary/src/Axis2SoapProvider.cpp
new file mode 100644
index 0000000..fa0e1ca
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Axis2SoapProvider.cpp
@@ -0,0 +1,328 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include <axutil_error_default.h>
+#include <axutil_log_default.h>
+#include <axutil_thread_pool.h>
+#include <axiom_xml_reader.h>
+#include <axutil_file_handler.h>
+#include "Axis2SoapProvider.h"
+
+// NOTE: these types are not in the public
+// Axis2/C API via headers but we need them;
+// review if there is a newer rev after 1.6
+
+// lifted out from http_receiver.c
+typedef struct
+{
+     axis2_transport_receiver_t http_server;
+     axis2_http_svr_thread_t *svr_thread;
+     int port;
+     axis2_conf_ctx_t *conf_ctx;
+     axis2_conf_ctx_t *conf_ctx_private;
+} axis2_http_server_impl_t;
+ 
+#define AXIS2_INTF_TO_IMPL(http_server) \
+ ((axis2_http_server_impl_t *)(http_server))
+ 
+// lifted out from http_svr_thread.c
+struct axis2_http_svr_thread
+{
+    int listen_socket;
+    axis2_bool_t stopped;
+    axis2_http_worker_t *worker;
+    int port;
+};
+
+typedef struct axis2_http_svr_thd_args
+{
+    axutil_env_t *env;
+    axis2_socket_t socket;
+    axis2_http_worker_t *worker;
+    axutil_thread_t *thread;
+} axis2_http_svr_thd_args_t;
+
+using namespace aviary::soap;
+
+Axis2SoapProvider::Axis2SoapProvider(int _log_level, const char* _log_file, const char* _repo_path)
+{
+    if (_log_file) {
+        m_log_file = _log_file;
+    }
+    if (_repo_path) {
+        m_repo_path = _repo_path;
+    }
+    m_log_level = axutil_log_levels_t(_log_level);
+    m_env = NULL;
+    m_http_server = NULL;
+    m_svr_thread = NULL;
+    m_initialized = false;
+}
+
+Axis2SoapProvider::~Axis2SoapProvider()
+{
+    if (m_http_server) {
+        axis2_transport_receiver_free(m_http_server, m_env);
+    }
+
+    if (m_env) {
+        axutil_env_free(m_env);
+    }
+
+    axiom_xml_reader_cleanup();
+
+}
+
+bool
+Axis2SoapProvider::init(int _port, int _read_timeout, std::string& _error)
+{
+    if (m_log_file.empty() || m_repo_path.empty()) {
+        _error = "Log file or repo path is NULL";
+        return false;
+    }
+
+    if (!m_initialized) {
+        axutil_allocator_t* allocator = axutil_allocator_init(NULL);
+        axutil_error_t *error = axutil_error_create(allocator);
+        axutil_log_t *log = axutil_log_create(allocator, NULL, m_log_file.c_str());
+
+        // TODO: not sure we need a TP but don't wanted to get tripped up by a NP
+        // deeper in the stack
+        axutil_thread_pool_t *thread_pool = axutil_thread_pool_init(allocator);
+        axiom_xml_reader_init();
+        m_env = axutil_env_create(allocator);
+        axutil_error_init();
+
+        m_env = axutil_env_create_with_error_log_thread_pool(allocator, error, log, thread_pool);
+        m_env->log->level = m_log_level;
+
+        axis2_status_t status = axutil_file_handler_access(m_repo_path.c_str(), AXIS2_R_OK);
+
+        if (status != AXIS2_SUCCESS) {
+			_error = m_repo_path;
+			_error += " does not exist or insufficient permissions";
+            AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI,_error.c_str());
+            return m_initialized;
+        }
+
+        m_http_server = axis2_http_server_create_with_file(m_env, m_repo_path.c_str(), _port);
+        if (!m_http_server) {
+			_error =  AXIS2_ERROR_GET_MESSAGE(m_env->error);
+            AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI, "HTTP server create failed: %d: %s",
+                            m_env->error->error_number,_error.c_str());
+            return m_initialized;
+        }
+
+        m_svr_thread = createHttpReceiver(m_env,m_http_server,_error); 
+        if (!m_svr_thread) {
+			_error =  AXIS2_ERROR_GET_MESSAGE(m_env->error);
+			AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI, "HTTP receiver create failed: %d: %s",
+                            m_env->error->error_number,_error.c_str());
+            return m_initialized;
+        }
+
+        m_initialized = true;
+    }
+
+    return m_initialized;
+
+}
+
+axis2_http_svr_thread_t*
+Axis2SoapProvider::createHttpReceiver(axutil_env_t* _env, axis2_transport_receiver_t* _server, std::string& _error)
+{
+
+    axis2_http_server_impl_t *server_impl = NULL;
+    axis2_http_worker_t *worker = NULL;
+
+    server_impl = AXIS2_INTF_TO_IMPL(_server);
+    server_impl->svr_thread = axis2_http_svr_thread_create(_env, server_impl->port);
+
+    // shouldn't bother checking this for ST but we'll play along
+    if(!server_impl->svr_thread) {
+        AXIS2_LOG_ERROR(_env->log, AXIS2_LOG_SI, "unable to create server thread for port %d",
+                server_impl->port);
+        return NULL;
+    }
+
+    worker = axis2_http_worker_create(_env, server_impl->conf_ctx);
+    if(!worker) {
+        AXIS2_LOG_ERROR(_env->log, AXIS2_LOG_SI, "axis2 http worker creation failed");
+        axis2_http_svr_thread_free(server_impl->svr_thread, _env);
+        server_impl->svr_thread = NULL;
+        return NULL;
+    }
+
+    axis2_http_worker_set_svr_port(worker, _env, server_impl->port);
+    axis2_http_svr_thread_set_worker(server_impl->svr_thread, _env, worker);
+    return server_impl->svr_thread;
+
+}
+
+SOCKET
+Axis2SoapProvider::getHttpListenerSocket()
+{
+    SOCKET socket = INVALID_SOCKET;
+    if (m_svr_thread) {
+        socket = m_svr_thread->listen_socket;
+    }
+    return socket;
+}
+
+bool
+Axis2SoapProvider::processHttpRequest(std::string& _error)
+{
+    if (!m_initialized) {
+         _error = "Axis2SoapPovider has not been initialized yet";
+        return false;
+    }
+    else {
+
+        AXIS2_ENV_CHECK(m_env, AXIS2_FAILURE);
+
+        int socket = INVALID_SOCKET;
+        axis2_http_svr_thd_args_t *arg_list = NULL;
+
+        socket = (int)axutil_network_handler_svr_socket_accept(m_env, m_svr_thread->listen_socket);
+        if(!m_svr_thread->worker)
+        {
+            AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI,
+                "Worker not ready yet. Cannot serve the request");
+            axutil_network_handler_close_socket(m_env, socket);
+            return false;
+        }
+
+        arg_list = (axis2_http_svr_thd_args_t *)AXIS2_MALLOC(m_env->allocator, sizeof(axis2_http_svr_thd_args_t));
+        if(!arg_list)
+        {
+            AXIS2_LOG_ERROR(m_env->log, AXIS2_LOG_SI,
+                "Memory allocation error in the svr thread loop");
+            return false;
+        }
+
+        arg_list->env = (axutil_env_t *)m_env;
+        arg_list->socket = socket;
+        arg_list->worker = m_svr_thread->worker;
+
+        // single-threaded for DC
+        invokeHttpWorker(NULL, (void *)arg_list);
+    }
+
+    return true;
+}
+
+void *AXIS2_THREAD_FUNC
+Axis2SoapProvider::invokeHttpWorker(
+    axutil_thread_t * thd,
+    void *data)
+{
+    struct AXIS2_PLATFORM_TIMEB t1, t2;
+    axis2_simple_http_svr_conn_t *svr_conn = NULL;
+    axis2_http_simple_request_t *request = NULL;
+    int millisecs = 0;
+    double secs = 0;
+    axis2_http_worker_t *tmp = NULL;
+    axis2_status_t status = AXIS2_FAILURE;
+    axutil_env_t *env = NULL;
+    axis2_socket_t socket;
+    axutil_env_t *thread_env = NULL;
+    axis2_http_svr_thd_args_t *arg_list = NULL;
+
+#ifndef WIN32
+#ifdef AXIS2_SVR_MULTI_THREADED
+    signal(SIGPIPE, SIG_IGN);
+#endif
+#endif
+
+    if(!data)
+    {
+        return NULL;
+    }
+    arg_list = (axis2_http_svr_thd_args_t *)data;
+
+    env = arg_list->env;
+    thread_env = axutil_init_thread_env(env);
+
+    IF_AXIS2_LOG_DEBUG_ENABLED(env->log)
+    {
+        AXIS2_PLATFORM_GET_TIME_IN_MILLIS(&t1);
+    }
+
+    socket = arg_list->socket;
+    svr_conn = axis2_simple_http_svr_conn_create(thread_env, (int)socket);
+    if(!svr_conn)
+    {
+        AXIS2_LOG_ERROR(env->log, AXIS2_LOG_SI, "creating simple_http_svr_connection failed");
+        return NULL;
+    }
+
+    axis2_simple_http_svr_conn_set_rcv_timeout(svr_conn, thread_env, m_http_socket_read_timeout);
+
+    /* read HTTPMethod, URL, HTTP Version and http headers. Leave the remaining in the stream */
+    request = axis2_simple_http_svr_conn_read_request(svr_conn, thread_env);
+    if(!request)
+    {
+        AXIS2_LOG_ERROR(env->log, AXIS2_LOG_SI, "Could not create request");
+        return NULL;
+    }
+
+    tmp = arg_list->worker;
+    status = axis2_http_worker_process_request(tmp, thread_env, svr_conn, request);
+    axis2_simple_http_svr_conn_free(svr_conn, thread_env);
+    axis2_http_simple_request_free(request, thread_env);
+
+    IF_AXIS2_LOG_DEBUG_ENABLED(env->log)
+    {
+        AXIS2_PLATFORM_GET_TIME_IN_MILLIS(&t2);
+        millisecs = t2.millitm - t1.millitm;
+        secs = difftime(t2.time, t1.time);
+        if(millisecs < 0)
+        {
+            millisecs += 1000;
+            secs--;
+        }
+        secs += millisecs / 1000.0;
+
+#if defined(WIN32)
+        AXIS2_LOG_DEBUG(thread_env->log, AXIS2_LOG_SI, "Request processed...");
+#else
+        AXIS2_LOG_DEBUG(thread_env->log, AXIS2_LOG_SI, "Request processed in %.3f seconds", secs);
+#endif
+    }
+
+    if(status == AXIS2_SUCCESS)
+    {
+        AXIS2_LOG_DEBUG(thread_env->log, AXIS2_LOG_SI, "Request served successfully");
+    }
+    else
+    {
+        AXIS2_LOG_WARNING(thread_env->log, AXIS2_LOG_SI, "Error occurred in processing request ");
+    }
+
+    // just ST here
+    AXIS2_FREE(thread_env->allocator, arg_list);
+    axutil_free_thread_env(thread_env);
+    thread_env = NULL;
+
+    return NULL;
+}
+
+// TODO: need a public axis2_tcp_worker.h for this
+//Axis2SoapProvider::processTcpRequest() {
+//    axis2_tcp_worker_process_request();
+//}
diff --git a/src/condor_contrib/aviary/src/Axis2SoapProvider.h b/src/condor_contrib/aviary/src/Axis2SoapProvider.h
new file mode 100644
index 0000000..1828ee8
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Axis2SoapProvider.h
@@ -0,0 +1,80 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _AXIS2SOAPPROVIDER_H
+#define _AXIS2SOAPPROVIDER_H
+
+#include <string>
+#include <axis2_http_server.h>
+#include <axis2_http_transport.h>
+#include <platforms/axutil_platform_auto_sense.h>
+#include <axis2_http_worker.h>
+#include <axutil_network_handler.h>
+#include <axis2_http_svr_thread.h>
+// TODO: future tcp support
+//#include <axis2_tcp_worker.h>
+
+// borrow what DC does
+#if !defined(WIN32)
+#  ifndef SOCKET
+#    define SOCKET int
+#  endif
+#  ifndef INVALID_SOCKET
+#    define INVALID_SOCKET -1
+#  endif
+#endif /* not WIN32 */
+
+#define DEFAULT_LOG_FILE "./axis2.log"
+#define DEFAULT_REPO_FILE "../axis2.xml"
+#define DEFAULT_PORT 9090
+
+// C++ wrapper around a SINGLE-THREADED
+// Axis2/C engine; suitable for integration
+// with DaemonCore socket registration
+// ./configure --enable-multi-thread=no
+
+namespace aviary {
+namespace soap {
+
+class Axis2SoapProvider {
+    public:
+        Axis2SoapProvider(int _log_level=AXIS2_LOG_LEVEL_DEBUG, const char* _log_file=DEFAULT_LOG_FILE, const char* _repo_path=DEFAULT_REPO_FILE);
+        ~Axis2SoapProvider();
+        bool init(int _port, int _read_timeout, std::string& _error);
+        SOCKET getHttpListenerSocket();
+        bool processHttpRequest(std::string& _error);
+
+		const axutil_env_t* getEnv() {return m_env;}
+
+    private:
+        std::string m_log_file;
+        std::string m_repo_path;
+        axutil_log_levels_t m_log_level;
+        axutil_env_t* m_env;
+        axis2_transport_receiver_t* m_http_server;
+        axis2_http_svr_thread_t* m_svr_thread;
+        int m_http_socket_read_timeout;
+        bool m_initialized;
+
+        axis2_http_svr_thread_t* createHttpReceiver(axutil_env_t* _env, axis2_transport_receiver_t* _server, std::string& _error);
+        void *AXIS2_THREAD_FUNC invokeHttpWorker( axutil_thread_t * thd, void *data );
+};
+
+}}
+
+#endif    // _AXIS2SOAPPROVIDER_H
diff --git a/src/condor_contrib/aviary/src/CMakeLists.txt b/src/condor_contrib/aviary/src/CMakeLists.txt
new file mode 100644
index 0000000..b39d38d
--- /dev/null
+++ b/src/condor_contrib/aviary/src/CMakeLists.txt
@@ -0,0 +1,85 @@
+ ###############################################################
+ # 
+ # Copyright (C) 2009-2011, Red Hat, Inc.
+ # 
+ # Licensed under the Apache License, Version 2.0 (the "License"); you 
+ # may not use this file except in compliance with the License.  You may 
+ # obtain a copy of the License at 
+ # 
+ #    http://www.apache.org/licenses/LICENSE-2.0 
+ # 
+ # Unless required by applicable law or agreed to in writing, software 
+ # distributed under the License is distributed on an "AS IS" BASIS, 
+ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ # See the License for the specific language governing permissions and 
+ # limitations under the License. 
+ # 
+ ###############################################################
+
+# shouldn't happen if gen code checked-in
+if ( NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/../codegen" )
+     message( FATAL_ERROR "run ../gen-xsd-cpp.sh first!")
+endif ()
+
+############################
+# file target references.
+############################
+file( GLOB COMMON_GEN_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/../codegen/common/src/*.cpp )
+file( GLOB JOB_GEN_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/../codegen/job/src/*.cpp )
+file( GLOB JOB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/AviaryJobService*.cpp )
+file( GLOB QUERY_GEN_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/../codegen/query/src/*.cpp )
+file( GLOB QUERY_SRCS ${CMAKE_CURRENT_SOURCE_DIR} AviaryQueryService*.cpp )
+
+file( GLOB SCHED_PLUGIN_SRCS Codec.cpp AviaryUtils.cpp SchedulerObject.cpp
+			PROC_ID_comparator.cpp Axis2SoapProvider.cpp AviaryScheddPlugin*.cpp )
+
+file( GLOB JOB_SERVER_SRCS aviary_query_server.cpp Axis2SoapProvider.cpp 
+							SubmissionObject.cpp JobServerJobLogConsumer.cpp
+							Job.cpp HistoryFile.cpp HistoryProcessingUtils.cpp Globals.cpp
+							Codec.cpp JobServerObject.cpp AviaryUtils.cpp )
+
+############################
+# schedd plugin
+############################
+src_target_ref( condor_collector "hashkey" COLLECTOR_REF )
+src_target_ref( utils "set_user_priv_from_ad" UTILS_REF )
+
+add_library (aviary_job_axis SHARED ${COMMON_GEN_SRCS} ${JOB_GEN_SRCS} ${JOB_SRCS} Codec.cpp AviaryUtils.cpp SchedulerObject.cpp )
+# remove unresolved deps by copying in -lwso2_wsf objects
+target_link_libraries(aviary_job_axis --whole-archive -lwso2_wsf --no-whole-archive)
+
+condor_plugin( AviaryScheddPlugin-plugin "${COLLECTOR_REF};${UTILS_REF};${SCHED_PLUGIN_SRCS}" "${C_LIBEXEC}" "${WSO2_FOUND}" ON)
+# remove unresolved deps by copying in -laxis2_engine objects
+target_link_libraries(AviaryScheddPlugin-plugin --whole-archive -laxis2_engine --no-whole-archive)
+
+############################
+# query server (aka ye old job server)
+############################
+add_library (aviary_query_axis SHARED ${COMMON_GEN_SRCS} ${QUERY_GEN_SRCS} ${QUERY_SRCS} )
+target_link_libraries (aviary_query_axis ${WSO2_FOUND})
+
+condor_exe( aviary_query_server "${JOB_SERVER_SRCS}"
+			"${C_SBIN}" "${CONDOR_LIBS};${PCRE_FOUND};${OPENSSL_FOUND};${COREDUMPER_FOUND};${KRB5_FOUND};${GLOBUS_FOUND};${GCB_FOUND};${WSO2_FOUND}" OFF )
+
+############################
+# install targets && configure our axis2.xml for platform
+############################
+configure_file("${CMAKE_CURRENT_SOURCE_DIR}/../etc/axis2.xml.in" "${CMAKE_CURRENT_BINARY_DIR}/../etc/axis2.xml" @ONLY)
+install (FILES ${CMAKE_CURRENT_BINARY_DIR}/../etc/axis2.xml DESTINATION ${CMAKE_INSTALL_PREFIX} )
+
+install (TARGETS aviary_query_axis DESTINATION ${C_SERVICES}/query)
+install (FILES ${CMAKE_CURRENT_SOURCE_DIR}/../services/query/services.xml DESTINATION ${C_SERVICES}/query )
+install (FILES ${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-common.xsd
+			${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-query.xsd
+			${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-query.wsdl
+		DESTINATION ${C_SERVICES}/query )
+
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/../etc/61aviary.config DESTINATION "${C_ETC_EXAMPLES}")
+
+install (TARGETS aviary_job_axis DESTINATION ${C_SERVICES}/job)
+install (FILES ${CMAKE_CURRENT_SOURCE_DIR}/../services/job/services.xml DESTINATION ${C_SERVICES}/job )
+install (FILES ${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-common.xsd
+				${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-job.xsd
+				${CMAKE_CURRENT_SOURCE_DIR}/../etc/aviary-job.wsdl
+		DESTINATION ${C_SERVICES}/job )
+
diff --git a/src/condor_contrib/aviary/src/Codec.cpp b/src/condor_contrib/aviary/src/Codec.cpp
new file mode 100644
index 0000000..aa3535b
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Codec.cpp
@@ -0,0 +1,144 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_qmgr.h"
+
+// local includes
+#include "Codec.h"
+#include "AviaryUtils.h"
+
+using namespace compat_classad;
+using namespace aviary::codec;
+using namespace aviary::util;
+
+// TODO: defer until linking issues sorted
+//Codec*
+//DefaultCodecFactory::createCodec() {
+//    if (!m_codec) {
+//        m_codec = new BaseCodec;
+//    }
+//    return m_codec;
+//}
+
+BaseCodec::BaseCodec()
+{
+    //
+}
+
+BaseCodec::~BaseCodec()
+{
+    //
+}
+
+
+bool
+BaseCodec::addAttributeToMap (ClassAd& ad, const char* name, AttributeMapType& _map)
+{
+    ExprTree *expr;
+
+    // All these extra lookups are horrible. They have to
+    // be there because the ClassAd may have multiple
+    // copies of the same attribute name! This means that
+    // the last attribute with a given name will set the
+    // value, but the last attribute tends to be the
+    // attribute with the oldest (wrong) value. How
+    // annoying is that!
+    if (!(expr = ad.Lookup(name))) {
+        dprintf(D_FULLDEBUG, "Warning: failed to lookup attribute '%s' from ad\n", name);
+        return false;
+    }
+
+    classad::Value value;
+    ad.EvaluateExpr(expr,value);
+	const char* key = strdup(name);
+    switch (value.GetType()) {
+        // seems this covers expressions also
+        case classad::Value::BOOLEAN_VALUE:
+            _map[key] = new AviaryAttribute(AviaryAttribute::EXPR_TYPE,strdup(trimQuotes(ExprTreeToString(expr)).c_str()));
+            break;
+        case classad::Value::INTEGER_VALUE:
+            _map[key] = new AviaryAttribute(AviaryAttribute::INTEGER_TYPE,strdup(ExprTreeToString(expr)));;
+            break;
+        case classad::Value::REAL_VALUE:
+            _map[key] = new AviaryAttribute(AviaryAttribute::FLOAT_TYPE,strdup(ExprTreeToString(expr)));
+            break;
+        case classad::Value::STRING_VALUE:
+        default:
+            _map[key] = new AviaryAttribute(AviaryAttribute::STRING_TYPE,strdup(trimQuotes(ExprTreeToString(expr)).c_str()));
+    }
+
+    return true;
+}
+
+bool
+BaseCodec::classAdToMap(ClassAd& ad, AttributeMapType& _map)
+{
+    ExprTree *expr;
+	const char *name;
+	ad.ResetExpr();
+	_map.clear();
+	while (ad.NextExpr(name,expr)) {
+		if (!addAttributeToMap(ad, name, _map)) {
+                    return false;
+		}
+	}
+
+// //debug
+//        if (DebugFlags & D_FULLDEBUG) {
+//            ad.dPrint(D_FULLDEBUG|D_NOHEADER);
+//        }
+
+    return true;
+}
+
+
+bool
+BaseCodec::mapToClassAd(AttributeMapType& _map, ClassAd& ad)
+{
+
+    for (AttributeMapIterator entry = _map.begin(); _map.end() != entry; entry++) {
+        const char* name = entry->first;
+        AviaryAttribute* value = entry->second;
+
+        switch (value->getType()) {
+            case AviaryAttribute::INTEGER_TYPE:
+                ad.Assign(name, atoi(value->getValue()));
+                break;
+            case AviaryAttribute::FLOAT_TYPE:
+                ad.Assign(name, atof(value->getValue()));
+                break;
+            case AviaryAttribute::STRING_TYPE:
+                ad.Assign(name, value->getValue());
+                break;
+            case AviaryAttribute::EXPR_TYPE:
+                ad.AssignExpr(name, value->getValue());
+                break;
+            default:
+                dprintf(D_FULLDEBUG, "Warning: Unknown/unsupported type in map for attribute '%s'\n", name);
+        }
+    }
+
+//     // debug
+//     if (DebugFlags & D_FULLDEBUG) {
+//           ad.dPrint(D_FULLDEBUG|D_NOHEADER);
+//     }
+
+    return true;
+}
diff --git a/src/condor_contrib/aviary/src/Codec.h b/src/condor_contrib/aviary/src/Codec.h
new file mode 100644
index 0000000..b73a958
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Codec.h
@@ -0,0 +1,127 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _CODEC_H
+#define _CODEC_H
+
+// c++ includes
+#include <map>
+#include <vector>
+
+// condor includes
+#include <compat_classad.h>
+
+using namespace std;
+using namespace compat_classad;
+
+namespace aviary {
+namespace codec {
+
+// universal err struct
+struct AviaryStatus
+{
+	// keep these aligned with whatever public API
+	// in XSD, JSON, etc.
+    enum StatusType
+    {
+		// don't use "OK"
+        A_OK = 0,
+        FAIL = 1,
+        NO_MATCH = 2,
+        STRING_TYPE = 3,
+		INVALID_OFFSET = 4,
+		UNIMPLEMENTED = 5,
+		UNAVAILABLE = 6
+    };
+
+    StatusType type;
+    string text;
+};
+
+class AviaryAttribute
+{
+public:
+    enum AttributeType
+    {
+        EXPR_TYPE = 0,
+        INTEGER_TYPE = 1,
+        FLOAT_TYPE = 2,
+        STRING_TYPE = 3
+    };
+    AviaryAttribute ( AttributeType _type, const char* _value): m_type(_type), m_value(_value) {};
+    ~AviaryAttribute();
+
+    AttributeType getType() const { return m_type; }
+    const char * getValue() const { return m_value; }
+
+private:
+    AttributeType m_type;
+    const char * m_value;
+};
+
+typedef map<const char*, AviaryAttribute*> AttributeMapType;
+typedef AttributeMapType::const_iterator AttributeMapIterator;
+
+// TODO: revisit
+// singleton class for encoding/decoding from/to transport-specific types
+// to a simple type to be used in the impl;
+// intent is to sit above ClassAds but still interact with them;
+// base is suitable for SOAP, but QMF might need subclassing
+// with it's !!descriptors idiom
+class Codec {
+public:
+    virtual bool addAttributeToMap(ClassAd& ad, const char* name, AttributeMapType& _map) = 0;
+    virtual bool classAdToMap(ClassAd &ad, AttributeMapType &_map) = 0;
+    virtual bool mapToClassAd(AttributeMapType &_map, ClassAd &ad) = 0;
+
+};
+
+// TODO: defer until linking issues sorted
+//class CodecFactory {
+// public:
+//     virtual Codec* createCodec() = 0;
+// 
+// };
+// 
+// class DefaultCodecFactory: public CodecFactory {
+// public:
+//     virtual Codec* createCodec();
+// protected:
+//     Codec* m_codec;
+// };
+
+class BaseCodec: public Codec {
+public:
+    //friend class DefaultCodecFactory;
+    virtual bool addAttributeToMap(ClassAd& ad, const char* name, AttributeMapType& _map);
+    virtual bool classAdToMap(ClassAd &ad, AttributeMapType &_map);
+    virtual bool mapToClassAd(AttributeMapType &_map, ClassAd &ad);
+
+//protected:
+    BaseCodec();
+    ~BaseCodec();
+
+private:
+    BaseCodec (const BaseCodec &);
+    BaseCodec& operator= (const BaseCodec &);
+
+};
+
+}}
+
+#endif    // _CODEC_H
diff --git a/src/condor_contrib/aviary/src/Globals.cpp b/src/condor_contrib/aviary/src/Globals.cpp
new file mode 100644
index 0000000..14e36fb
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Globals.cpp
@@ -0,0 +1,29 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include "Globals.h"
+
+namespace aviary {
+namespace query {
+
+JobCollectionType g_jobs;
+SubmissionCollectionType g_submissions;
+OwnerlessClusterType g_ownerless_clusters;
+OwnerlessSubmissionType g_ownerless_submissions;
+
+}}
\ No newline at end of file
diff --git a/src/condor_contrib/aviary/src/Globals.h b/src/condor_contrib/aviary/src/Globals.h
new file mode 100644
index 0000000..2b09add
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Globals.h
@@ -0,0 +1,51 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _GLOBALS_H
+#define _GLOBALS_H
+
+// condor includes
+#include "condor_common.h"
+
+// c++ includes
+#include <map>
+
+// local includes
+#include "Job.h"
+#include "JobServerObject.h"
+#include "SubmissionObject.h"
+#include "cmpstr.h"
+
+using namespace std;
+
+namespace aviary {
+namespace query {
+
+typedef map<const char *, Job *, cmpstr> JobCollectionType;
+typedef map<const char *, SubmissionObject *, cmpstr> SubmissionCollectionType;
+typedef map<int, string> OwnerlessClusterType;
+typedef map<int, SubmissionObject*> OwnerlessSubmissionType;
+
+extern JobCollectionType g_jobs;
+extern SubmissionCollectionType g_submissions;
+extern OwnerlessClusterType g_ownerless_clusters;
+extern OwnerlessSubmissionType g_ownerless_submissions;
+
+}}
+
+#endif /* _GLOBALS_H */
diff --git a/src/condor_contrib/aviary/src/HistoryFile.cpp b/src/condor_contrib/aviary/src/HistoryFile.cpp
new file mode 100644
index 0000000..81cc624
--- /dev/null
+++ b/src/condor_contrib/aviary/src/HistoryFile.cpp
@@ -0,0 +1,380 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "condor_common.h"
+
+#include "condor_config.h"
+#include "condor_debug.h"
+
+#include "condor_attributes.h"
+
+#include "directory.h"
+
+#include "HistoryFile.h"
+
+#include "HistoryProcessingUtils.h"
+
+#include <libgen.h> // dirname
+
+#include <string>
+
+#define HISTORY_INDEX_SUFFIX ".idx"
+using std::string;
+
+
+HistoryFile::HistoryFile(const string name):
+	m_name(name),
+	m_stat(NULL),
+	m_file(NULL),
+	m_index(NULL)
+{
+}
+
+HistoryFile::~HistoryFile()
+{
+	cleanup();
+}
+
+void
+HistoryFile::cleanup()
+{
+	m_entries.clear();
+	if (m_file) { fclose(m_file); m_file = NULL; }
+	if (m_index) { fclose(m_index); m_index = NULL; }
+	if (m_stat) { free(m_stat); m_stat = NULL; }
+}
+
+HistoryFile::HistoryFile(const HistoryFile &base)
+{
+	m_file = NULL;
+	m_index = NULL;
+	m_stat = NULL;
+
+	*this = base;
+}
+
+HistoryFile &
+HistoryFile::operator=(const HistoryFile &base)
+{
+	if (this != &base) {
+		(*this).m_name = base.m_name;
+
+		cleanup();
+
+		// Don't just copy the stat and FILE* members, initialize them
+		CondorError errstack;
+		if (!init(errstack)) {
+			// XXX: Should throw an exception here
+			dprintf ( D_ALWAYS, "HistoryFile::operator=: %s\n",
+					errstack.getFullText(true));		
+		}
+	}
+
+	return *this;
+}
+
+bool
+HistoryFile::init(CondorError &errstack)
+{
+	StatWrapper stat_wrapper;
+
+	if (stat_wrapper.Stat(m_name.c_str())) {
+		errstack.pushf("HistoryFile::init", 1,
+					   "Failed to stat %s: %d (%s)\n",
+					   m_name.c_str(),
+					   stat_wrapper.GetErrno(),
+					   strerror(stat_wrapper.GetErrno()));
+		return false;
+	}
+
+	m_stat = (StatStructType *) malloc(sizeof(StatStructType));
+	ASSERT(m_stat);
+	memcpy(m_stat, stat_wrapper.GetBuf(), sizeof(StatStructType));
+	if (!S_ISREG(m_stat->st_mode)) {
+		errstack.pushf("HistoryFile::init", 2,
+					   "%s: not a regular file\n",
+					   m_name.c_str());
+		return false;
+	}
+
+	m_file = safe_fopen_wrapper(m_name.c_str(), "r");
+	if (NULL == m_file) {
+		errstack.pushf("HistoryFile::init", 4,
+					   "Failed to fopen %s: %d (%s)\n",
+					   m_name.c_str(), errno, strerror(errno));
+		return false;
+	}
+
+	// Store the index in history.INO.idx to handle renames
+	MyString tmp;
+	char *buf = strdup(m_name.c_str());
+	ASSERT(buf);
+	long unsigned int id;
+	ASSERT(getId(id));
+	tmp.sprintf("%s%shistory.%ld%s", dirname(buf), DIR_DELIM_STRING, id, HISTORY_INDEX_SUFFIX);
+	m_index_name = tmp.Value();
+	free(buf);
+
+	const char *mode = "r+";
+
+	if (stat_wrapper.Stat(m_index_name.c_str())) {
+			// Not being available is acceptable
+		if (ENOENT != stat_wrapper.GetErrno()) {
+			errstack.pushf("HistoryFile::init", 1,
+						   "Failed to stat %s: %d (%s)\n",
+						   m_index_name.c_str(),
+						   stat_wrapper.GetErrno(),
+						   strerror(stat_wrapper.GetErrno()));
+			return false;
+		}
+
+		mode = "w+";
+ 	}
+
+	const StatStructType *stat = stat_wrapper.GetBuf();
+	if (!S_ISREG(stat->st_mode)) {
+		errstack.pushf("HistoryFile::init", 2,
+					   "%s: not a regular file\n",
+					   m_index_name.c_str());
+		return false;
+	}
+
+	m_index = safe_fopen_wrapper(m_index_name.c_str(), mode);
+	if (NULL == m_index) {
+		errstack.pushf("HistoryFile::init", 4,
+					   "Failed to fopen %s: %d (%s)\n",
+					   m_index_name.c_str(), errno, strerror(errno));
+		return false;
+	}
+
+	return true;
+}
+
+bool
+HistoryFile::getId(long unsigned int &id)
+{
+	if (!m_stat) return false;
+
+	id = m_stat->st_ino;
+	return true;
+}
+
+HistoryFile::HistoryEntriesTypeIterators
+HistoryFile::poll(CondorError &/*errstack*/)
+{
+	// Record the end of the current set of records, used to
+	// return just the newly read records
+	int size = m_entries.size();
+
+	// Load from the index
+	CondorError ignored_errstack;
+	if (!pollIndex(ignored_errstack)) {
+		dprintf(D_FULLDEBUG, "%s\n", ignored_errstack.getFullText(true));		
+	}
+
+	// Seek to the end of the last known record
+	if (!m_entries.empty()) {
+		HistoryEntry entry = m_entries.back();
+		fseek(m_file, entry.stop, SEEK_SET);
+	}
+
+	int end, error, empty;
+	end = 0;
+	while (!end) {
+		long int start, stop;
+
+		start = ftell(m_file);
+
+		// NOTE: If the ClassAd parsing completes without finding
+		// the delimiter the result is end=1 and empty=0. This
+		// should be sufficient for identifying incomplete
+		// records that are otherwise valid.
+		ClassAd ad(m_file, "***", end, error, empty);
+
+		stop = ftell(m_file);
+
+		if (end) continue;
+		if (error) {
+			error = 0;
+			dprintf(D_ALWAYS, "HistoryFile::poll: malformed ad, skipping\n");
+			continue;
+		}
+		if (empty) {
+			empty = 0;
+			dprintf(D_ALWAYS, "HistoryFile::poll: empty ad, skipping\n");
+			continue;
+		}
+
+		int cluster, proc, q_date, status, entered_status;
+		char *global_id = NULL, *cmd = NULL, *args1 = NULL, *args2 = NULL;
+		char *release_reason = NULL, *hold_reason = NULL;
+		char *submission = NULL;
+		char *owner = NULL;
+		if (!ad.LookupInteger(ATTR_CLUSTER_ID, cluster)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping\n",
+					ATTR_CLUSTER_ID);
+			continue;
+		}
+		if (!ad.LookupInteger(ATTR_PROC_ID, proc)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping\n",
+					ATTR_PROC_ID);
+			continue;
+		}
+		if (!ad.LookupInteger(ATTR_Q_DATE, q_date)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_Q_DATE, cluster, proc);
+			continue;
+		}
+		if (!ad.LookupInteger(ATTR_JOB_STATUS, status)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_JOB_STATUS, cluster, proc);
+			continue;
+		}
+		if (!ad.LookupInteger(ATTR_ENTERED_CURRENT_STATUS, entered_status)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_ENTERED_CURRENT_STATUS, cluster, proc);
+			continue;
+		}
+		if (!ad.LookupString(ATTR_GLOBAL_JOB_ID, &global_id)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_GLOBAL_JOB_ID, cluster, proc);
+			continue;
+		}
+		if (!ad.LookupString(ATTR_JOB_CMD, &cmd)) {
+			dprintf(D_ALWAYS, "HistoryFile::poll: no %s, skipping: %d.%d\n",
+					ATTR_JOB_CMD, cluster, proc);
+			continue;
+		}
+		ad.LookupString(ATTR_JOB_ARGUMENTS1, &args1);
+		ad.LookupString(ATTR_JOB_ARGUMENTS2, &args2);
+		ad.LookupString(ATTR_RELEASE_REASON, &release_reason);
+		ad.LookupString(ATTR_HOLD_REASON, &hold_reason);
+		ad.LookupString(ATTR_JOB_SUBMISSION, &submission);
+		ad.LookupString(ATTR_OWNER, &owner);
+
+		// Write an index record
+		fprintf(m_index,
+				"%ld %ld %s %d %d %d %d %d\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
+				start, stop, global_id,
+				cluster, proc,
+				q_date, status, entered_status,
+				submission ? submission : "",
+				owner ? owner : "",
+				cmd,
+				args1 ? args1 : "",
+				args2 ? args2 : "",
+				release_reason ? release_reason : "",
+				hold_reason ? hold_reason : "");
+
+		HistoryEntry entry;
+
+		entry.file = m_name;
+		entry.start = start;
+		entry.stop = stop;
+		entry.id = global_id;
+		entry.cluster = cluster;
+		entry.proc = proc;
+		entry.q_date = q_date;
+		entry.status = status;
+		entry.entered_status = entered_status;
+		if (submission) entry.submission = submission;
+		if (owner) entry.owner = owner;
+		entry.cmd = cmd;
+		if (args1) entry.args1 = args1;
+		if (args2) entry.args2 = args2;
+		if (release_reason) entry.release_reason = release_reason;
+		if (hold_reason) entry.hold_reason = hold_reason;
+
+		m_entries.push_back(entry);
+	}
+
+		// Return iterators for newly read records
+	return HistoryFile::HistoryEntriesTypeIterators(m_entries.begin() + size,
+													m_entries.end());
+}
+
+/**
+ * Index format:
+ *  start(%ld) stop(%ld) id(%s) cluster(%d) proc(%d) q_date(%d) status(%d) entered_status(%d)
+ *  submission(%s)
+ *  cmd(%s)
+ *  args1(%s)
+ * 	args2(%s)
+ *  release_reason(%s)
+ *  hold_reason(%s)
+ */
+bool
+HistoryFile::pollIndex(CondorError &errstack)
+{
+	while (1) {
+		int code;
+		HistoryEntry entry;
+
+		entry.file = m_name;
+		char *id = NULL;
+		code = fscanf(m_index, "%ld %ld %as %d %d %d %d %d",
+					  &entry.start, &entry.stop, &id,
+					  &entry.cluster, &entry.proc,
+					  &entry.q_date, &entry.status, &entry.entered_status);
+		if (code != 8) {
+			// Ok, at the end of the file, we're done
+			// code check is to handle truncated final entry
+			if (feof(m_index) && code < 0) {
+				break;
+			}
+
+			// XXX: EINTR?
+			errstack.pushf("HistoryFile::pollIndex", 6,
+						   "Failed to fscanf HistoryEntry from %s, "
+						   "rc=%d: %d (%s)\n",
+						   m_index_name.c_str(), code, errno, strerror(errno));
+
+			return false;
+		}
+
+		MyString buf;
+
+		buf.readLine(m_index); // consume newline
+
+#define BUF_SET(dest,attr)											\
+		if (buf.readLine(m_index)) {								\
+			buf.trim();												\
+			if (!buf.IsEmpty()) {									\
+				dest = buf.Value();									\
+			}														\
+		} else {													\
+			errstack.pushf("HistoryFile::pollIndex", 7,				\
+						   "Failed to read %s's %s from %s\n",		\
+						   id, attr, m_index_name.c_str());			\
+			return false;											\
+		}
+
+		BUF_SET(entry.submission, ATTR_JOB_SUBMISSION);
+		BUF_SET(entry.owner, ATTR_OWNER);
+		BUF_SET(entry.cmd, ATTR_JOB_CMD);
+		BUF_SET(entry.args1, ATTR_JOB_ARGUMENTS1);
+		BUF_SET(entry.args2, ATTR_JOB_ARGUMENTS2);
+		BUF_SET(entry.release_reason, ATTR_RELEASE_REASON);
+		BUF_SET(entry.hold_reason, ATTR_HOLD_REASON);
+
+		entry.id = id;
+		free(id); id = NULL;
+
+		m_entries.push_back(entry);
+	}
+
+	return true;
+}
diff --git a/src/condor_contrib/aviary/src/HistoryFile.h b/src/condor_contrib/aviary/src/HistoryFile.h
new file mode 100644
index 0000000..a7b0adc
--- /dev/null
+++ b/src/condor_contrib/aviary/src/HistoryFile.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _HISTORYFILE_H
+#define _HISTORYFILE_H
+
+#include <string>
+#include <deque>
+
+using std::string;
+using std::deque;
+using std::pair;
+
+#include "stat_wrapper.h"
+#include "CondorError.h"
+
+namespace aviary {
+namespace history {
+		
+struct HistoryEntry
+{
+	string file;
+	long int start; // ftell stream index for record start
+	long int stop;  // ftell stream index for record end
+	string id;
+	int q_date;
+	int cluster;
+	int proc;
+	int status;
+	int entered_status;
+	string submission;
+	string owner;
+	string cmd;
+	string args1;
+	string args2;
+	string release_reason;
+	string hold_reason;
+};
+
+class HistoryFile
+{
+public:
+	typedef deque<HistoryEntry> HistoryEntriesType;
+	typedef HistoryEntriesType::const_iterator HistoryEntriesTypeIterator;
+	typedef pair<HistoryEntriesTypeIterator,
+				 HistoryEntriesTypeIterator> HistoryEntriesTypeIterators;
+
+	HistoryFile(const string name);
+
+	~HistoryFile();
+
+	HistoryFile(const HistoryFile &base);
+	HistoryFile & operator=(const HistoryFile &base);
+
+	bool init(CondorError &errstack);
+
+	bool getId(long unsigned int &id);
+
+	HistoryEntriesTypeIterators poll(CondorError &errstack);
+
+	void cleanup();
+
+private:
+	string m_name;
+	string m_index_name;
+	HistoryEntriesType m_entries;
+	StatStructType *m_stat;
+	FILE *m_file;
+	FILE *m_index;
+
+	bool pollIndex(CondorError &errstack);
+
+};
+
+}}
+
+#endif /* _HISTORYFILE_H */
diff --git a/src/condor_contrib/aviary/src/HistoryProcessingUtils.cpp b/src/condor_contrib/aviary/src/HistoryProcessingUtils.cpp
new file mode 100644
index 0000000..0936f4d
--- /dev/null
+++ b/src/condor_contrib/aviary/src/HistoryProcessingUtils.cpp
@@ -0,0 +1,265 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_debug.h"
+#include "condor_attributes.h"
+#include "CondorError.h"
+#include "directory.h"
+#include "stat_wrapper.h"
+
+//local includes
+#include "JobServerJobLogConsumer.h"
+#include "Job.h"
+#include "HistoryProcessingUtils.h"
+#include "HistoryFile.h"
+#include "AviaryUtils.h"
+#include "Globals.h"
+
+// platform includes
+#include <libgen.h> // dirname
+
+// c++ includes
+#include <string>
+#include <deque>
+#include <set>
+
+using namespace aviary::query;
+
+#define HISTORY_INDEX_SUFFIX ".idx"
+using namespace std;
+
+typedef set<long unsigned int> HistoryFileListType;
+static HistoryFileListType m_historyFiles;
+MyString m_path;
+
+// force a reset of history processing
+void aviary::history::init_history_files() {
+    m_historyFiles.clear();
+    processHistoryDirectory();
+    processOrphanedIndices();
+    processCurrentHistory(true);
+}
+
+// Processing jobs from history file must allow for
+// duplicates, such as when current history file is renamed.
+static
+void
+process ( const HistoryEntry &entry )
+{
+    MyString key;
+
+    key.sprintf ( "%d.%d", entry.cluster, entry.proc );
+
+    const char* key_cstr = key.StrDup();
+
+    HistoryJobImpl *hji = new HistoryJobImpl (entry);
+
+    JobCollectionType::const_iterator element = g_jobs.find ( key_cstr );
+    if ( g_jobs.end() != element )
+    {
+	(*element).second->setImpl(hji);
+	dprintf ( D_FULLDEBUG, "HistoryJobImpl added to '%s'\n", key_cstr );
+    }
+    else {
+      // live job long gone...could be a restart
+      Job* job = new Job(key_cstr);
+      job->setImpl(hji);
+      g_jobs[key_cstr] = job;
+      dprintf ( D_FULLDEBUG, "HistoryJobImpl created for '%s'\n", key_cstr);
+    }
+
+	// // debug
+	// fprintf ( stdout,
+	//          "%ld %ld %s %d %d %d %d %d %s %s %s %s %s %s %s\n",
+	//          entry.start, entry.stop, entry.id.c_str(),
+	//          entry.cluster, entry.proc,
+	//          entry.q_date, entry.status, entry.entered_status,
+	//          entry.submission.c_str(),
+	//          entry.owner.c_str(),
+	//          entry.cmd.c_str(),
+	//          entry.args1.c_str(),
+	//          entry.args2.c_str(),
+	//          entry.release_reason.c_str(),
+	//          entry.hold_reason.c_str() );
+}
+
+/**
+ * Process the history directory and maintain the history file map
+ *
+ * Only handle rotated history files, those history.* that are not an
+ * index. For each one that is not in the history file map, create a
+ * new HistoryFile, poll it for entries to process, and add it to the
+ * map.
+ */
+void
+aviary::history::processHistoryDirectory()
+{
+    const char *file = NULL;
+
+    Directory dir ( m_path.Value() );
+    dir.Rewind();
+    while ( ( file = dir.Next() ) )
+    {
+        // Skip all non-history files, e.g. history and history.*.idx
+        if ( strncmp ( file, "history.", 8 ) ||
+                !strncmp ( file + ( strlen ( file ) - 4 ), HISTORY_INDEX_SUFFIX, 4 ) ) continue;
+
+        HistoryFile h_file ( ( m_path + DIR_DELIM_STRING + file ).Value() );
+        CondorError errstack;
+        if ( !h_file.init ( errstack ) )
+        {
+            dprintf ( D_ALWAYS, "%s\n", errstack.getFullText() );
+            return;
+        }
+        errstack.clear();
+
+        long unsigned int id;
+        ASSERT ( h_file.getId ( id ) );
+        HistoryFileListType::iterator entry = m_historyFiles.find ( id );
+        if ( m_historyFiles.end() == entry )
+        {
+            HistoryFile::HistoryEntriesTypeIterators ij = h_file.poll ( errstack );
+            for ( HistoryFile::HistoryEntriesTypeIterator i = ij.first;
+                    i != ij.second;
+                    i++ )
+            {
+                process ( ( *i ) );
+            }
+
+            m_historyFiles.insert ( id );
+        }
+    }
+}
+
+/**
+ * Process orphaned index files, those that exist but do not have a
+ * corresponding history file.
+ *
+ * Process all .idx files looking for the corresponding HistoryFile in
+ * the history file map.
+ */
+void
+aviary::history::processOrphanedIndices()
+{
+    const char *file = NULL;
+
+    Directory dir ( m_path.Value() );
+    dir.Rewind();
+    while ( ( file = dir.Next() ) )
+    {
+        // Skip all non-history index files, e.g. history and history.*
+        if ( strncmp ( file, "history.", 8 ) ||
+                strncmp ( file + ( strlen ( file ) - 4 ), HISTORY_INDEX_SUFFIX, 4 ) ) continue;
+
+        // XXX: This is ugly because it indicates we know details
+        // of how HistoryFile implements index files.
+
+        // The index file is "history.%ld.idx" where %ld is the id
+        // of the history file the index is for.
+
+        long unsigned int id;
+        int count = sscanf ( file, "history.%ld.idx", &id );
+        if ( 1 != count )
+        {
+            dprintf ( D_ALWAYS, "Error parsing %s, skipping.\n", file );
+            continue;
+        }
+
+        HistoryFileListType::iterator entry = m_historyFiles.find ( id );
+        if ( m_historyFiles.end() == entry )
+        {
+            // The index is dangling, remove it.
+            if ( !dir.Remove_Current_File() )
+            {
+               dprintf ( D_ALWAYS, "Failed to remove: %s\n", file );
+            }
+        }
+    }
+}
+
+/**
+ * Process the current history file.
+ *
+ * 1) check to see if it is properly initialized, recording id (inode)
+ * 2) stat the current history file
+ * 3) poll for new entries and process them
+ * 4) detect rotations
+ */
+void
+aviary::history::processCurrentHistory(bool force_reset)
+{
+    static MyString currentHistoryFilename = m_path + DIR_DELIM_STRING + "history";
+    static HistoryFile currentHistory ( currentHistoryFilename.Value() );
+
+    CondorError errstack;
+
+    if (force_reset) {
+       currentHistory.cleanup();
+    }
+
+	// (1)
+    long unsigned int id;
+    if ( !currentHistory.getId ( id ) || force_reset)
+    {
+        if ( !currentHistory.init ( errstack ) )
+        {
+            dprintf ( D_ALWAYS, "%s\n", errstack.getFullText() );
+            return;
+        }
+        ASSERT ( currentHistory.getId ( id ) );
+        m_historyFiles.insert ( id );
+    }
+
+    // (2)
+    // Stat before poll to handle race of: poll + write + rotate + stat
+    StatWrapper stat_wrapper;
+    if ( stat_wrapper.Stat ( currentHistoryFilename ) )
+    {
+        dprintf ( D_ALWAYS, "Failed to stat %s: %d (%s)\n",
+                  currentHistoryFilename.Value(),
+                  stat_wrapper.GetErrno(), strerror ( stat_wrapper.GetErrno() ) );
+        return;
+    }
+    const StatStructType *stat = stat_wrapper.GetBuf();
+    ASSERT ( currentHistory.getId ( id ) );
+
+    // (3)
+    errstack.clear();
+    HistoryFile::HistoryEntriesTypeIterators poll = currentHistory.poll ( errstack );
+    for ( HistoryFile::HistoryEntriesTypeIterator i = poll.first;
+            i != poll.second;
+            i++ )
+    {
+        process ( ( *i ) );
+    }
+
+    // (4)
+    // If different the file has rotated
+    if ( id != stat->st_ino )
+    {
+        currentHistory = HistoryFile ( currentHistoryFilename.Value() );
+        if ( !currentHistory.init ( errstack ) )
+        {
+            dprintf ( D_ALWAYS, "%s\n", errstack.getFullText() );
+            return;
+        }
+        ASSERT ( currentHistory.getId ( id ) );
+        m_historyFiles.insert ( id );
+    }
+}
diff --git a/src/condor_contrib/aviary/src/HistoryProcessingUtils.h b/src/condor_contrib/aviary/src/HistoryProcessingUtils.h
new file mode 100644
index 0000000..c16531a
--- /dev/null
+++ b/src/condor_contrib/aviary/src/HistoryProcessingUtils.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _HISTORYPROCESSINGUTILS_H
+#define _HISTORYPROCESSINGUTILS_H
+
+#include "Job.h"
+#include "AviaryUtils.h"
+
+namespace aviary {
+namespace history {
+
+void init_history_files();
+void processHistoryDirectory();
+void processOrphanedIndices();
+void processCurrentHistory(bool force_reset = false);
+bool populateMapFromClassAd ( ClassAd& ad, AttributeMapType& _map );
+
+}}
+
+#endif /* _HISTORYPROCESSINGUTILS_H */
diff --git a/src/condor_contrib/aviary/src/Job.cpp b/src/condor_contrib/aviary/src/Job.cpp
new file mode 100644
index 0000000..8465593
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Job.cpp
@@ -0,0 +1,691 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "condor_attributes.h"
+#include "condor_parser.h"
+#include "compat_classad.h"
+#include "proc.h"
+#include "stl_string_utils.h"
+
+// c++ includes
+#include <sstream>
+
+// local includes
+#include "Globals.h"
+#include "AviaryUtils.h"
+
+using namespace std;
+using namespace compat_classad;
+using namespace aviary::query;
+using namespace aviary::util;
+
+// Any key that begins with the '0' char is either the
+// header or a cluster, i.e. not a job
+#define IS_JOB(key) ((key) && '0' != (key)[0])
+
+// summary attributes
+ const char *ATTRS[] = {ATTR_CLUSTER_ID,
+                           ATTR_PROC_ID,
+                           ATTR_GLOBAL_JOB_ID,
+                           ATTR_Q_DATE,
+                           ATTR_ENTERED_CURRENT_STATUS,
+                           ATTR_JOB_STATUS,
+                           ATTR_JOB_CMD,
+                           ATTR_JOB_ARGUMENTS1,
+                           ATTR_JOB_ARGUMENTS2,
+                           ATTR_RELEASE_REASON,
+                           ATTR_HOLD_REASON,
+                           ATTR_JOB_SUBMISSION,
+                           ATTR_OWNER,
+                           NULL
+                          };
+
+// TODO: C++ utils which may very well exist elsewhere :-)
+template <class T>
+bool from_string ( T& t,
+                   const string& s,
+                   ios_base& ( *f ) ( ios_base& ) )
+{
+    istringstream iss ( s );
+    return ! ( iss >> f >> t ).fail();
+}
+
+template <class T>
+string to_string ( T t, ios_base & ( *f ) ( ios_base& ) )
+{
+    ostringstream oss;
+    oss << f << t;
+    return oss.str();
+}
+
+//////////////
+// LiveJobImpl
+//////////////
+LiveJobImpl::LiveJobImpl (const char* cluster_proc, ClusterJobImpl* parent)
+{
+    m_job = NULL;
+    m_parent = NULL;
+    m_summary_ad = NULL;
+    m_full_ad = new ClassAd();
+    if ( parent)
+    {
+        m_parent = parent;
+        m_parent->incrementRef();
+        m_full_ad->ChainToAd ( parent->m_full_ad );
+    }
+
+    dprintf ( D_FULLDEBUG, "LiveJobImpl created for '%s'\n", cluster_proc);
+}
+
+LiveJobImpl::~LiveJobImpl()
+{
+    // unchain our parent first
+    if (m_full_ad) {
+        m_full_ad->Unchain();
+        delete m_full_ad;
+        m_full_ad = NULL;
+    }
+
+    if (m_summary_ad) {
+        delete m_summary_ad;
+        m_summary_ad = NULL;
+    }
+
+    if (m_parent) {
+        m_parent->decrementRef();
+    }
+
+    dprintf ( D_FULLDEBUG, "LiveJobImpl destroyed: key '%s'\n", m_job->getKey());
+}
+
+bool
+LiveJobImpl::get ( const char *_name, const AviaryAttribute *&_attribute ) const
+{
+    // our job ad is chained so lookups will
+    // encompass our parent ad as well as the child
+
+    // parse the type
+    ExprTree *expr = NULL;
+    if ( ! ( expr = m_full_ad->Lookup ( _name ) ) )
+    {
+	    dprintf ( D_FULLDEBUG,
+                  "warning: failed to lookup attribute %s in job '%s'\n", _name, m_job->getKey() );
+        return false;
+    }
+    // decode the type
+    classad::Value value;
+    m_full_ad->EvaluateExpr(expr,value);
+    switch ( value.GetType() )
+    {
+        case classad::Value::INTEGER_VALUE:
+        {
+            int i;
+            if ( !m_full_ad->LookupInteger ( _name, i ) )
+            {
+                return false;
+            }
+            _attribute = new AviaryAttribute ( AviaryAttribute::INTEGER_TYPE, to_string<int> ( i,dec ).c_str() );
+            return true;
+        }
+        case classad::Value::REAL_VALUE:
+        {
+            float f;
+            if ( !m_full_ad->LookupFloat ( _name, f ) )
+            {
+                return false;
+            }
+            _attribute = new AviaryAttribute ( AviaryAttribute::FLOAT_TYPE, to_string<float> ( f,dec ).c_str() );
+            return true;
+        }
+        case classad::Value::STRING_VALUE:
+        {
+            MyString str;
+            if ( !m_full_ad->LookupString ( _name, str ) )
+            {
+                return false;
+            }
+            _attribute = new AviaryAttribute ( AviaryAttribute::STRING_TYPE, str.StrDup() );
+            return true;
+        }
+        default:
+        {
+            ExprTree* tree = NULL;
+            if ( ! ( tree = m_full_ad->Lookup ( _name ) ) )
+            {
+                return false;
+            }
+            const char* rhs;
+            rhs = ExprTreeToString( expr );
+            _attribute = new AviaryAttribute ( AviaryAttribute::EXPR_TYPE, rhs );
+            return true;
+        }
+    }
+
+    return false;
+}
+
+int LiveJobImpl::getStatus() const
+{
+    const AviaryAttribute* attr;
+
+    if ( !this->get ( ATTR_JOB_STATUS, attr ) )
+    {
+	// assume we might get cluster jobs here also
+	return JOB_STATUS_MIN;
+    }
+
+    return strtol ( attr->getValue(), ( char ** ) NULL, 10 );
+}
+
+void
+LiveJobImpl::set ( const char *_name, const char *_value )
+{
+
+    if ( strcasecmp ( _name, ATTR_JOB_SUBMISSION ) == 0 )
+    {
+        string val = trimQuotes( _value );
+        // grab the cluster from our key
+        PROC_ID id = getProcByString(m_job->getKey());
+	if (m_job) {
+		m_job->setSubmission ( val.c_str(), id.cluster );
+	}
+    }
+
+    // our status is changing...decrement for old one
+    if ( strcasecmp ( _name, ATTR_JOB_STATUS ) == 0 )
+    {
+	if ( m_job )
+        {
+	    m_job->setStatus(this->getStatus());
+            m_job->decrementSubmission ();
+        }
+    }
+
+    if ( strcasecmp ( _name, ATTR_OWNER ) == 0 )
+    {
+	// need to leave an owner for this job
+	// to be picked up soon
+	// if we are in here, we don't have m_submission
+	PROC_ID id = getProcByString(m_job->getKey());
+	string val = trimQuotes( _value );
+	g_ownerless_clusters[id.cluster] = val;
+	m_job->updateSubmission(id.cluster,val.c_str());
+    }
+
+    // parse the type
+    ExprTree *expr;
+    if ( ParseClassAdRvalExpr ( _value, expr ) )
+    {
+        dprintf ( D_ALWAYS,
+                  "error: parsing %s[%s] = %s, skipping\n",
+                  m_job->getKey(), _name, _value );
+        return;
+    }
+    // add this value to the classad
+    classad::Value value;
+    expr->Evaluate(value);
+    switch ( value.GetType() )
+    {
+        case classad::Value::INTEGER_VALUE:
+            int i;
+            from_string<int> ( i, string ( _value ), dec );
+            m_full_ad->Assign ( _name, i );
+            break;
+        case classad::Value::REAL_VALUE:
+            float f;
+            from_string<float> ( f, string ( _value ), dec );
+            m_full_ad->Assign ( _name, f );
+            break;
+        case classad::Value::STRING_VALUE:
+            m_full_ad->Assign ( _name, _value );
+            break;
+        default:
+            m_full_ad->AssignExpr ( _name, _value );
+            break;
+    }
+    delete expr; expr = NULL;
+
+    // our status has changed...increment for new one
+    if ( strcasecmp ( _name, ATTR_JOB_STATUS ) == 0 )
+    {
+        if ( m_job )
+        {
+	    m_job->setStatus(this->getStatus());
+            m_job->incrementSubmission ();
+        }
+    }
+}
+
+void
+LiveJobImpl::remove ( const char *_name )
+{
+	// seems we implode if we don't unchain first
+	classad::ClassAd* cp = m_full_ad->GetChainedParentAd();
+	m_full_ad->Delete ( _name );
+	m_full_ad->ChainToAd(cp);
+}
+
+const ClassAd* LiveJobImpl::getSummary () const
+{
+	ClassAd* _summary_ad = NULL;
+	if (!m_summary_ad) {
+		_summary_ad = new ClassAd();
+		_summary_ad->ResetExpr();
+		int i = 0;
+		while (NULL != ATTRS[i]) {
+			const AviaryAttribute* attr = NULL;
+			if (this->get(ATTRS[i],attr)) {
+				switch (attr->getType()) {
+					case AviaryAttribute::FLOAT_TYPE:
+						_summary_ad->Assign(ATTRS[i], atof(attr->getValue()));
+						break;
+					case AviaryAttribute::INTEGER_TYPE:
+						_summary_ad->Assign(ATTRS[i], atol(attr->getValue()));
+						break;
+					case AviaryAttribute::EXPR_TYPE:
+					case AviaryAttribute::STRING_TYPE:
+					default:
+						_summary_ad->Assign(ATTRS[i], strdup(attr->getValue()));
+				}
+			}
+		i++;
+		}
+	} else {
+		_summary_ad = m_summary_ad;
+	}
+
+	return _summary_ad;
+}
+
+const ClassAd* LiveJobImpl::getFullAd () const
+{
+    return m_full_ad;
+}
+
+/////////////////
+// ClusterJobImpl
+/////////////////
+ClusterJobImpl::ClusterJobImpl(const char* key): LiveJobImpl(key, NULL)
+{
+        m_ref_count = 0;
+}
+
+ClusterJobImpl::~ClusterJobImpl()
+{
+        dprintf ( D_FULLDEBUG, "ClusterJobImpl destroyed: key '%s'\n", m_job->getKey());
+}
+
+void
+ClusterJobImpl::incrementRef()
+{
+        m_ref_count++;
+}
+
+void
+ClusterJobImpl::decrementRef()
+{
+        --m_ref_count;
+}
+
+/////////////////
+// HistoryJobImpl
+/////////////////
+HistoryJobImpl::HistoryJobImpl ( const HistoryEntry& _he):
+	m_he(_he)
+{
+    m_job = NULL;
+    g_ownerless_clusters[_he.cluster] = _he.owner;
+    dprintf ( D_FULLDEBUG, "HistoryJobImpl created for '%d.%d'\n", _he.cluster, _he.proc );
+}
+
+HistoryJobImpl::~HistoryJobImpl ()
+{
+	dprintf ( D_FULLDEBUG, "HistoryJobImpl destroyed: key '%s'\n", m_job->getKey());
+}
+
+int HistoryJobImpl::getStatus() const
+{
+    return m_he.status;
+}
+
+int HistoryJobImpl::getCluster() const
+{
+	return m_he.cluster;
+}
+
+const char* HistoryJobImpl::getSubmissionId() const
+{
+	return m_he.submission.c_str();
+}
+
+void HistoryJobImpl::getSummary ( ClassAd& _ad ) const
+{
+	_ad.ResetExpr();
+	// use HistoryEntry data only
+	_ad.Assign(ATTR_GLOBAL_JOB_ID,m_he.id.c_str());
+	_ad.Assign(ATTR_CLUSTER_ID,m_he.cluster);
+	_ad.Assign(ATTR_PROC_ID,m_he.proc);
+	_ad.Assign(ATTR_Q_DATE,m_he.q_date);
+	_ad.Assign(ATTR_JOB_STATUS,m_he.status);
+	_ad.Assign(ATTR_ENTERED_CURRENT_STATUS,m_he.entered_status);
+	_ad.Assign(ATTR_JOB_SUBMISSION,m_he.submission.c_str());
+	_ad.Assign(ATTR_OWNER,m_he.owner.c_str());
+	_ad.Assign(ATTR_JOB_CMD,m_he.cmd.c_str());
+
+	// beyond here these may be empty so don't
+	// automatically add to summary
+	if (!m_he.args1.empty()) {
+		_ad.Assign(ATTR_JOB_ARGUMENTS1,m_he.args1.c_str());
+	}
+	if (!m_he.args2.empty()) {
+		_ad.Assign(ATTR_JOB_ARGUMENTS2,m_he.args2.c_str());
+	}
+	if (!m_he.release_reason.empty()) {
+		_ad.Assign(ATTR_RELEASE_REASON,m_he.release_reason.c_str());
+	}
+	if (!m_he.hold_reason.empty()) {
+		_ad.Assign(ATTR_HOLD_REASON,m_he.hold_reason.c_str());
+	}
+
+}
+
+// specialization: this GetFullAd has to retrieve its classad attributes
+// from the history file based on index pointers
+void
+ HistoryJobImpl::getFullAd ( ClassAd& _ad) const
+{
+    // fseek to he.start
+    // ClassAd method to deserialize from a file with "***"
+
+    FILE * hFile;
+    int end = 0;
+    int error = 0;
+    int empty = 0;
+	string _text;
+
+    // TODO: move the ClassAd/file deserialize back to HistoryFile???
+    const char* fName = m_he.file.c_str();
+    if ( ! ( hFile = safe_fopen_wrapper ( fName, "r" ) ) )
+    {
+		sprintf(_text,"unable to open history file '%s'", m_he.file.c_str());
+        dprintf ( D_ALWAYS, "%s\n",_text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+		return;
+    }
+    if ( fseek ( hFile , m_he.start , SEEK_SET ) )
+    {
+		sprintf(_text,"bad seek in '%s' at index %d", m_he.file.c_str(),m_he.start);
+        dprintf ( D_ALWAYS, "%s\n",_text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+        return;
+    }
+
+    ClassAd myJobAd ( hFile, "***", end, error, empty );
+    fclose ( hFile );
+
+	// debug logging and error to i/f for now
+	// we might not have our original history file anymore
+    if ( error )
+    {
+		sprintf(_text,"malformed ad for job '%s' in file '%s'",m_job->getKey(), m_he.file.c_str());
+        dprintf ( D_FULLDEBUG, "%s\n", _text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+		return;
+    }
+    if ( empty )
+    {
+		sprintf(_text,"empty ad for job '%s' in '%s'", m_job->getKey(),m_he.file.c_str());
+        dprintf ( D_FULLDEBUG,"%s\n", _text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+		return;
+    }
+
+	if (!_ad.CopyFrom(myJobAd)) {
+		sprintf(_text,"problem copying contents of history ClassAd for '%s'",m_job->getKey());
+		dprintf ( D_ALWAYS, "%s\n",_text.c_str());
+		_ad.Assign("JOB_AD_ERROR",_text.c_str());
+	}
+
+}
+
+//////
+// Job
+//////
+Job::Job(const char* _key):  m_submission(NULL), m_live_job(NULL), m_history_job(NULL), m_key(_key) 
+{
+        dprintf (D_FULLDEBUG,"Job::Job of '%s'\n", m_key);
+}
+
+Job::~Job() {
+	// Destroy will be safe way to
+	// cleanup
+
+	dprintf (D_FULLDEBUG,"Job::~Job of '%s'\n", m_key);
+
+    this->decrementSubmission();
+
+	delete m_live_job;
+	delete m_history_job;
+
+	delete m_key;
+	// submissions are shared and can't be deleted here
+}
+
+void Job::setImpl (LiveJobImpl* lji)
+{
+	lji->setJob(this);
+	// probably shouldn't happen
+	if (m_live_job) {
+		delete m_live_job;
+	}
+	m_live_job = lji;
+
+	// status of a live job always has precedence
+	// so decrement if the history job got in ahead of it
+	if (m_history_job) {
+		m_status = m_history_job->getStatus();
+		m_submission->decrement(this);
+	}
+	m_status = m_live_job->getStatus();
+}
+
+void Job::setImpl (HistoryJobImpl* hji)
+{
+	hji->setJob(this);
+	// probably shouldn't happen
+	if (m_history_job) {
+		delete m_history_job;
+	}
+	m_history_job = hji;
+
+	// stay away from extra inc/decs if the live job is still doing its thing
+	if (!m_submission) {
+		m_status = m_history_job->getStatus();
+		setSubmission(m_history_job->getSubmissionId(),m_history_job->getCluster());
+	}
+
+	// call Destroy to see if we can clean up the live job
+	this->destroy();
+}
+
+void Job::setStatus(int status)
+{
+	m_status = status;
+}
+
+const char* Job::getKey() const
+{
+	return m_key;
+}
+
+void Job::set ( const char *_name, const char *_value ) {
+	if (m_live_job) {
+		m_live_job->set(_name,_value);
+	}
+	// ignore for history jobs
+}
+
+void Job::remove ( const char *_name ) {
+	if (m_live_job) {
+		m_live_job->remove(_name);
+	}
+	// ignore for history jobs
+}
+
+void Job::incrementSubmission() {
+	if (m_submission) {
+		m_submission->increment(this);
+	}
+}
+
+void Job::decrementSubmission() {
+	if (m_submission) {
+		m_submission->decrement(this);
+	}
+}
+
+void
+Job::updateSubmission ( int cluster, const char* owner )
+{
+	OwnerlessSubmissionType::const_iterator it = g_ownerless_submissions.find ( cluster );
+	if ( g_ownerless_submissions.end() != it ) {
+		SubmissionObject* submission = (*it).second;
+		submission->setOwner(owner);
+		g_ownerless_submissions.erase(cluster);
+	}
+}
+
+void
+Job::setSubmission ( const char* _subName, int cluster )
+{
+	const char* owner = NULL;
+
+	// need to see if someone has left us an owner
+	OwnerlessClusterType::const_iterator it = g_ownerless_clusters.find ( cluster );
+	if ( g_ownerless_clusters.end() != it )
+	{
+		owner = ( *it ).second.c_str() ;
+	}
+
+	SubmissionCollectionType::const_iterator element = g_submissions.find ( _subName );
+	SubmissionObject *submission;
+	if ( g_submissions.end() == element )
+	{
+		submission = new SubmissionObject ( _subName, owner );
+		g_submissions[strdup ( _subName ) ] = submission;
+	}
+	else
+	{
+		submission = ( *element ).second;
+	}
+	m_submission = submission;
+
+	m_submission->increment(this);
+
+	if (owner) {
+		// ensure that the submission has an owner
+		m_submission->setOwner ( owner );
+		g_ownerless_clusters.erase ( cluster );
+	}
+	else {
+		// add it to our list to be updated for owner
+		g_ownerless_submissions[cluster] = m_submission;
+	}
+
+}
+
+bool ClusterJobImpl::destroy()
+{
+        return m_ref_count == 0;
+}
+
+bool
+LiveJobImpl::destroy()
+{
+        return ((this->getStatus() == COMPLETED) || (this->getStatus() == REMOVED));
+}
+
+bool
+Job::destroy()
+{
+
+        bool live_destroy = (m_live_job && m_live_job->destroy());
+
+        if (m_history_job && live_destroy) {
+                // must be a proc
+                delete m_live_job;
+                m_live_job = NULL;
+                return false;
+        }
+
+        // hint to caller
+        return live_destroy;
+}
+
+// space v. speed tradeoff here - we want to keep the size of the job server down
+// since we may have to support millions of jobs in memory
+void Job::getFullAd ( ClassAd& _ad) const
+{
+	// history ads are always reconstructed
+	// so we deep copy the live job ad to be consistent
+	// on the interface
+
+	if (m_live_job) {
+		_ad = *(m_live_job->getFullAd());
+	}
+	else {
+		m_history_job->getFullAd(_ad);
+	}
+
+}
+
+// poke a hole for live job ad chaining
+const ClassAd* Job::getClassAd() const
+{
+	const ClassAd* ad_ptr = NULL;
+	if (m_live_job) {
+		ad_ptr = m_live_job->getFullAd();
+	}
+	return ad_ptr;
+
+}
+
+void Job::getSummary ( ClassAd& _ad) const
+{
+	//same thing as full ad
+	if (m_live_job) {
+		_ad = *(m_live_job->getSummary());
+	}
+	else {
+		m_history_job->getSummary(_ad);
+	}
+}
+
+int Job::getStatus() const
+{
+	return m_status;
+}
+
+JobImpl* Job::getImpl() {
+        // only will provide live job impl
+        // if it's NULL the caller needs to deal
+        return m_live_job;
+}
diff --git a/src/condor_contrib/aviary/src/Job.h b/src/condor_contrib/aviary/src/Job.h
new file mode 100644
index 0000000..77e2af6
--- /dev/null
+++ b/src/condor_contrib/aviary/src/Job.h
@@ -0,0 +1,160 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _JOB_H
+#define _JOB_H
+
+// c++ includes
+#include <string>
+#include <map>
+#include <set>
+#include <vector>
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "condor_classad.h"
+
+// local includes
+#include "Codec.h"
+#include "HistoryFile.h"
+#include "cmpstr.h"
+
+using std::string;
+using std::map;
+using std::set;
+using std::vector;
+
+using namespace aviary::codec;
+using namespace aviary::history;
+
+namespace aviary {
+namespace query {
+
+class SubmissionObject;
+class Job;
+
+// interface class for job impls
+class JobImpl
+{
+public:
+        Job* getJob() { return m_job; }
+        void setJob(Job* _job) { m_job = _job; }
+
+protected:
+        Job* m_job;
+        JobImpl() {};
+};
+
+class ClusterJobImpl;
+
+// Job delegate that encapsulates the job active in the queue
+class LiveJobImpl: public JobImpl
+{
+    public:
+        LiveJobImpl ( const char*, ClusterJobImpl* );
+        virtual ~LiveJobImpl();
+        int getStatus () const;
+        const ClassAd* getSummary () const;
+        const ClassAd* getFullAd () const;
+        void set ( const char* , const char* );
+        bool get ( const char * , const AviaryAttribute *& ) const;
+        void remove ( const char* );
+
+        virtual bool destroy();
+
+    private:
+        ClusterJobImpl* m_parent;
+        ClassAd* m_full_ad;
+        ClassAd* m_summary_ad;
+};
+
+class ClusterJobImpl: public LiveJobImpl
+{
+public:
+        ClusterJobImpl(const char*);
+        ~ClusterJobImpl();
+        void incrementRef();
+        void decrementRef();
+        bool destroy();
+
+private:
+        int m_ref_count;
+};
+
+// Job delegate that encapsulates the archived job history
+// and can derive the attributes of its associated class ad
+class HistoryJobImpl: public JobImpl
+{
+    public:
+        HistoryJobImpl (const HistoryEntry&);
+        ~HistoryJobImpl();
+        int  getStatus () const;
+        void getSummary ( ClassAd& ) const;
+        void getFullAd ( ClassAd& ) const;
+        int  getCluster() const;
+        const char* getSubmissionId () const;
+
+    private:
+        HistoryEntry m_he;
+};
+
+// the public face of jobs
+// not for subclassing - clients (generally) shouldn't be
+// burdened with the live/history distinction
+class Job
+{
+    public:
+        Job(const char*);
+        ~Job();
+
+        const char * getKey() const;
+
+        int  getStatus () const;
+        void setStatus(int);
+
+        void getSummary (ClassAd&) const;
+        void getFullAd (ClassAd&) const;
+        const ClassAd* getClassAd() const;
+
+        void set ( const char* , const char* );
+        void remove ( const char* );
+
+        void setSubmission ( const char*, int );
+        void updateSubmission ( int, const char* );
+        void incrementSubmission();
+        void decrementSubmission();
+
+        void setImpl(LiveJobImpl*);
+        void setImpl(HistoryJobImpl*);
+        JobImpl* getImpl();
+
+        bool destroy();
+
+    private:
+        SubmissionObject *m_submission;
+        // live job to start, history job when ready
+        LiveJobImpl* m_live_job;
+        HistoryJobImpl* m_history_job;
+        const char* m_key;
+        int m_status;
+};
+
+}}
+
+#endif /* _JOB_H */
diff --git a/src/condor_contrib/aviary/src/JobServerJobLogConsumer.cpp b/src/condor_contrib/aviary/src/JobServerJobLogConsumer.cpp
new file mode 100644
index 0000000..eb8c320
--- /dev/null
+++ b/src/condor_contrib/aviary/src/JobServerJobLogConsumer.cpp
@@ -0,0 +1,226 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "condor_exprtype.h"
+#include "condor_attributes.h"
+#include "condor_astbase.h"
+#include "condor_parser.h"
+#include "condor_qmgr.h"
+#include "ClassAdLogReader.h"
+
+// local includes
+#include "JobServerJobLogConsumer.h"
+#include "Globals.h"
+#include "HistoryProcessingUtils.h"
+
+using namespace aviary::query;
+using namespace aviary::history;
+
+#define IS_JOB(key) ((key) && '0' != (key)[0])
+
+JobServerJobLogConsumer::JobServerJobLogConsumer(): m_reader(NULL)
+{ }
+
+JobServerJobLogConsumer::~JobServerJobLogConsumer()
+{ }
+
+void
+JobServerJobLogConsumer::Reset()
+{
+	// When deleting jobs, to avoid problems with jobs referencing
+	// deleted clusters, we must be sure to delete the clusters
+	// last
+
+	dprintf(D_FULLDEBUG, "JobServerJobLogConsumer::Reset() - deleting jobs and submissions\n");
+
+	for (JobCollectionType::iterator i = g_jobs.begin();
+	     g_jobs.end() != i; i++) {
+		// Skip clusters for now
+		if ('0' != (*i).second->getKey()[0]) {
+			delete (*i).second;
+			g_jobs.erase(i);
+		}
+	}
+
+	for (JobCollectionType::iterator i = g_jobs.begin();
+		  g_jobs.end() != i; i++) {
+		     delete (*i).second;
+		     g_jobs.erase(i);
+	}
+
+	for (SubmissionCollectionType::iterator i = g_submissions.begin();
+		       g_submissions.end() != i; i++) {
+			  delete (*i).second;
+			  g_submissions.erase(i);
+	}
+
+	// due to the shared use of g_jobs
+	// a JobLogReader->Reset() might cause
+	// us to reload our history
+	init_history_files();
+
+}
+
+bool
+JobServerJobLogConsumer::NewClassAd(const char *_key,
+									const char */*type*/,
+									const char */*target*/)
+{
+
+	const char* key_dup = strdup(_key);
+
+	dprintf(D_FULLDEBUG, "JobServerJobLogConsumer::NewClassAd processing _key='%s'\n", _key);
+
+	// ignore the marker
+	if (strcmp(_key,"0.0") == 0) {
+	  return true;
+	}
+
+	if ('0' == _key[0]) {
+		// Cluster ad
+		if (g_jobs.end() == g_jobs.find(_key)) {
+			Job* new_cluster_job = new Job(key_dup);
+			new_cluster_job->setImpl(new ClusterJobImpl(key_dup));
+			g_jobs[key_dup] = new_cluster_job;
+		}
+	} else {
+		// Proc ad
+
+		// first see if some other proc job is here
+		// ie history
+		if (g_jobs.end() != g_jobs.find(_key)) {
+			return true;
+		}
+
+		PROC_ID proc = getProcByString(_key);
+		MyString cluster_key;
+
+		cluster_key.sprintf("0%d.-1", proc.cluster);
+
+		const char *cluster_dup = cluster_key.StrDup();
+		JobCollectionType::const_iterator element = g_jobs.find(cluster_dup);
+        ClusterJobImpl* cluster_impl = NULL;
+
+		if (g_jobs.end() == element) {
+			// didn't find an existing cluster job so create a new one
+			Job* new_cluster_job = new Job(cluster_dup);
+            cluster_impl = new ClusterJobImpl(cluster_dup);
+            new_cluster_job->setImpl(cluster_impl);
+            g_jobs[cluster_dup] = new_cluster_job;
+		} else {
+			// found an existing cluster job - we'll assume it is the cluster parent
+			cluster_impl = static_cast<ClusterJobImpl*>((*element).second->getImpl());
+		}
+
+        Job* new_proc_job = new Job(key_dup);
+        new_proc_job->setImpl(new LiveJobImpl(key_dup, cluster_impl));
+        g_jobs[key_dup] = new_proc_job;
+
+	}
+
+	return true;
+}
+
+bool
+JobServerJobLogConsumer::DestroyClassAd(const char *_key)
+{
+
+	// ignore the marker
+	if (strcmp(_key,"0.0") == 0) {
+	  return true;
+	}
+
+   dprintf ( D_FULLDEBUG, "JobServerJobLogConsumer::DestroyClassAd - key '%s'\n", _key);
+    JobCollectionType::iterator g_element = g_jobs.find(_key);
+
+    if (g_jobs.end() == g_element) {
+        dprintf(D_ALWAYS,
+                "error reading %s: no such job found for key '%s'\n",
+                m_reader->GetClassAdLogFileName(), _key);
+        return false;
+    }
+
+    Job* job = (*g_element).second;
+    // Destroy will figure out the submission decrement
+    if (job->destroy()) {
+            delete job;
+            job = NULL;
+            g_jobs.erase(g_element);
+    }
+
+    return true;
+}
+
+bool
+JobServerJobLogConsumer::SetAttribute(const char *_key,
+									  const char *_name,
+									  const char *_value)
+{
+
+	// ignore the marker
+	if (strcmp(_key,"0.0") == 0) {
+	  return true;
+	}
+
+	if (0 == strcmp(_name,"NextClusterNum") ) {
+		// skip over these
+		//dprintf(D_FULLDEBUG, "%s: skipping job entry '%s' for '%s = %s'\n",
+		//	m_reader->GetJobLogFileName(), _key, _name, _value);
+		return true;
+	}
+
+    JobCollectionType::const_iterator g_element = g_jobs.find(_key);
+
+	if (g_jobs.end() == g_element) {
+		dprintf(D_ALWAYS,
+				"error reading %s : no such job '%s' for '%s = %s'\n",
+				m_reader->GetClassAdLogFileName(),
+				_key, _name, _value);
+		return false;
+	}
+
+	(*g_element).second->set(_name, _value);
+
+	return true;
+}
+
+bool
+JobServerJobLogConsumer::DeleteAttribute(const char *_key,
+										 const char *_name)
+{
+	// ignore the marker
+	if (strcmp(_key,"0.0") == 0) {
+	  return true;
+	}
+
+	JobCollectionType::const_iterator g_element = g_jobs.find(_key);
+
+	if (g_jobs.end() == g_element) {
+		dprintf(D_ALWAYS,
+				"error reading %s: no such job '%s' for 'delete %s'\n",
+                m_reader->GetClassAdLogFileName(), _key, _name);
+		return false;
+	}
+
+	(*g_element).second->remove(_name);
+
+	return true;
+}
diff --git a/src/condor_contrib/aviary/src/JobServerJobLogConsumer.h b/src/condor_contrib/aviary/src/JobServerJobLogConsumer.h
new file mode 100644
index 0000000..22703ed
--- /dev/null
+++ b/src/condor_contrib/aviary/src/JobServerJobLogConsumer.h
@@ -0,0 +1,62 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _JOBSERVERJOBLOGCONSUMER_H
+#define _JOBSERVERJOBLOGCONSUMER_H
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "ClassAdLogReader.h"
+
+// local includes
+#include "Job.h"
+#include "SubmissionObject.h"
+
+// c++ includes
+#include <string>
+#include <map>
+#include <set>
+
+using namespace std;
+
+class JobServerJobLogConsumer: public ClassAdLogConsumer
+{
+public:
+	JobServerJobLogConsumer();
+	~JobServerJobLogConsumer();
+
+	void Reset();
+	bool NewClassAd(const char *key,
+					const char *type,
+					const char *target);
+	bool DestroyClassAd(const char *key);
+	bool SetAttribute(const char *key,
+					  const char *name,
+					  const char *value);
+	bool DeleteAttribute(const char *key,
+						 const char *name);
+    void SetJobLogReader(ClassAdLogReader *_reader) { m_reader = _reader; }
+
+
+private:
+
+    ClassAdLogReader *m_reader;
+};
+
+#endif /* _JOBSERVERJOBLOGCONSUMER_H */
diff --git a/src/condor_contrib/aviary/src/JobServerObject.cpp b/src/condor_contrib/aviary/src/JobServerObject.cpp
new file mode 100644
index 0000000..ee76024
--- /dev/null
+++ b/src/condor_contrib/aviary/src/JobServerObject.cpp
@@ -0,0 +1,374 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_attributes.h"
+#include "condor_debug.h"
+#include "condor_qmgr.h"
+#include "set_user_priv_from_ad.h"
+#include "stat_info.h"
+#include "stl_string_utils.h"
+
+// C++ includes
+// enable for debugging classad to ostream
+// watch out for unistd clash
+//#include <sstream>
+
+//local includes
+#include "JobServerObject.h"
+#include "AviaryConversionMacros.h"
+#include "AviaryUtils.h"
+#include "Codec.h"
+#include "JobServerJobLogConsumer.h"
+#include "Globals.h"
+
+using namespace std;
+using namespace aviary::query;
+using namespace aviary::util;
+using namespace aviary::codec;
+
+JobServerObject* JobServerObject::m_instance = NULL;
+
+JobServerObject::JobServerObject ()
+{
+	m_name = getScheddName();
+	m_pool = getPoolName();
+	m_codec = new BaseCodec;
+}
+
+JobServerObject::~JobServerObject()
+{
+	delete m_codec;
+}
+
+JobServerObject* JobServerObject::getInstance()
+{
+    if (!m_instance) {
+        m_instance = new JobServerObject();
+    }
+    return m_instance;
+}
+
+void
+JobServerObject::update ( const ClassAd &ad )
+{
+    MGMT_DECLARATIONS;
+
+    m_stats.Pool = getPoolName();
+    STRING ( CondorPlatform );
+    STRING ( CondorVersion );
+    TIME_INTEGER ( DaemonStartTime );
+//  TIME_INTEGER(JobQueueBirthdate);
+    STRING ( Machine );
+//  INTEGER(MaxJobsRunning);
+    INTEGER ( MonitorSelfAge );
+    DOUBLE ( MonitorSelfCPUUsage );
+    DOUBLE ( MonitorSelfImageSize );
+    INTEGER ( MonitorSelfRegisteredSocketCount );
+    INTEGER ( MonitorSelfResidentSetSize );
+    TIME_INTEGER ( MonitorSelfTime );
+    STRING ( MyAddress );
+    //TIME_INTEGER(MyCurrentTime);
+    STRING ( Name );
+//  INTEGER(NumUsers);
+    STRING ( PublicNetworkIpAddr );
+//  INTEGER(TotalHeldJobs);
+//  INTEGER(TotalIdleJobs);
+//  INTEGER(TotalJobAds);
+//  INTEGER(TotalRemovedJobs);
+//  INTEGER(TotalRunningJobs);
+
+    m_stats.System = m_stats.Machine;
+}
+
+Job*
+getValidKnownJob(const char* key, AviaryStatus &_status) {
+
+	// #1: is it even a proper "cluster.proc"?
+	PROC_ID id = getProcByString(key);
+	if (id.cluster < 0 || id.proc < 0) {
+		sprintf (_status.text, "Invalid job id '%s'",key);
+		dprintf(D_FULLDEBUG, "%s\n", _status.text.c_str());
+		_status.type = AviaryStatus::FAIL;
+		return NULL;
+	}
+
+	// #2 is it anywhere in our job map?
+    JobCollectionType::const_iterator element = g_jobs.find(key);
+    if ( g_jobs.end() == element ) {
+		sprintf (_status.text, "Unknown local job id '%s'",key);
+		dprintf(D_FULLDEBUG, "%s\n", _status.text.c_str());
+		_status.type = AviaryStatus::NO_MATCH;
+		return NULL;
+    }
+
+	return (*element).second;
+}
+
+bool JobServerObject::getStatus(const char* key, int& job_status, AviaryStatus &_status) {
+	Job* job = NULL;
+	if (!(job = getValidKnownJob(key,_status))) {
+		return false;
+	}
+
+	job_status = job->getStatus();
+
+	_status.type = AviaryStatus::A_OK;
+	return true;
+}
+
+bool JobServerObject::getSummary(const char* key, JobSummaryFields& _summary, AviaryStatus &_status) {
+	Job* job = NULL;
+	if (!(job = getValidKnownJob(key,_status))) {
+		return false;
+	}
+
+    ClassAd classAd;
+    job->getSummary ( classAd );
+    // little cheat for ad problems with history lookups
+    string str;
+    if ( classAd.LookupString("JOB_AD_ERROR", str) )
+    {
+		sprintf(_status.text,"Error obtaining ClassAd for job '%s'; ",key);
+		_status.text += str;
+		dprintf(D_ALWAYS,"%s\n",_status.text.c_str());
+        return false;
+    }
+
+	// return the limited attributes
+    classAd.LookupString(ATTR_JOB_CMD,_summary.cmd);
+	classAd.LookupString(ATTR_JOB_ARGUMENTS1,_summary.args1);
+	classAd.LookupString(ATTR_JOB_ARGUMENTS2,_summary.args2);
+	classAd.LookupString(ATTR_HOLD_REASON,_summary.hold_reason);
+	classAd.LookupString(ATTR_RELEASE_REASON,_summary.release_reason);
+	classAd.LookupString(ATTR_REMOVE_REASON,_summary.remove_reason);
+	classAd.LookupString(ATTR_JOB_SUBMISSION,_summary.submission_id);
+	classAd.LookupString(ATTR_OWNER,_summary.owner);
+	classAd.LookupInteger(ATTR_Q_DATE,_summary.queued);
+	classAd.LookupInteger(ATTR_ENTERED_CURRENT_STATUS,_summary.last_update);
+	_summary.status = job->getStatus();
+
+	_status.type = AviaryStatus::A_OK;
+    return true;
+}
+
+bool
+JobServerObject::getJobAd ( const char* key, AttributeMapType& _map, AviaryStatus &_status)
+{
+	Job* job = NULL;
+	if (!(job = getValidKnownJob(key,_status))) {
+		return false;
+	}
+    // call Job::getFullAd and use utils to populate the map
+    ClassAd classAd;
+    job->getFullAd ( classAd );
+    // little cheat for ad problems with history lookups
+    string str;
+    if ( classAd.LookupString("JOB_AD_ERROR", str) )
+    {
+		sprintf(_status.text,"Error obtaining ClassAd for job '%s'; ",key);
+		_status.text += str;
+		dprintf(D_ALWAYS,"%s\n",_status.text.c_str());
+    }
+
+    // return all the attributes in the ClassAd
+    if ( !m_codec->classAdToMap ( classAd, _map  ) )
+    {
+		sprintf(_status.text,"Error mapping info for job '%s'; ",key);
+		dprintf(D_ALWAYS,"%s\n",_status.text.c_str());
+        return false;
+    }
+
+    // debug
+//    if (DebugFlags & D_FULLDEBUG) {
+//        classAd.dPrint(D_FULLDEBUG|D_NOHEADER);
+//        std::ostringstream oss;
+//        oss << _map;
+//        dprintf(D_FULLDEBUG|D_NOHEADER, oss.str().c_str());
+//    }
+
+	_status.type = AviaryStatus::A_OK;
+    return true;
+}
+
+bool
+JobServerObject::fetchJobData(const char* key,
+					   const UserFileType ftype,
+					   std::string& fname,
+					   int max_bytes,
+					   bool from_end,
+					   int& fsize,
+					   std::string &data,
+					   AviaryStatus &_status)
+{
+	int32_t start;
+	int32_t end;
+	priv_state prev_priv_state;
+	int fd = -1;
+	int count;
+	int length;
+	int whence;
+	char *buffer;
+	bool fetched;
+	Job* job = NULL;
+
+	if (!(job =getValidKnownJob(key,_status))) {
+		return false;
+	}
+
+
+	ClassAd ad;
+	string str;
+	job->getFullAd ( ad );
+	if ( ad.LookupString("JOB_AD_ERROR", str)  ) {
+		sprintf(_status.text,"Error checking ClassAd for user priv on job '%s'; ",key);
+		_status.text += str;
+		dprintf(D_ALWAYS,"%s\n",_status.text.c_str());
+		return false;
+	}
+	
+	// find out what the actual file is from classad lookup
+	switch (ftype) {
+		case ERR:
+			if ( !ad.LookupString(ATTR_JOB_ERROR, fname)  ) {
+				sprintf (_status.text,  "No error file for job '%s'",key);
+				dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+				return false;
+			}
+			break;
+		case LOG:
+			if ( !ad.LookupString(ATTR_ULOG_FILE, fname)  ) {
+				sprintf (_status.text,  "No log file for job '%s'",key);
+				dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+				return false;
+			}
+			break;
+		case OUT:
+			if ( !ad.LookupString(ATTR_JOB_OUTPUT, fname)  ) {
+				sprintf (_status.text,  "No output file for job '%s'",key);
+				dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+				return false;
+			}
+			break;
+		default:
+			// ruh-roh...asking for a file type we don't know about
+			sprintf (_status.text,  "Unknown file type for job '%s'",key);
+			dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+			return false;
+	}
+	
+	StatInfo the_file(fname.c_str());
+	if (the_file.Error()) {
+		sprintf (_status.text, "Error opening requested file '%s', error %d",fname.c_str(),the_file.Errno());
+		dprintf(D_ALWAYS,"%s\n", _status.text.c_str());
+		return false;
+	}
+
+	fsize = the_file.GetFileSize();
+
+	// we calculate these based on file size
+	if (from_end) {
+		end = fsize;
+		start = end - max_bytes;
+	}
+	else {
+		start = 0;
+		end = max_bytes;
+	}
+
+	// start >= 0, end >= 0 :: lseek(start, SEEK_SET), read(end - start)
+	//  end < start :: error, attempt to read backwards
+	// start >= 0, end < 0 :: error, don't know length
+	// start < 0, end > 0 :: attempt to read off end of file, end = 0
+	// start < 0, end <= 0 :: lseek(start, SEEK_END), read(abs(start - end))
+	//  end < start :: error, attempt to read backwards
+
+	// TODO: redundant checks given above
+	if ((start >= 0 && end >= 0 && end < start) ||
+		(start >= 0 && end < 0) ||
+		(start < 0 && end <= 0 && end < start)) {
+		_status.text = "Invalid start and end values";
+		return false;
+	}
+
+	// Instead of reading off the end of the file, read to the
+	// end of it
+	if (start < 0 && end > 0) {
+		end = 0;
+	}
+
+	if (start >= 0) {
+		whence = SEEK_SET;
+		length = end - start;
+	} else {
+		whence = SEEK_END;
+		length = abs(start - end);
+	}
+
+	// TODO: Sanity check that length isn't too big?
+	buffer = new char[length + 1];
+
+	prev_priv_state = set_user_priv_from_ad(ad);
+
+	if (-1 != (fd = safe_open_wrapper(fname.c_str(),
+									  O_RDONLY | _O_BINARY,
+									  0))) {
+			// If we are seeking from the end of the file, it is
+			// possible that we will try to seek off the front of the
+			// file. To avoid this, we check the file's size and set
+			// the max length that we are able to seek
+		if (SEEK_END == whence) {
+			struct stat buf;
+			if (-1 != fstat(fd, &buf)) {
+				if (buf.st_size < abs(start)) {
+					start = -buf.st_size;
+				}
+			} // if fstat fails, we just continue having made an effort
+		}
+
+		if (-1 != lseek(fd, start, whence)) {				
+			if (-1 == (count = full_read(fd, buffer, length))) {
+				_status.text = "Failed to read from " + fname;
+				fetched = false;
+			} else {
+					// Terminate the string.
+				buffer[count] = '\0';
+
+				data = buffer;
+				fetched = true;
+			}
+
+			close(fd); // assume closed on failure?
+		} else {
+			_status.text = "Failed to seek in " + fname;
+			fetched = false;
+		}
+	} else {
+		_status.text = "Failed to open " + fname;
+		fetched = false;
+	}
+
+	set_priv(prev_priv_state);
+
+	delete [] buffer;
+
+	if (fetched) {
+		_status.type = AviaryStatus::A_OK;
+	}
+	return fetched;
+}
diff --git a/src/condor_contrib/aviary/src/JobServerObject.h b/src/condor_contrib/aviary/src/JobServerObject.h
new file mode 100644
index 0000000..d305270
--- /dev/null
+++ b/src/condor_contrib/aviary/src/JobServerObject.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _JOBSERVEROBJECT_H
+#define _JOBSERVEROBJECT_H
+
+// condor includes
+#include "condor_common.h"
+#include "condor_classad.h"
+
+// local includes
+#include "Codec.h"
+
+struct a;
+struct a;
+struct a;
+struct a;
+using namespace std;
+using namespace compat_classad;
+using namespace aviary::codec;
+
+namespace aviary {
+namespace query {
+
+struct JobServerStats {
+    // Properties
+    string      CondorPlatform;
+    string      CondorVersion;
+    int64_t     DaemonStartTime;
+    string      Pool;
+    string      System;
+    uint32_t    MaxJobsRunning;
+    string      Machine;
+    string      MyAddress;
+    string      Name;
+	string		PublicNetworkIpAddr;
+
+    // Statistics
+    uint32_t    MonitorSelfAge;
+    double      MonitorSelfCPUUsage;
+    double      MonitorSelfImageSize;
+    uint32_t    MonitorSelfRegisteredSocketCount;
+    uint32_t    MonitorSelfResidentSetSize;
+    int64_t     MonitorSelfTime;
+    uint32_t    NumUsers;
+};
+
+enum UserFileType {
+	ERR = 0,
+	LOG = 1,
+	OUT = 2
+};
+
+struct JobSummaryFields {
+	int status;
+	string cmd;
+	string args1;
+	string args2;
+	int queued;
+	int last_update;
+	string hold_reason;
+	string release_reason;
+	string remove_reason;
+	string submission_id;
+	string owner;
+};
+
+typedef pair<const char*,JobSummaryFields*> JobSummaryPair;
+typedef vector<JobSummaryPair> JobSummaryPairCollection;
+
+class JobServerObject
+{
+public:
+
+	void update(const ClassAd &ad);
+
+	bool getStatus(const char* id, int& status, AviaryStatus &_status);
+	bool getSummary(const char* key, JobSummaryFields& _summary, AviaryStatus &_status);
+	bool getJobAd(const char* id, AttributeMapType& _map, AviaryStatus &_status);
+	bool fetchJobData(const char* key,
+					   const UserFileType ftype,
+					   std::string& fname,
+					   int max_bytes,
+					   bool from_end,
+					   int& fsize,
+					   std::string &data,
+			           AviaryStatus &_status);
+
+    ~JobServerObject();
+	static JobServerObject* getInstance();
+
+	const char* getName() { return m_name.c_str(); }
+	const char* getPool() { return m_pool.c_str(); }
+
+private:
+    JobServerObject();
+	JobServerObject(JobServerObject const&);
+	JobServerObject& operator=(JobServerObject const&);
+
+	string m_name;
+	string m_pool;
+	JobServerStats m_stats;
+	Codec* m_codec;
+
+	static JobServerObject* m_instance;
+
+};
+
+}} /* aviary::query */
+
+#endif /* _JOBSERVEROBJECT_H */
diff --git a/src/condor_contrib/aviary/src/PROC_ID_comparator.cpp b/src/condor_contrib/aviary/src/PROC_ID_comparator.cpp
new file mode 100644
index 0000000..6eb94ba
--- /dev/null
+++ b/src/condor_contrib/aviary/src/PROC_ID_comparator.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "proc.h"
+
+// local includes
+#include "PROC_ID_comparator.h"
+
+using namespace aviary::util;
+
+bool
+PROC_ID_comparator::operator()(const std::string &lhs, const std::string &rhs)
+{
+	PROC_ID lhs_id, rhs_id;
+
+		// !!! The EXCEPT macro is "#define EXCEPT \", so we must
+		// !!! enclose it in { }'s else we'll always EXCEPT
+
+	if (!StrToProcId(lhs.c_str(), lhs_id)) { EXCEPT("Invalid LHS PROC_ID %s", lhs.c_str()); }
+	if (!StrToProcId(rhs.c_str(), rhs_id)) { EXCEPT("Invalid RHS PROC_ID %s", rhs.c_str()); }
+
+	return
+		(lhs_id.cluster < rhs_id.cluster) ||
+		((lhs_id.cluster == rhs_id.cluster) && (lhs_id.proc < rhs_id.proc));
+}
diff --git a/src/condor_contrib/aviary/src/PROC_ID_comparator.h b/src/condor_contrib/aviary/src/PROC_ID_comparator.h
new file mode 100644
index 0000000..4a45d1c
--- /dev/null
+++ b/src/condor_contrib/aviary/src/PROC_ID_comparator.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _PROC_ID_COMPARATOR_H
+#define _PROC_ID_COMPARATOR_H
+
+#include <string>
+
+namespace aviary {
+namespace util {
+
+struct PROC_ID_comparator
+{
+	bool operator()(const std::string &lhs, const std::string &rhs);
+};
+
+}};
+
+#endif /* _PROC_ID_COMPARATOR_H */
diff --git a/src/condor_contrib/aviary/src/SchedulerObject.cpp b/src/condor_contrib/aviary/src/SchedulerObject.cpp
new file mode 100644
index 0000000..5f48c97
--- /dev/null
+++ b/src/condor_contrib/aviary/src/SchedulerObject.cpp
@@ -0,0 +1,363 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_attributes.h"
+#include "condor_debug.h"
+#include "condor_qmgr.h"
+#include "../condor_schedd.V6/scheduler.h"
+
+// local includes
+#include "AviaryUtils.h"
+#include "AviaryConversionMacros.h"
+#include "SchedulerObject.h"
+#include "Codec.h"
+
+// Global Scheduler object, used for needReschedule
+extern Scheduler scheduler;
+extern char * Name;
+
+using namespace aviary::job;
+using namespace aviary::util;
+using namespace aviary::codec;
+
+SchedulerObject* SchedulerObject::m_instance = NULL;
+
+SchedulerObject::SchedulerObject()
+{
+    m_pool = getPoolName();
+	m_name = getScheddName();
+    m_codec = new BaseCodec();
+}
+
+SchedulerObject::~SchedulerObject()
+{
+	delete m_codec;
+}
+
+SchedulerObject* SchedulerObject::getInstance()
+{
+    if (!m_instance) {
+        m_instance = new SchedulerObject();
+    }
+    return m_instance;
+}
+
+void
+SchedulerObject::update(const ClassAd &ad)
+{
+	MGMT_DECLARATIONS;
+
+	m_stats.Pool = getPoolName();
+	STRING(CondorPlatform);
+	STRING(CondorVersion);
+	TIME_INTEGER(DaemonStartTime);
+	TIME_INTEGER(JobQueueBirthdate);
+	STRING(Machine);
+	INTEGER(MaxJobsRunning);
+	INTEGER(MonitorSelfAge);
+	DOUBLE(MonitorSelfCPUUsage);
+	DOUBLE(MonitorSelfImageSize);
+	INTEGER(MonitorSelfRegisteredSocketCount);
+	INTEGER(MonitorSelfResidentSetSize);
+	TIME_INTEGER(MonitorSelfTime);
+	STRING(MyAddress);
+    //TIME_INTEGER(MyCurrentTime);
+	STRING(Name);
+	INTEGER(NumUsers);
+	STRING(MyAddress);
+	INTEGER(TotalHeldJobs);
+	INTEGER(TotalIdleJobs);
+	INTEGER(TotalJobAds);
+	INTEGER(TotalRemovedJobs);
+	INTEGER(TotalRunningJobs);
+	m_stats.System = m_stats.Machine;
+
+	// debug
+	if (DebugFlags & D_FULLDEBUG) {
+		const_cast<ClassAd*>(&ad)->dPrint(D_FULLDEBUG|D_NOHEADER);
+	}
+}
+
+
+bool
+SchedulerObject::submit(AttributeMapType &jobAdMap, std::string &id, std::string &text)
+{
+	int cluster;
+	int proc;
+
+    if (!m_codec) {
+        text = "Codec has not been initialized";
+        return false;
+    }
+
+	// our mandatory set of attributes for a submit
+	const char* required[] = {
+				ATTR_JOB_CMD,
+				ATTR_REQUIREMENTS,
+				ATTR_OWNER,
+				ATTR_JOB_IWD,
+				NULL
+				};
+
+		// 1. Create transaction
+	BeginTransaction();
+
+		// 2. Create cluster
+	if (-1 == (cluster = NewCluster())) {
+		AbortTransaction();
+		text = "Failed to create new cluster";
+		return false;
+	}
+
+		// 3. Create proc
+	if (-1 == (proc = NewProc(cluster))) {
+		AbortTransaction();
+		text = "Failed to create new proc";
+		return false;
+	}
+
+		// 4. Submit job ad
+
+		// Schema: (vanilla job)
+		// Schedd demands - Owner, JobUniverse
+		// To run - JobStatus, Requirements
+
+		// Schedd excepts if no Owner
+		// Schedd prunes on startup if no Owner or JobUniverse
+		// Schedd won't run job without JobStatus
+		// Job cannot match without Requirements
+		// Shadow rejects jobs without an Iwd
+		// Shadow: Job has no CondorVersion, assuming pre version 6.3.3
+		// Shadow: Unix Vanilla job is pre version 6.3.3, setting 'TransferFiles = "NEVER"'
+		// Starter won't run job without Cmd
+		// Starter needs a valid Owner (local account name) if not using nobody
+		// condor_q requires ClusterId (int), ProcId (int), QDate (int), RemoteUserCpu (float), JobStatus (int), JobPrio (int), ImageSize (int), Owner (str) and Cmd (str)
+
+		// Schema: (vm job)
+		// ShouldTransferFiles - unset by default, must be set
+
+	ClassAd ad;
+	int universe;
+
+    // ShouldTransferFiles - unset by default, must be set
+    // shadow will try to setup local transfer sandbox otherwise
+    // without good priv
+    ad.Assign(ATTR_SHOULD_TRANSFER_FILES, "NO");
+
+	if (!m_codec->mapToClassAd(jobAdMap, ad)) {
+		AbortTransaction();
+		text = "Failed to parse job ad";
+		return false;
+	}
+
+	std::string missing;
+	if (!checkRequiredAttrs(ad, required, missing)) {
+		AbortTransaction();
+		text = "Job ad is missing required attributes: " + missing;
+		return false;
+	}
+
+		// EARLY SET: These attribute are set early so the incoming ad
+		// has a change to override them.
+	::SetAttribute(cluster, proc, ATTR_JOB_STATUS, "1"); // 1 = idle
+
+		// Junk that condor_q wants, but really shouldn't be necessary
+	::SetAttribute(cluster, proc, ATTR_JOB_REMOTE_USER_CPU, "0.0"); // float
+	::SetAttribute(cluster, proc, ATTR_JOB_PRIO, "0");              // int
+	::SetAttribute(cluster, proc, ATTR_IMAGE_SIZE, "0");            // int
+
+	if (!ad.LookupInteger(ATTR_JOB_UNIVERSE, universe)) {
+		char* uni_str = param("DEFAULT_UNIVERSE");
+		if (!uni_str) {
+			universe = CONDOR_UNIVERSE_VANILLA;
+		}
+		else {
+			universe = CondorUniverseNumber(uni_str);
+		}
+		::SetAttributeInt(cluster, proc, ATTR_JOB_UNIVERSE, universe );
+	}
+	// more stuff - without these our idle stats are whack
+	if ( universe != CONDOR_UNIVERSE_MPI && universe != CONDOR_UNIVERSE_PVM ) {
+		::SetAttribute(cluster, proc, ATTR_MAX_HOSTS, "1");              // int
+		::SetAttribute(cluster, proc, ATTR_MIN_HOSTS, "1");            // int
+	}
+	::SetAttribute(cluster, proc, ATTR_CURRENT_HOSTS, "0"); // int
+
+	ExprTree *expr;
+	const char *name;
+	std::string value;
+	ad.ResetExpr();
+	while (ad.NextExpr(name,expr)) {
+
+			// All these extra lookups are horrible. They have to
+			// be there because the ClassAd may have multiple
+			// copies of the same attribute name! This means that
+			// the last attribute with a given name will set the
+			// value, but the last attribute tends to be the
+			// attribute with the oldest (wrong) value. How
+			// annoying is that!
+		if (!(expr = ad.Lookup(name))) {
+			dprintf(D_ALWAYS, "Failed to lookup %s\n", name);
+
+			AbortTransaction();
+			text = "Failed to parse job ad attribute";
+			return false;
+		}
+
+        value = ExprTreeToString(expr);
+        ::SetAttribute(cluster, proc, name, value.c_str());
+	}
+
+		// LATE SET: These attributes are set late, after the incoming
+		// ad, so they override whatever the incoming ad set.
+	char buf[22]; // 22 is max size for an id, 2^32 + . + 2^32 + \0
+	snprintf(buf, 22, "%d", cluster);
+	::SetAttribute(cluster, proc, ATTR_CLUSTER_ID, buf);
+	snprintf(buf, 22, "%d", proc);
+	::SetAttribute(cluster, proc, ATTR_PROC_ID, buf);
+	snprintf(buf, 22, "%d", time(NULL));
+	::SetAttribute(cluster, proc, ATTR_Q_DATE, buf);
+
+		// Could check for some invalid attributes, e.g
+		//  JobUniverse <= CONDOR_UNIVERSE_MIN or >= CONDOR_UNIVERSE_MAX
+	
+		// 5. Commit transaction
+	CommitTransaction();
+
+
+		// 6. Reschedule
+	scheduler.needReschedule();
+
+
+		// 7. Return identifier
+		// TODO: dag ids?
+	MyString tmp;
+	//tmp.sprintf("%s#%d.%d", Name, cluster, proc);
+	// we have other API compositions for job id and submission id
+	// so let's return raw cluster.proc
+	tmp.sprintf("%d.%d", cluster, proc);
+	id = tmp.Value();
+
+	return true;
+}
+
+bool
+SchedulerObject::setAttribute(std::string key,
+							  std::string name,
+							  std::string value,
+							  std::string &text)
+{
+	PROC_ID id = getProcByString(key.c_str());
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "SetAttribute: Failed to parse id: %s\n", key.c_str());
+		text = "Invalid Id";
+		return false;
+	}
+
+	if (!isValidAttributeName(name,text)) {
+		return false;
+	}
+
+		// All values are strings in the eyes of
+		// ::SetAttribute. Their type is inferred when read from
+		// the ClassAd log. It is important that the incoming
+		// value is properly quoted to differentiate between EXPR
+		// and STRING.
+	if (::SetAttribute(id.cluster,
+					   id.proc,
+					   name.c_str(),
+					   value.c_str())) {
+		text = "Failed to set attribute " + name + " to " + value;
+		return false;
+	}
+
+	return true;
+}
+
+bool
+SchedulerObject::hold(std::string key, std::string &reason, std::string &text)
+{
+	PROC_ID id = getProcByString(key.c_str());
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "Hold: Failed to parse id: %s\n", key.c_str());
+		text = "Invalid Id";
+		return false;
+	}	
+
+	if (!holdJob(id.cluster,
+				 id.proc,
+				 reason.c_str(),
+				 true, // Always perform this action within a transaction
+				 true, // Always notify the shadow of the hold
+				 false, // Do not email the user about this action
+				 false, // Do not email admin about this action
+				 false // This is not a system related (internal) hold
+				 )) {
+		text = "Failed to hold job";
+		return false;
+	}
+
+	return true;
+}
+
+bool
+SchedulerObject::release(std::string key, std::string &reason, std::string &text)
+{
+	PROC_ID id = getProcByString(key.c_str());
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "Release: Failed to parse id: %s\n", key.c_str());
+		text = "Invalid Id";
+		return false;
+	}
+
+	if (!releaseJob(id.cluster,
+					id.proc,
+					reason.c_str(),
+					true, // Always perform this action within a transaction
+					false, // Do not email the user about this action
+					false // Do not email admin about this action
+					)) {
+		text = "Failed to release job";
+		return false;
+	}
+
+	return true;
+}
+
+bool
+SchedulerObject::remove(std::string key, std::string &reason, std::string &text)
+{
+	PROC_ID id = getProcByString(key.c_str());
+	if (id.cluster < 0 || id.proc < 0) {
+		dprintf(D_FULLDEBUG, "Remove: Failed to parse id: %s\n", key.c_str());
+		text = "Invalid Id";
+		return false;
+	}	
+
+	if (!abortJob(id.cluster,
+				  id.proc,
+				  reason.c_str(),
+				  true // Always perform within a transaction
+				  )) {
+		text = "Failed to remove job";
+		return false;
+	}
+
+	return true;
+}
diff --git a/src/condor_contrib/aviary/src/SchedulerObject.h b/src/condor_contrib/aviary/src/SchedulerObject.h
new file mode 100644
index 0000000..670218e
--- /dev/null
+++ b/src/condor_contrib/aviary/src/SchedulerObject.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SCHEDULEROBJECT_H
+#define _SCHEDULEROBJECT_H
+
+// condor includes
+#include "condor_common.h"
+#include "condor_classad.h"
+
+// local includes
+#include "Codec.h"
+#include "AviaryUtils.h"
+
+using namespace std;
+using namespace aviary::util;
+using namespace aviary::codec;
+
+namespace aviary {
+namespace job {
+
+struct SchedulerStats {
+    // Properties
+    string      CondorPlatform;
+    string      CondorVersion;
+    int64_t     DaemonStartTime;
+    string      Pool;
+    string      System;
+    int64_t     JobQueueBirthdate;
+    uint32_t    MaxJobsRunning;
+    string      Machine;
+    string      MyAddress;
+    string      Name;
+
+    // Statistics
+    uint32_t    MonitorSelfAge;
+    double      MonitorSelfCPUUsage;
+    double      MonitorSelfImageSize;
+    uint32_t    MonitorSelfRegisteredSocketCount;
+    uint32_t    MonitorSelfResidentSetSize;
+    int64_t     MonitorSelfTime;
+    uint32_t    NumUsers;
+    uint32_t    TotalHeldJobs;
+    uint32_t    TotalIdleJobs;
+    uint32_t    TotalJobAds;
+    uint32_t    TotalRemovedJobs;
+    uint32_t    TotalRunningJobs;
+};
+
+class SchedulerObject {
+public:
+
+
+	void update(const ClassAd &ad);
+	bool submit(AttributeMapType& jobAdMap, string& id, string& text);
+	bool setAttribute(string id,
+                      string name,
+                      string value,
+                      string &text);
+	bool hold(string id, string &reason, string &text);
+	bool release(string id, string &reason, string &text);
+	bool remove(string id, string &reason, string &text);
+
+    static SchedulerObject* getInstance();
+
+	const char* getPool() {return m_pool.c_str(); }
+	const char* getName() {return m_name.c_str(); }
+
+	~SchedulerObject();
+
+private:
+    SchedulerObject();
+	SchedulerObject(SchedulerObject const&);
+	SchedulerObject& operator=(SchedulerObject const&);
+
+    string m_pool;
+    string m_name;
+	Codec* m_codec;
+    SchedulerStats m_stats;
+    static SchedulerObject* m_instance;
+
+};
+
+
+}} /* aviary::job */
+
+#endif /* _SCHEDULEROBJECT_H */
diff --git a/src/condor_contrib/aviary/src/SubmissionObject.cpp b/src/condor_contrib/aviary/src/SubmissionObject.cpp
new file mode 100644
index 0000000..9ca84b3
--- /dev/null
+++ b/src/condor_contrib/aviary/src/SubmissionObject.cpp
@@ -0,0 +1,221 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_config.h"
+#include "condor_debug.h"
+#include "condor_attributes.h"
+#include "proc.h"
+
+// local includes
+#include "SubmissionObject.h"
+#include "JobServerObject.h"
+#include "AviaryUtils.h"
+
+using namespace std;
+using namespace aviary::query;
+using namespace aviary::codec;
+using namespace aviary::util;
+
+SubmissionObject::SubmissionObject (
+                                     const char *_name,
+                                     const char *_owner ) :
+        ownerSet ( false )
+{
+	m_name = _name;
+    if ( _owner )
+    {
+        setOwner ( _owner );
+    }
+    else
+    {
+        setOwner ( "Unknown" );
+        ownerSet = false;
+    }
+
+    m_codec = new BaseCodec;
+
+    dprintf ( D_FULLDEBUG, "Created new SubmissionObject '%s' for '%s'\n", _name, _owner);
+}
+
+SubmissionObject::~SubmissionObject()
+{
+	dprintf ( D_FULLDEBUG, "SubmissionObject::~SubmissionObject for '%s'\n", m_name.c_str());
+	delete m_codec;
+}
+
+void
+SubmissionObject::increment ( const Job *job )
+{
+    int status = job->getStatus();
+
+    dprintf ( D_FULLDEBUG, "SubmissionObject::increment '%s' on '%s'\n", getJobStatusString(status), job->getKey());
+
+    switch ( status )
+    {
+        case IDLE:
+            m_idle.insert ( job );
+            break;
+        case RUNNING:
+            m_running.insert ( job );
+            break;
+        case REMOVED:
+            m_removed.insert ( job );
+            break;
+        case COMPLETED:
+            m_completed.insert ( job );
+            break;
+        case HELD:
+            m_held.insert ( job );
+            break;
+        default:
+            dprintf ( D_ALWAYS, "error: Unknown %s of %d on %s\n",
+                      ATTR_JOB_STATUS, status, job->getKey() );
+            break;
+    }
+}
+
+void
+SubmissionObject::decrement ( const Job *job )
+{
+    int status = job->getStatus();
+
+    dprintf ( D_FULLDEBUG, "SubmissionObject::decrement '%s' on '%s'\n", getJobStatusString(status), job->getKey());
+
+    switch ( status )
+    {
+        case IDLE:
+            m_idle.erase ( job );
+            break;
+        case RUNNING:
+            m_running.erase ( job );
+            break;
+        case REMOVED:
+            m_removed.erase ( job );
+            break;
+        case COMPLETED:
+            m_completed.erase ( job );
+            break;
+        case HELD:
+            m_held.erase ( job );
+            break;
+        default:
+            dprintf ( D_ALWAYS, "error: Unknown %s of %d on %s\n",
+                      ATTR_JOB_STATUS, status, job->getKey() );
+            break;
+    }
+}
+
+
+const SubmissionObject::JobSet &
+SubmissionObject::getIdle()
+{
+    return m_idle;
+}
+
+const SubmissionObject::JobSet &
+SubmissionObject::getRunning()
+{
+    return m_running;
+}
+
+const SubmissionObject::JobSet &
+SubmissionObject::getRemoved()
+{
+    return m_removed;
+}
+
+const SubmissionObject::JobSet &
+SubmissionObject::getCompleted()
+{
+    return m_completed;
+}
+
+const SubmissionObject::JobSet &
+SubmissionObject::getHeld()
+{
+    return m_held;
+}
+
+void
+SubmissionObject::setOwner ( const char *_owner )
+{
+    if ( !ownerSet )
+    {
+        m_owner = _owner;
+        ownerSet = true;
+    }
+}
+
+JobSummaryPair makeJobPair(const Job* job) {
+	JobServerObject* jso = JobServerObject::getInstance();
+	const char* job_cp = job->getKey();
+	JobSummaryFields* jsf = new JobSummaryFields;
+	AviaryStatus status;
+	// TODO: should check this return val i suppose
+	jso->getSummary(job_cp, *jsf, status);
+	return make_pair(job_cp,jsf);
+}
+
+void
+SubmissionObject::getJobSummaries ( JobSummaryPairCollection &jobs)
+{
+
+    // id, timestamp (which?), command, args, ins, outs, state, message
+    // id, time queued, time entered current state, state, command, args, hold reason, release reason
+
+    // find all the jobs in their various states...
+
+    //1) Idle
+    for ( SubmissionObject::JobSet::const_iterator i = getIdle().begin();
+            getIdle().end() != i; i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+	}
+
+    //2) Running
+    for ( SubmissionObject::JobSet::const_iterator i = getRunning().begin();
+            getRunning().end() != i;
+            i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+    }
+
+    //3) Removed
+    for ( SubmissionObject::JobSet::const_iterator i = getRemoved().begin();
+            getRemoved().end() != i; i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+    }
+
+    //4) Completed
+    for ( SubmissionObject::JobSet::const_iterator i = getCompleted().begin();
+            getCompleted().end() != i; i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+    }
+
+    //5) Held
+    for ( SubmissionObject::JobSet::const_iterator i = getHeld().begin();
+            getHeld().end() != i; i++ )
+    {
+		jobs.push_back(makeJobPair(*i));
+    }
+
+}
diff --git a/src/condor_contrib/aviary/src/SubmissionObject.h b/src/condor_contrib/aviary/src/SubmissionObject.h
new file mode 100644
index 0000000..2b0f7a6
--- /dev/null
+++ b/src/condor_contrib/aviary/src/SubmissionObject.h
@@ -0,0 +1,88 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _SUBMISSIONOBJECT_H
+#define _SUBMISSIONOBJECT_H
+
+// c++ includes
+#include <string>
+#include <map>
+#include <set>
+
+// coondor includes
+#include "condor_common.h"
+
+// local includes
+#include "Job.h"
+#include "JobServerObject.h"
+
+using std::string;
+using std::map;
+using std::set;
+
+namespace aviary {
+namespace query {
+		
+struct cmpjob {
+	bool operator()(const Job *a, const Job *b) const {
+		return strcmp(a->getKey(), b->getKey()) < 0;
+	}
+};
+
+class SubmissionObject
+{
+public:
+    friend class Job;
+	typedef set<const Job *, cmpjob> JobSet;
+
+	SubmissionObject( const char *name, const char *owner);
+	~SubmissionObject();
+
+	const JobSet & getIdle();
+	const JobSet & getRunning();
+	const JobSet & getRemoved();
+	const JobSet & getCompleted();
+	const JobSet & getHeld();
+
+	void setOwner(const char *owner);
+	const char* getOwner() { return m_owner.c_str(); }
+	const char* getName() { return m_name.c_str(); }
+	void getJobSummaries(JobSummaryPairCollection& _jobs);
+
+protected:
+	void increment(const Job *job);
+	void decrement(const Job *job);
+
+private:
+	JobSet m_idle;
+	JobSet m_running;
+	JobSet m_removed;
+	JobSet m_completed;
+	JobSet m_held;
+
+	bool ownerSet;
+
+	string m_name;
+	string m_owner;
+	Codec* m_codec;
+
+};
+
+}}
+
+#endif /* _SUBMISSIONOBJECT_H */
diff --git a/src/condor_contrib/aviary/src/aviary_query_server.cpp b/src/condor_contrib/aviary/src/aviary_query_server.cpp
new file mode 100644
index 0000000..1231a27
--- /dev/null
+++ b/src/condor_contrib/aviary/src/aviary_query_server.cpp
@@ -0,0 +1,279 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+// condor includes
+#include "condor_common.h"
+#include "condor_daemon_core.h"
+#include "condor_debug.h"
+#include "condor_attributes.h"
+#include "get_daemon_name.h"
+#include "subsystem_info.h"
+#include "condor_config.h"
+#include "stat_info.h"
+#include "JobLogMirror.h"
+
+// local includes
+#include "Axis2SoapProvider.h"
+#include "JobServerJobLogConsumer.h"
+#include "JobServerObject.h"
+#include "HistoryProcessingUtils.h"
+#include "Globals.h"
+
+// about self
+DECL_SUBSYSTEM("QUERY_SERVER", SUBSYSTEM_TYPE_DAEMON );	// used by Daemon Core
+
+using namespace std;
+using namespace aviary::query;
+using namespace aviary::soap;
+using namespace aviary::history;
+
+ClassAd	*ad = NULL;
+Axis2SoapProvider* provider = NULL;
+JobLogMirror *mirror = NULL;
+JobServerJobLogConsumer *consumer = NULL;
+JobServerObject *job_server = NULL;
+
+extern MyString m_path;
+
+void init_classad();
+void Dump();
+int HandleTransportSocket(Service *, Stream *);
+int HandleResetSignal(Service *, int);
+void ProcessHistoryTimer(Service*);
+
+//-------------------------------------------------------------
+
+int main_init(int /* argc */, char * /* argv */ [])
+{
+	dprintf(D_ALWAYS, "main_init() called\n");
+
+	// setup the job log consumer
+	consumer = new JobServerJobLogConsumer();
+	mirror = new JobLogMirror(consumer);
+	mirror->init();
+
+    // config then env for our all-important axis2 repo dir
+    const char* log_file = "./aviary_query.axis2.log";
+	string repo_path;
+	char *tmp = NULL;
+	if (tmp = param("WSFCPP_HOME")) {
+		repo_path = tmp;
+		free(tmp);
+	}
+	else if (tmp = getenv("WSFCPP_HOME")) {
+		repo_path = tmp;
+	}
+	else {
+		EXCEPT("No WSFCPP_HOME in config or env");
+	}
+
+	int port = param_integer("HTTP_PORT",9091);
+	int level = param_integer("AXIS2_DEBUG_LEVEL",AXIS2_LOG_LEVEL_CRITICAL);
+
+    // init transport here
+    provider = new Axis2SoapProvider(level,log_file,repo_path.c_str());
+
+    std::string axis_error;
+    if (!provider->init(port,AXIS2_HTTP_DEFAULT_SO_TIMEOUT,axis_error)) {
+		dprintf(D_ALWAYS, "%s\n",axis_error.c_str());
+        EXCEPT("Failed to initialize Axis2SoapProvider");
+    }
+
+	init_classad();
+
+	ReliSock *sock = new ReliSock;
+	if (!sock) {
+		EXCEPT("Failed to allocate transport socket");
+	}
+
+	if (!sock->assign(provider->getHttpListenerSocket())) {
+		EXCEPT("Failed to bind transport socket");
+	}
+	int index;
+	if (-1 == (index =
+			   daemonCore->Register_Socket((Stream *) sock,
+                                           "Transport method socket",
+										   (SocketHandler)
+										   HandleTransportSocket,
+                                           "Handler for transport invocations"))) {
+		EXCEPT("Failed to register transport socket");
+	}
+
+	job_server = JobServerObject::getInstance();
+
+	dprintf(D_ALWAYS,"Axis2 listener on http port: %d\n",port);
+
+    // before doing any job history processing, set the location of the files
+    // TODO: need to test mal-HISTORY values: HISTORY=/tmp/somewhere
+    const char* tmp2 = param ( "HISTORY" );
+    StatInfo si( tmp2 );
+    tmp2 = si.DirPath ();
+    if ( !tmp2 )
+    {
+        dprintf ( D_ALWAYS, "warning: No HISTORY defined - Aviary Query Server will not process history jobs\n" );
+    }
+    else
+    {
+        m_path = tmp2;
+        dprintf ( D_FULLDEBUG, "HISTORY path is %s\n",tmp2 );
+        // register a timer for processing of historical job files
+        if (-1 == (index =
+            daemonCore->Register_Timer(
+                0,
+                param_integer("HISTORY_INTERVAL",120),
+                (TimerHandler)ProcessHistoryTimer,
+                "Timer for processing job history files"
+                ))) {
+        EXCEPT("Failed to register history timer");
+        }
+    }
+
+    // useful for testing job coalescing
+    // and potentially just useful
+	if (-1 == (index =
+		daemonCore->Register_Signal(SIGUSR1,
+				    "Forced Reset Signal",
+				    (SignalHandler)
+				    HandleResetSignal,
+				    "Handler for Reset signals"))) {
+		EXCEPT("Failed to register Reset signal");
+	}
+
+	return TRUE;
+}
+
+void
+init_classad()
+{
+	if ( ad ) {
+		delete ad;
+	}
+	ad = new ClassAd();
+
+	ad->SetMyTypeName("QueryServer");
+	ad->SetTargetTypeName("Daemon");
+
+	char* default_name = default_daemon_name();
+		if( ! default_name ) {
+			EXCEPT( "default_daemon_name() returned NULL" );
+		}
+	ad->Assign(ATTR_NAME, default_name);
+	delete [] default_name;
+
+	ad->Assign(ATTR_MY_ADDRESS, my_ip_string());
+
+	// Initialize all the DaemonCore-provided attributes
+	daemonCore->publish( ad );
+
+}
+
+//-------------------------------------------------------------
+
+int 
+main_config()
+{
+	dprintf(D_ALWAYS, "main_config() called\n");
+
+	return TRUE;
+}
+
+//-------------------------------------------------------------
+
+void Stop()
+{
+	if (param_boolean("DUMP_STATE", false)) {
+		Dump();
+	}
+
+	delete job_server;
+
+	DC_Exit(0);
+}
+
+//-------------------------------------------------------------
+
+int main_shutdown_fast()
+{
+	dprintf(D_ALWAYS, "main_shutdown_fast() called\n");
+
+	Stop();
+
+	DC_Exit(0);
+	return TRUE;	// to satisfy c++
+}
+
+//-------------------------------------------------------------
+
+int main_shutdown_graceful()
+{
+	dprintf(D_ALWAYS, "main_shutdown_graceful() called\n");
+
+	Stop();
+
+	DC_Exit(0);
+	return TRUE;	// to satisfy c++
+}
+
+//-------------------------------------------------------------
+
+void
+main_pre_dc_init( int /* argc */, char* /* argv */ [] )
+{
+		// dprintf isn't safe yet...
+}
+
+
+void
+main_pre_command_sock_init( )
+{
+}
+
+
+int
+HandleTransportSocket(Service *, Stream *)
+{
+	// respond to a transport callback here
+	std::string provider_error;
+    if (!provider->processHttpRequest(provider_error)) {
+        dprintf (D_ALWAYS,"Error processing request: %s\n",provider_error.c_str());
+    }
+
+	return KEEP_STREAM;
+}
+
+int
+HandleResetSignal(Service *, int)
+{
+	consumer->Reset();
+
+    return TRUE;
+}
+
+void ProcessHistoryTimer(Service*) {
+	dprintf(D_FULLDEBUG, "ProcessHistoryTimer() called\n");
+    processHistoryDirectory();
+    processOrphanedIndices();
+    processCurrentHistory();
+}
+
+
+void
+Dump()
+{
+	dprintf(D_ALWAYS|D_NOHEADER, "DUMP called\n");
+}
diff --git a/src/condor_contrib/aviary/src/cmpstr.h b/src/condor_contrib/aviary/src/cmpstr.h
new file mode 100644
index 0000000..a4b2fbe
--- /dev/null
+++ b/src/condor_contrib/aviary/src/cmpstr.h
@@ -0,0 +1,28 @@
+/***************************************************************
+ *
+ * Copyright (C) 2009-2011 Red Hat, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _CMPSTR_H
+#define _CMPSTR_H
+
+struct cmpstr {
+   bool operator()(const char *a, const char *b) const {
+      return strcmp(a, b) < 0;
+   }
+};
+
+#endif /* _CMPSTR_H */
diff --git a/src/condor_contrib/aviary/test/jobcontrol.py b/src/condor_contrib/aviary/test/jobcontrol.py
new file mode 100755
index 0000000..a7c051f
--- /dev/null
+++ b/src/condor_contrib/aviary/test/jobcontrol.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+from suds import *
+from suds.client import Client
+from sys import exit, argv, stdin
+import time
+
+# change these for other default locations and ports
+job_wsdl = 'file:/var/lib/condor/aviary/services/job/aviary-job.wsdl'
+
+cmds = ['holdJob', 'releaseJob', 'removeJob']
+
+cmdarg = len(argv) > 1 and argv[1]
+cproc =  len(argv) > 2 and argv[2]
+job_url = len(argv) > 3 and argv[3] or "http://localhost:9090/services/job/"
+
+if cmdarg not in cmds:
+	print "error unknown command: ", cmdarg
+	print "available commands are: ",cmds
+	exit(1)
+
+client = Client(job_wsdl);
+job_url += cmdarg
+client.set_options(location=job_url)
+
+# set up our JobID
+jobId = client.factory.create('ns0:JobID')
+jobId.job = cproc
+
+try:
+	func = getattr(client.service, cmdarg, None)
+	if callable(func):
+	    result = func(jobId,"test")
+except Exception, e:
+	print "unable to access scheduler at: ", job_url
+	print e
+	exit(1)
+
+if result.code != "OK":
+	print result.code,"; ", result.text
diff --git a/src/condor_contrib/aviary/test/jobquery.py b/src/condor_contrib/aviary/test/jobquery.py
new file mode 100755
index 0000000..f311c38
--- /dev/null
+++ b/src/condor_contrib/aviary/test/jobquery.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+import logging
+from suds import *
+from suds.client import Client
+from sys import exit, argv, stdin
+import time
+
+# enable these to see the SOAP messages
+#logging.basicConfig(level=logging.INFO)
+#logging.getLogger('suds.client').setLevel(logging.DEBUG)
+
+# change these for other default locations and ports
+job_wsdl = 'file:/var/lib/condor/aviary/services/query/aviary-query.wsdl'
+
+cmds = ['getJobStatus', 'getJobSummary', 'getJobDetails']
+
+cmdarg = len(argv) > 1 and argv[1]
+cproc =  len(argv) > 2 and argv[2]
+job_url = len(argv) > 3 and argv[3] or "http://localhost:9091/services/query/"
+
+if cmdarg not in cmds:
+	print "error unknown command: ", cmdarg
+	print "available commands are: ",cmds
+	exit(1)
+
+client = Client(job_wsdl);
+job_url += cmdarg
+client.set_options(location=job_url)
+
+# enable to see service schema
+#print client
+
+# set up our JobID
+if cproc:
+	jobId = client.factory.create("ns0:JobID")
+	jobId.job = cproc
+else:
+	# returns all jobs
+	jobId = None
+
+try:
+	func = getattr(client.service, cmdarg, None)
+	if callable(func):
+	    result = func(jobId)
+except Exception, e:
+	print "invocation failed: ", job_url
+	print e
+	exit(1)
+
+print result
diff --git a/src/condor_contrib/aviary/test/setattr.py b/src/condor_contrib/aviary/test/setattr.py
new file mode 100755
index 0000000..175210c
--- /dev/null
+++ b/src/condor_contrib/aviary/test/setattr.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+from suds import *
+from suds.client import Client
+from sys import exit, argv, stdin
+import time
+
+# change these for other default locations and ports
+job_wsdl = 'file:/var/lib/condor/aviary/services/job/aviary-job.wsdl'
+
+cproc =  len(argv) > 1 and argv[1]
+attr_name = len(argv) > 2 and argv[2]
+attr_value = len(argv) > 3 and argv[3]
+job_url = len(argv) > 4 and argv[4] or "http://localhost:9090/services/job/setJobAttribute"
+
+client = Client(job_wsdl);
+client.set_options(location=job_url)
+
+# set up our JobID
+jobId = client.factory.create('ns0:JobID')
+jobId.job = cproc
+
+# set up the Attribute
+aviary_attr = client.factory.create('ns0:Attribute')
+aviary_attr.name = attr_name
+aviary_attr.type = "STRING";
+aviary_attr.value = '"'+attr_value+'"'
+
+try:
+	result = client.service.setJobAttribute(jobId, aviary_attr)
+except Exception, e:
+	print "unable to access scheduler at: ", job_url
+	print e
+	exit(1)
+
+if result.code != "OK":
+	print result.code,"; ", result.text
diff --git a/src/condor_contrib/aviary/test/submissions.py b/src/condor_contrib/aviary/test/submissions.py
new file mode 100755
index 0000000..1f03d63
--- /dev/null
+++ b/src/condor_contrib/aviary/test/submissions.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+import logging
+from suds import *
+from suds.client import Client
+from sys import exit, argv
+
+# enable these to see the SOAP messages
+#logging.basicConfig(level=logging.INFO)
+#logging.getLogger('suds.client').setLevel(logging.DEBUG)
+
+query_wsdl = 'file:/var/lib/condor/aviary/services/query/aviary-query.wsdl'
+
+sub_name = len(argv) > 1 and argv[1]
+query_url = len(argv) > 2 and argv[2] or 'http://localhost:9091/services/query/getSubmissionSummary'
+
+client = Client(query_wsdl);
+client.set_options(location=query_url)
+
+# enable to see service schema
+#print client
+
+# set up our ID
+if sub_name:
+	subId = client.factory.create("ns0:SubmissionID")
+	subId.name = sub_name
+else:
+	# returns all jobs
+	subId = None
+
+try:
+	submissions = client.service.getSubmissionSummary(subId)
+except Exception, e:
+	print "invocation failed: ", query_url
+	print e
+	exit(1)
+
+print submissions
diff --git a/src/condor_contrib/aviary/test/submit.py b/src/condor_contrib/aviary/test/submit.py
new file mode 100755
index 0000000..87b2f44
--- /dev/null
+++ b/src/condor_contrib/aviary/test/submit.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright 2009-2011 Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# uses Suds - https://fedorahosted.org/suds/
+from suds import *
+from suds.client import Client
+from sys import exit, argv
+import time, pwd
+
+uid = pwd.getpwuid(os.getuid())[0]
+if not uid:
+    uid = "condor"
+
+quiet = False
+
+# change these for other default locations and ports
+job_wsdl = 'file:/var/lib/condor/aviary/services/job/aviary-job.wsdl'
+job_url = 'http://localhost:9090/services/job/submitJob'
+
+for arg in argv[1:]:
+	if arg == '-q':
+		quiet = True
+	if "http://" in arg:
+		url = arg
+
+client = Client(job_wsdl);
+client.set_options(location=job_url)
+
+if not quiet:
+	print client
+	
+# add specific requirements here
+req1 = client.factory.create("ns0:ResourceConstraint")
+req1.type = 'OS'
+req1.value = 'LINUX'
+reqs = [ req1 ]
+
+# add extra Condor-specific or custom job attributes here
+extra1 = client.factory.create("ns0:Attribute")
+extra1.name = 'RECIPE'
+extra1.type = 'STRING'
+extra1.value = 'SECRET_SAUCE'
+extras = [ extra1 ]
+
+try:
+	result = client.service.submitJob( \
+	# the executable command
+		'/bin/sleep', \
+	# some arguments for the command
+		'120', \
+	# the submitter name
+		uid, \
+	# initial working directory wwhere job will execute
+		'/tmp', \
+	# an arbitrary string identifying the target submission group
+		'python_test_submit', \
+	# special resource requirements
+		reqs,	\
+	# additional attributes
+		extras
+	)
+except Exception, e:
+	print "invocation failed at: ", job_url
+	print e
+	exit(1)	
+
+if result.status.code != "OK":
+	print result.status.code,"; ", result.status.text
+	exit(1)
+
+if not quiet:
+	print result
+else:
+	print result.id.job;
diff --git a/src/condor_contrib/mgmt/qmf/daemons/Globals.cpp b/src/condor_contrib/mgmt/qmf/daemons/Globals.cpp
index 0a850ff..37a5873 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/Globals.cpp
+++ b/src/condor_contrib/mgmt/qmf/daemons/Globals.cpp
@@ -20,4 +20,5 @@
 
 JobCollectionType g_jobs;
 SubmissionCollectionType g_submissions;
-OwnerlessClusterType g_ownerless;
\ No newline at end of file
+OwnerlessClusterType g_ownerless_clusters;
+OwnerlessSubmissionType g_ownerless_submissions;
diff --git a/src/condor_contrib/mgmt/qmf/daemons/Globals.h b/src/condor_contrib/mgmt/qmf/daemons/Globals.h
index 989d7ac..8850a0c 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/Globals.h
+++ b/src/condor_contrib/mgmt/qmf/daemons/Globals.h
@@ -33,10 +33,12 @@ using namespace std;
 
 typedef map<const char *, Job *, cmpstr> JobCollectionType;
 typedef map<const char *, SubmissionObject *, cmpstr> SubmissionCollectionType;
-typedef map<int, const char *> OwnerlessClusterType;
+typedef map<int, string> OwnerlessClusterType;
+typedef map<int, SubmissionObject*> OwnerlessSubmissionType;
 
 extern JobCollectionType g_jobs;
 extern SubmissionCollectionType g_submissions;
-extern OwnerlessClusterType g_ownerless;
+extern OwnerlessClusterType g_ownerless_clusters;
+extern OwnerlessSubmissionType g_ownerless_submissions;
 
 #endif /* _GLOBALS_H */
diff --git a/src/condor_contrib/mgmt/qmf/daemons/Job.cpp b/src/condor_contrib/mgmt/qmf/daemons/Job.cpp
index 22ea98a..301949e 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/Job.cpp
+++ b/src/condor_contrib/mgmt/qmf/daemons/Job.cpp
@@ -247,7 +247,8 @@ LiveJobImpl::Set ( const char *_name, const char *_value )
 	// if we are in here, we don't have m_submission
 	PROC_ID id = getProcByString(m_job->GetKey());
 	std::string val = TrimQuotes( _value );
-	g_ownerless[id.cluster] = strdup( val.c_str() );
+	g_ownerless_clusters[id.cluster] = val;
+	m_job->UpdateSubmission(id.cluster,val.c_str());
     }
 
     // parse the type
@@ -372,7 +373,7 @@ HistoryJobImpl::HistoryJobImpl ( const HistoryEntry& _he):
 	m_he(_he)
 {
     m_job = NULL;
-    g_ownerless[_he.cluster] = strdup(_he.owner.c_str());
+    g_ownerless_clusters[_he.cluster] = _he.owner;
     dprintf ( D_FULLDEBUG, "HistoryJobImpl created for '%d.%d'\n", _he.cluster, _he.proc );
 }
 
@@ -585,18 +586,26 @@ void Job::DecrementSubmission() {
 }
 
 void
+Job::UpdateSubmission ( int cluster, const char* owner )
+{
+	OwnerlessSubmissionType::const_iterator it = g_ownerless_submissions.find ( cluster );
+	if ( g_ownerless_submissions.end() != it ) {
+		SubmissionObject* submission = (*it).second;
+		submission->SetOwner(owner);
+		g_ownerless_submissions.erase(cluster);
+	}
+}
+
+void
 Job::SetSubmission ( const char* _subName, int cluster )
 {
 	const char* owner = NULL;
 
 	// need to see if someone has left us an owner
-	OwnerlessClusterType::const_iterator it = g_ownerless.find ( cluster );
-	if ( g_ownerless.end() == it )
+	OwnerlessClusterType::const_iterator it = g_ownerless_clusters.find ( cluster );
+	if ( g_ownerless_clusters.end() != it )
 	{
-		dprintf ( D_FULLDEBUG, "warning: unable to resolve owner for Job key '%s' and cluster '%d'\n", GetKey(), cluster );
-	}
-	else {
-		owner = ( *it ).second ;
+		owner = ( *it ).second.c_str() ;
 	}
 
 	SubmissionCollectionType::const_iterator element = g_submissions.find ( _subName );
@@ -617,7 +626,11 @@ Job::SetSubmission ( const char* _subName, int cluster )
 	if (owner) {
 		// ensure that the submission has an owner
 		m_submission->SetOwner ( owner );
-		g_ownerless.erase ( cluster );
+		g_ownerless_clusters.erase ( cluster );
+	}
+	else {
+		// add it to our list to be updated for owner
+		g_ownerless_submissions[cluster] = m_submission;
 	}
 
 }
diff --git a/src/condor_contrib/mgmt/qmf/daemons/Job.h b/src/condor_contrib/mgmt/qmf/daemons/Job.h
index 2a640f5..147b10b 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/Job.h
+++ b/src/condor_contrib/mgmt/qmf/daemons/Job.h
@@ -149,6 +149,7 @@ class Job
         void Remove ( const char* );
 
         void SetSubmission ( const char*, int );
+        void UpdateSubmission ( int, const char* );
         void IncrementSubmission();
         void DecrementSubmission();
 
diff --git a/src/condor_contrib/mgmt/qmf/daemons/JobServerJobLogConsumer.cpp b/src/condor_contrib/mgmt/qmf/daemons/JobServerJobLogConsumer.cpp
index 62f22c2..7eb7342 100644
--- a/src/condor_contrib/mgmt/qmf/daemons/JobServerJobLogConsumer.cpp
+++ b/src/condor_contrib/mgmt/qmf/daemons/JobServerJobLogConsumer.cpp
@@ -118,9 +118,7 @@ JobServerJobLogConsumer::NewClassAd(const char *_key,
 		JobCollectionType::const_iterator element = g_jobs.find(cluster_dup);
         ClusterJobImpl* cluster_impl = NULL;
 
-		// TODO this code assumes that we will always get the parent 
-		// classad before its child from the job log...this is not strictly
-		// guaranteed (e.g., compressed log?)
+		// either find an existing cluster parent or create a new one
 		if (g_jobs.end() == element) {
 			// didn't find an existing job so create a new one
 			Job* new_cluster_job = new Job(cluster_dup);
@@ -136,13 +134,6 @@ JobServerJobLogConsumer::NewClassAd(const char *_key,
         new_proc_job->SetImpl(new LiveJobImpl(key_dup, cluster_impl));
         g_jobs[key_dup] = new_proc_job;
 
-//		if (cluster_job) {
-//			ClassAd ad;
-//			cluster_job->GetFullAd(ad);
-//			dprintf(D_FULLDEBUG, "JobServerJobLogConsumer::NewClassAd found a parent ClassAd from cluster...\n");
-//			ad.dPrint(D_FULLDEBUG|D_NOHEADER);
-//		}
-
 	}
 
 	return true;
diff --git a/src/condor_contrib/mgmt/qmf/plugins/NegotiatorObject.cpp b/src/condor_contrib/mgmt/qmf/plugins/NegotiatorObject.cpp
index 78baa6c..48290df 100644
--- a/src/condor_contrib/mgmt/qmf/plugins/NegotiatorObject.cpp
+++ b/src/condor_contrib/mgmt/qmf/plugins/NegotiatorObject.cpp
@@ -188,7 +188,7 @@ NegotiatorObject::SetLimit(std::string &name, double max, std::string &text)
 		return STATUS_USER + 1;
 	}
 
-	if (!IsValidGroupUserName(name,text)) {
+	if (!IsValidParamName(name,text)) {
 		return STATUS_USER + 2;
 	}
 
@@ -233,7 +233,7 @@ NegotiatorObject::SetRawConfig(std::string &name, std::string &value, std::strin
 		return STATUS_USER + 1;
 	}
 
-	if (!IsValidAttributeName(name,text)) {
+	if (!IsValidParamName(name,text)) {
 		return STATUS_USER + 2;
 	}
 
diff --git a/src/condor_contrib/mgmt/qmf/plugins/Utils.cpp b/src/condor_contrib/mgmt/qmf/plugins/Utils.cpp
index 8262f95..90e2c32 100644
--- a/src/condor_contrib/mgmt/qmf/plugins/Utils.cpp
+++ b/src/condor_contrib/mgmt/qmf/plugins/Utils.cpp
@@ -22,6 +22,8 @@
 
 #include "condor_debug.h"
 
+#include "condor_config.h" // is_valid_param_name
+
 #include "compat_classad_util.h"
 
 
@@ -49,23 +51,37 @@ string TrimQuotes(const char* str) {
 }
 
 // validate that an incoming group/user name is
-// alphanumeric, underscores, or a dot separator
+// alphanumeric, underscores, @ or a dot separator
 bool IsValidGroupUserName(const std::string& _name, std::string& _text) {
 	const char* ptr = _name.c_str();
+
 	while( *ptr ) {
 		char c = *ptr++;
 		if (	('a' > c || c > 'z') &&
 			('A' > c || c > 'Z') &&
 			('0' > c || c > '9') &&
 			(c != '_' ) &&
+			(c != '@' ) &&
 			(c != '.' ) ) {
-			_text = "Invalid name for group/user - alphanumeric, underscore and dot characters only";
+			_text = "Invalid name for group/user - alphanumeric, underscore, @ and dot characters only";
 			return false;
 		}
 	}
 	return true;
 }
 
+// validate that an incoming group/user name is
+// alphanumeric, underscores, or a dot separator
+bool IsValidParamName(const std::string& _name, std::string& _text) {
+	const char* ptr = _name.c_str();
+
+	if (!is_valid_param_name(ptr)) {
+		_text = "Invalid name for group/user - alphanumeric, underscore, @ and dot characters only";
+		return false;
+	}
+	return true;
+}
+
 // validate that an incoming attribute name is
 // alphanumeric, or underscores
 bool IsValidAttributeName(const std::string& _name, std::string& _text) {
@@ -161,18 +177,14 @@ bool
 PopulateVariantMapFromAd(compat_classad::ClassAd &ad, Variant::Map &_map)
 {
 	ExprTree *expr;
-    ClassAd::iterator iter;
-
-    ad.ResetExpr();
-    _map.clear();
-    iter = ad.begin();
-    while (iter != ad.end()) {
-            string name = iter->first;
-            if (!AddAttribute(ad, name.c_str(), _map)) {
+	const char *name;
+	ad.ResetExpr();
+	_map.clear();
+	while (ad.NextExpr(name,expr)) {
+		if (!AddAttribute(ad, name, _map)) {
                     return false;
-            }
-            iter++;
-    }
+		}
+	}
 
 	// TODO: debug
 //	if (DebugFlags & D_FULLDEBUG) {
diff --git a/src/condor_contrib/mgmt/qmf/plugins/Utils.h b/src/condor_contrib/mgmt/qmf/plugins/Utils.h
index a248dab..670956a 100644
--- a/src/condor_contrib/mgmt/qmf/plugins/Utils.h
+++ b/src/condor_contrib/mgmt/qmf/plugins/Utils.h
@@ -27,6 +27,8 @@ bool AddAttribute(compat_classad::ClassAd &ad, const char *name, qpid::types::Va
 
 bool IsValidGroupUserName(const std::string& _name, std::string& _text);
 
+bool IsValidParamName(const std::string& _name, std::string& _text);
+
 bool IsValidAttributeName(const std::string& _name, std::string& _text);
 
 bool CheckRequiredAttrs(compat_classad::ClassAd& ad, const char* attrs[], std::string& missing);
diff --git a/src/condor_contrib/triggerd/src/TriggerConsole.cpp b/src/condor_contrib/triggerd/src/TriggerConsole.cpp
index 75406e5..5801fea 100644
--- a/src/condor_contrib/triggerd/src/TriggerConsole.cpp
+++ b/src/condor_contrib/triggerd/src/TriggerConsole.cpp
@@ -102,15 +102,37 @@ TriggerConsole::config(std::string host, int port, std::string user, std::string
    url << host << ":" << port;
    options << "{reconnect:True"; 
    if (!user.empty())
+   {
       options << ", username:'" << user << "', password:'" << passwd << "'";
+   }
    options << "}";
 
-   qpidConnection = qpid::messaging::Connection(url.str(), options.str());
-   qpidConnection.open();
+   try
+   {
+      qpidConnection = qpid::messaging::Connection(url.str(), options.str());
+      qpidConnection.open();
+   }
+   catch(...)
+   {
+      dprintf(D_ALWAYS, "Triggerd Error: Failed to contact AMQP broker on host '%s'.  Absent nodes detection disabled\n", host.c_str());
+      qpidConnection.close();
+   }
 
-   qmf2Session = qmf::ConsoleSession(qpidConnection);
-   qmf2Session.open();
-   qmf2Session.setAgentFilter("[and, [eq, _vendor, [quote, 'com.redhat.grid']], [eq, _product, [quote, 'master']]]");
+   if (true == qpidConnection.isOpen())
+   {
+      try
+      {
+         qmf2Session = qmf::ConsoleSession(qpidConnection);
+         qmf2Session.open();
+         qmf2Session.setAgentFilter("[and, [eq, _vendor, [quote, 'com.redhat.grid']], [eq, _product, [quote, 'master']]]");
+      }
+      catch(...)
+      {
+         dprintf(D_ALWAYS, "Triggerd Error: Failed to setup QMF connections\n");
+         qpidConnection.close();
+         qmf2Session.close();
+      }
+   }
 }
 
 
@@ -124,6 +146,12 @@ TriggerConsole::findAbsentNodes()
    std::list<std::string> missing_nodes;
    uint64_t timeout(30);
 
+   // Only Perform the check if the qpid connection is valid
+   if (false == qpidConnection.isOpen())
+   {
+      return missing_nodes;
+   }
+
    // Drain the queue of pending console events.
    qmf::ConsoleEvent evt;
    while (qmf2Session.nextEvent(evt, qpid::messaging::Duration::IMMEDIATE));
diff --git a/src/condor_contrib/triggerd/src/Triggerd.cpp b/src/condor_contrib/triggerd/src/Triggerd.cpp
index 85e65f9..21fa50d 100644
--- a/src/condor_contrib/triggerd/src/Triggerd.cpp
+++ b/src/condor_contrib/triggerd/src/Triggerd.cpp
@@ -221,22 +221,13 @@ Triggerd::init()
    triggerCollection = new ClassAdCollection(trigger_log.c_str());
    free(dataDir);
 
-   // Initialize the triggers if any already exist
-   triggerCollection->StartIterateAllClassAds();
-   while(true == triggerCollection->IterateAllClassAds(ad, key))
-   {
-      key_value = atoll(key.value());
-      if (triggers.end() == triggers.find(key_value))
-      {
-         if (STATUS_OK != AddTriggerToCollection(key_value, ad, error_text))
-         {
-            dprintf(D_ALWAYS, "Triggerd Error: '%s'.  Removing trigger\n", error_text.c_str());
-            int_str << key_value;
-            triggerCollection->DestroyClassAd(int_str.str().c_str());
-         }
-      }
-   }
+   settings.host = std::string(host);
+   settings.port = port;
+   settings.username = std::string(username);
+   settings.password = std::string(password);
+   settings.mechanism = std::string(mechanism);
 
+   // Initialize the QMF agent
    singleton = new ManagementAgent::Singleton();
    ManagementAgent* agent = singleton->getInstance();
 
@@ -244,17 +235,9 @@ Triggerd::init()
    CondorTrigger::registerSelf(agent);
    EventCondorTriggerNotify::registerSelf(agent);
 
-   mgmtObject = new CondorTriggerService(agent, this);
-
-   settings.host = std::string(host);
-   settings.port = port;
-   settings.username = std::string(username);
-   settings.password = std::string(password);
-   settings.mechanism = std::string(mechanism);
-
-   // Initialize the QMF agent
    agent->setName("com.redhat.grid","condortriggerservice", daemonName.c_str());
    agent->init(settings, interval, true, storefile);
+   mgmtObject = new CondorTriggerService(agent, this);
 
    // Initialize the QMF console, if desired
    enable_console = param_boolean("ENABLE_ABSENT_NODES_DETECTION", false);
@@ -269,8 +252,24 @@ Triggerd::init()
    free(password);
    free(mechanism);
 
-   bool _lifetime = param_boolean("QMF_IS_PERSISTENT", true);
-   agent->addObject(mgmtObject, daemonName.c_str(), _lifetime);
+   // Initialize the triggers if any already exist
+   triggerCollection->StartIterateAllClassAds();
+   while(true == triggerCollection->IterateAllClassAds(ad, key))
+   {
+      key_value = atoll(key.value());
+      if (triggers.end() == triggers.find(key_value))
+      {
+         if (STATUS_OK != AddTriggerToCollection(key_value, ad, error_text))
+         {
+            dprintf(D_ALWAYS, "Triggerd Error: '%s'.  Removing trigger\n", error_text.c_str());
+            int_str << key_value;
+            triggerCollection->DestroyClassAd(int_str.str().c_str());
+         }
+      }
+   }
+
+   bool lifetime = param_boolean("QMF_IS_PERSISTENT", true);
+   agent->addObject(mgmtObject, daemonName.c_str(), lifetime);
 
    // Create a socket to handle management method calls
    sock = new ReliSock;
diff --git a/src/condor_contrib/triggerd/src/condor_trigger_config.py b/src/condor_contrib/triggerd/src/condor_trigger_config.py
index 6b09ab7..8ac5e93 100644
--- a/src/condor_contrib/triggerd/src/condor_trigger_config.py
+++ b/src/condor_contrib/triggerd/src/condor_trigger_config.py
@@ -320,6 +320,9 @@ class TriggerConfigOptionParser(OptionParser):
         self.add_option("-i", "--init", action="store_true", help="add default triggers")
         self.add_option("-l", "--list", action="store_true", help="list installed triggers")
         self.add_option("-s", "--test", action="store_true", help="test triggers")
+        self.add_option("-U", "--user", action="store", help="The username used to authenticate with the broker")
+        self.add_option("-P", "--password", action="store", help="The password used to authenticate with the broker")
+        self.add_option("-m", "--auth-mechanism", action="store", help="A comma separated list of authentication mechanisms to use when communicating with the broker.  Supported mechanisms are: ANONYMOUS, PLAIN, GSSAPI", default="ANONYMOUS,PLAIN,GSSAPI")
 
     def is_valid(self, opts, args):
         valid = False
@@ -352,8 +355,13 @@ def main():
     session = TriggerConfig(opts.test)
 
     print "Connecting to broker '%s'..." % target
+    if opts.user != None and opts.password != None:
+       target = "%s/%s@%s" % (opts.user, opts.password, target)
+    elif opts.user != None:
+       target = "%s@%s" % (opts.user, target)
+
     try:
-        broker = session.addBroker(target)
+        broker = session.addBroker(target, mechanisms = opts.auth_mechanism.replace(',', ' '))
     except Exception, e:
         print e
         sys.exit(1)
diff --git a/src/condor_daemon_core.V6/soap_core.cpp b/src/condor_daemon_core.V6/soap_core.cpp
index 0cf3a64..178dce7 100644
--- a/src/condor_daemon_core.V6/soap_core.cpp
+++ b/src/condor_daemon_core.V6/soap_core.cpp
@@ -518,6 +518,10 @@ int serve_file(struct soap *soap, const char *name, const char *type) {
     web_root_realpath = strdup(buf);
   }
   free(web_root_dir);
+
+  if (!web_root_realpath) {
+    return 404;
+  } 
   
   char * full_name = dircat(web_root_realpath,name);
   char * full_name_realpath = NULL;
diff --git a/src/condor_examples/condor.boot.rpm b/src/condor_examples/condor.boot.rpm
index c96d3b3..498e7da 100755
--- a/src/condor_examples/condor.boot.rpm
+++ b/src/condor_examples/condor.boot.rpm
@@ -500,7 +500,7 @@ find_masters() {
 }
 
 # To the best of its ability, finds the active condor_master's PID.
-# echos the result, or an empty string if none was found.
+# Store the result in global variable MASTER_PIDS.
 # You can call this repeatedly to check for updates.
 # If we use the pid file the first time through, always use it --
 #  if it disappears, means that the Condor went bye-bye
@@ -560,7 +560,7 @@ wait_for_exit() {
     condor_master_pids
   done
   
-  if [ "`condor_master_pids`" = "" ]; then
+  if [ "$MASTER_PIDS" = "" ]; then
     return 0
   else
     return 1
@@ -684,8 +684,8 @@ xstop() {
 # This can fail for any number of reasons, and we wouldn't
 # detect it.
 #
-# As a possible improvement, we might send SIGHUP if `condor_master_pids`
-# is non-empty, only falling back on condor_reconfig if it is.
+# As a possible improvement, we might send SIGHUP if condor_master_pids
+# finds nothing, only falling back on condor_reconfig if it is.
 #
 # Also, detect the return code from CONDOR_RECONFIG; non-zero
 # indicates aproblem. (At the moment that never happens, but
@@ -712,7 +712,8 @@ reload() {
 # 3 not running
 # 4 unknown
 status() {
-  master_pid=`condor_master_pids`
+  condor_master_pids
+  master_pid="$MASTER_PIDS"
   if [ "$master_pid" != "" ]; then
     echo "Condor is running (pid $master_pid)"
     return 0
@@ -768,7 +769,8 @@ case "$INIT_COMMAND" in
     ;;
 
   'try-restart')
-    if [ "`condor_master_pids`" = "" ]; then exit 0; fi # Not running
+    condor_master_pids
+    if [ "$MASTER_PIDS" = "" ]; then exit 0; fi # Not running
     xstop
     start
     ;;
diff --git a/src/condor_gridmanager/amazonjob.cpp b/src/condor_gridmanager/amazonjob.cpp
index 27a13b5..b55e601 100644
--- a/src/condor_gridmanager/amazonjob.cpp
+++ b/src/condor_gridmanager/amazonjob.cpp
@@ -154,6 +154,12 @@ dprintf( D_ALWAYS, "================================>  AmazonJob::AmazonJob 1 \n
 	numSubmitAttempts = 0;
 	myResource = NULL;
 	gahp = NULL;
+	m_public_key_file = NULL;
+	m_private_key_file = NULL;
+	m_user_data = NULL;
+	m_user_data_file = NULL;
+	m_group_names = NULL;
+	m_instance_type = NULL;
 	
 	// check the public_key_file
 	buff[0] = '\0';
@@ -183,8 +189,6 @@ dprintf( D_ALWAYS, "================================>  AmazonJob::AmazonJob 1 \n
 		// at the attribute in a better way.
 
 	memset(buff, 0, 16385);
-	m_user_data = NULL;
-	m_user_data_file = NULL;	
 	
 	// if user assigns both user_data and user_data_file, the two will
 	// be concatenated by the gahp
@@ -197,14 +201,13 @@ dprintf( D_ALWAYS, "================================>  AmazonJob::AmazonJob 1 \n
 	
 	// get VM instance type
 	memset(buff, 0, 16385);
-	m_instance_type = NULL; // if clients don't assign this value in condor submit file,
-							// we should set the default value to NULL and gahp_server
-							// will start VM in Amazon using m1.small mode.
+	// if clients don't assign this value in condor submit file,
+	// we should set the default value to NULL and gahp_server
+	// will start VM in Amazon using m1.small mode.
 	if ( jobAd->LookupString( ATTR_AMAZON_INSTANCE_TYPE, buff ) ) {
 		m_instance_type = strdup(buff);	
 	}
 	
-	m_group_names = NULL;
 	m_vm_check_times = 0;
 	m_keypair_check_times = 0;
 
diff --git a/src/condor_includes/condor_debug.h b/src/condor_includes/condor_debug.h
index 742ed59..48be699 100644
--- a/src/condor_includes/condor_debug.h
+++ b/src/condor_includes/condor_debug.h
@@ -76,6 +76,12 @@
 extern "C" {
 #endif
 
+#if _MSC_VER >= 1400 /* VC++ 2005 version */
+#define PREFAST_NORETURN __declspec(noreturn)
+#else
+#define PREFAST_NORETURN
+#endif
+
 extern int DebugFlags;	/* Bits to look for in dprintf */
 extern int Termlog;		/* Are we logging to a terminal? */
 extern int DebugShouldLockToAppend; /* Should we lock the file before each write? */
@@ -93,7 +99,7 @@ void dprintf ( int flags, const char *fmt, ... ) CHECK_PRINTF_FORMAT(2,3);
 void dprintf_config( const char *subsys );
 void _condor_dprintf_va ( int flags, const char* fmt, va_list args );
 int _condor_open_lock_file(const char *filename,int flags, mode_t perm);
-void _EXCEPT_ ( const char *fmt, ... ) CHECK_PRINTF_FORMAT(1,2);
+void PREFAST_NORETURN _EXCEPT_ ( const char *fmt, ... ) CHECK_PRINTF_FORMAT(1,2);
 void Suicide(void);
 void set_debug_flags( const char *strflags );
 void _condor_fd_panic( int line, const char *file );
@@ -156,7 +162,7 @@ extern int	_EXCEPT_Line;			/* Line number of the exception    */
 extern const char	*_EXCEPT_File;		/* File name of the exception      */
 extern int	_EXCEPT_Errno;			/* errno from most recent system call */
 extern int (*_EXCEPT_Cleanup)(int,int,const char*);	/* Function to call to clean up (or NULL) */
-extern void _EXCEPT_(const char*, ...) CHECK_PRINTF_FORMAT(1,2);
+extern PREFAST_NORETURN void _EXCEPT_(const char*, ...) CHECK_PRINTF_FORMAT(1,2);
 
 #if defined(__cplusplus)
 }
diff --git a/src/condor_includes/condor_sys_nt.h b/src/condor_includes/condor_sys_nt.h
index 676793b..92e69ed 100644
--- a/src/condor_includes/condor_sys_nt.h
+++ b/src/condor_includes/condor_sys_nt.h
@@ -241,6 +241,18 @@ END_C_DECLS
 
 #endif
 
+// defeat prefast warnings
+_Check_return_ inline int isspace(_In_ char ch) {
+   return isspace(static_cast<int> (static_cast<unsigned char> (ch)));
+}
+_Check_return_ inline int isalnum(_In_ char ch) {
+   return isalnum(static_cast<int> (static_cast<unsigned char> (ch)));
+}
+_Check_return_ inline int isdigit(_In_ char ch) {
+   return isdigit(static_cast<int> (static_cast<unsigned char> (ch)));
+}
+
+
 /* Define the PRIx64 macros */
 
 // If no inttypes, try to define our own
diff --git a/src/condor_includes/condor_system.h b/src/condor_includes/condor_system.h
index d08d6dd..6e39d66 100644
--- a/src/condor_includes/condor_system.h
+++ b/src/condor_includes/condor_system.h
@@ -1,6 +1,6 @@
 /***************************************************************
  *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * Copyright (C) 1990-2011, Condor Team, Computer Sciences Department,
  * University of Wisconsin-Madison, WI.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you
diff --git a/src/condor_includes/config.h.cmake b/src/condor_includes/config.h.cmake
index 28d802f..3969aff 100644
--- a/src/condor_includes/config.h.cmake
+++ b/src/condor_includes/config.h.cmake
@@ -25,14 +25,6 @@
 /// TODO: OS VARS, may be able to ax with some smart mods
 /// the definitions
 /// I may be able to do away with all of this.
-///* Define if on FreeBSD4 */
-//#cmakedefine CONDOR_FREEBSD4
-///* Define if on FreeBSD5 */
-//#cmakedefine CONDOR_FREEBSD5
-///* Define if on FreeBSD6 */
-//#cmakedefine CONDOR_FREEBSD6
-///* Define if on FreeBSD7 */
-//#cmakedefine CONDOR_FREEBSD7
 ///* Define if on OS X 10.3 */
 //#cmakedefine Darwin_10_3
 ///* Define if on OS X 10.4 */
@@ -44,6 +36,28 @@
 //////////////////////////////////////////////////
 
 //////////////////////////////////////////////////
+// Sadly, some of these are still in use
+/* Define if on FreeBSD 4 */
+#cmakedefine CONDOR_FREEBSD4
+/* Define if on FreeBSD 5 */
+#cmakedefine CONDOR_FREEBSD5
+/* Define if on FreeBSD 6 */
+#cmakedefine CONDOR_FREEBSD6
+/* Define if on FreeBSD 7 */
+#cmakedefine CONDOR_FREEBSD7
+///* Define if on FreeBSD 8 */
+#cmakedefine CONDOR_FREEBSD8
+///* Define if on FreeBSD */
+#cmakedefine CONDOR_FREEBSD
+///* Define release of FreeBSD (i.e. 7.4, 8.2) */
+#cmakedefine FREEBSD_RELEASE
+///* Define major release of FreeBSD */
+#cmakedefine FREEBSD_MAJOR
+///* Define minor release of FreeBSD */
+#cmakedefine FREEBSD_MINOR
+//////////////////////////////////////////////////
+
+//////////////////////////////////////////////////
 /// Options which may be changed if standard universe
 /// goes away
 ///* Define if we can do checkpointing */
diff --git a/src/condor_io/condor_crypt.cpp b/src/condor_io/condor_crypt.cpp
index e8f1d40..2de4883 100644
--- a/src/condor_io/condor_crypt.cpp
+++ b/src/condor_io/condor_crypt.cpp
@@ -75,6 +75,7 @@ unsigned char * Condor_Crypt_Base :: randomKey(int length)
     int size = 128;
     if( ! already_seeded ) {
         unsigned char * buf = (unsigned char *) malloc(size);
+        ASSERT(buf);
 		for (int i = 0; i < size; i++) {
 			buf[i] = get_random_int() & 0xFF;
 		}
@@ -118,6 +119,6 @@ unsigned char * Condor_Crypt_Base :: oneWayHashKey(const char * initialKey)
 #ifdef HAVE_EXT_OPENSSL
     return Condor_MD_MAC::computeOnce((unsigned char *)initialKey, strlen(initialKey));
 #else 
-    return 0;
+    return NULL;
 #endif
 }
diff --git a/src/condor_io/condor_secman.cpp b/src/condor_io/condor_secman.cpp
index 54579de..207fbba 100644
--- a/src/condor_io/condor_secman.cpp
+++ b/src/condor_io/condor_secman.cpp
@@ -2900,7 +2900,7 @@ SecMan::CreateNonNegotiatedSecuritySession(DCpermission auth_level, char const *
 	unsigned char* keybuf = Condor_Crypt_Base::oneWayHashKey(private_key);
 	if(!keybuf) {
 		dprintf(D_ALWAYS,"SECMAN: failed to create non-negotiated security session %s because"
-				"oneWayHashKey() failed.\n",sesid);
+				" oneWayHashKey() failed.\n",sesid);
 		return false;
 	}
 	KeyInfo *keyinfo = new KeyInfo(keybuf,keylen,crypt_protocol);
diff --git a/src/condor_io/shared_port_client.cpp b/src/condor_io/shared_port_client.cpp
index 05a46ff..b9f26c2 100644
--- a/src/condor_io/shared_port_client.cpp
+++ b/src/condor_io/shared_port_client.cpp
@@ -193,12 +193,12 @@ SharedPortClient::PassSocket(Sock *sock_to_pass,char const *shared_port_id,char
 		return false;
 	}
 
-	int bufferSize = sizeof(WSAPROTOCOL_INFO) + sizeof(int);
+	int bufferSize = sizeof(protocol_info) + sizeof(int);
 	char *buffer = new char[bufferSize];
 	ASSERT( buffer );
 	int cmd = SHARED_PORT_PASS_SOCK;
 	memcpy_s(buffer, sizeof(int), &cmd, sizeof(int));
-	memcpy_s(buffer+sizeof(int), sizeof(WSAPROTOCOL_INFO), &protocol_info, sizeof(WSAPROTOCOL_INFO));
+	memcpy_s(buffer+sizeof(int), sizeof(protocol_info), &protocol_info, sizeof(protocol_info));
 	BOOL write_result = WriteFile(child_pipe, buffer, bufferSize, &read_bytes, 0);
 
 	delete [] buffer;
diff --git a/src/condor_job_router/JobRouter.h b/src/condor_job_router/JobRouter.h
index 7de6951..243f44c 100644
--- a/src/condor_job_router/JobRouter.h
+++ b/src/condor_job_router/JobRouter.h
@@ -26,7 +26,6 @@
 #include "RoutedJob.h"
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 #if HAVE_JOB_HOOKS
diff --git a/src/condor_job_router/JobRouterHookMgr.h b/src/condor_job_router/JobRouterHookMgr.h
index 5084e81..e061d05 100644
--- a/src/condor_job_router/JobRouterHookMgr.h
+++ b/src/condor_job_router/JobRouterHookMgr.h
@@ -26,7 +26,6 @@
 #include "RoutedJob.h"
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 
diff --git a/src/condor_job_router/NewClassAdJobLogConsumer.cpp b/src/condor_job_router/NewClassAdJobLogConsumer.cpp
index 9ee3728..3d2fe1c 100644
--- a/src/condor_job_router/NewClassAdJobLogConsumer.cpp
+++ b/src/condor_job_router/NewClassAdJobLogConsumer.cpp
@@ -27,7 +27,6 @@
 #include <string>
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 NewClassAdJobLogConsumer::NewClassAdJobLogConsumer() : m_reader(0) { }
diff --git a/src/condor_job_router/NewClassAdJobLogConsumer.h b/src/condor_job_router/NewClassAdJobLogConsumer.h
index 8b0c142..d4d6d12 100644
--- a/src/condor_job_router/NewClassAdJobLogConsumer.h
+++ b/src/condor_job_router/NewClassAdJobLogConsumer.h
@@ -27,7 +27,6 @@
 #include <string>
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 class NewClassAdJobLogConsumer: public ClassAdLogConsumer
diff --git a/src/condor_job_router/RoutedJob.h b/src/condor_job_router/RoutedJob.h
index 6cb2432..7d27709 100644
--- a/src/condor_job_router/RoutedJob.h
+++ b/src/condor_job_router/RoutedJob.h
@@ -23,7 +23,6 @@
 //#include "condor_common.h"
 
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 class JobRoute;
diff --git a/src/condor_job_router/VanillaToGrid.cpp b/src/condor_job_router/VanillaToGrid.cpp
index 429c478..fd4e8bd 100644
--- a/src/condor_job_router/VanillaToGrid.cpp
+++ b/src/condor_job_router/VanillaToGrid.cpp
@@ -29,7 +29,6 @@
 #include "filename_tools.h"
 #include "string_list.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 
diff --git a/src/condor_job_router/VanillaToGrid_main.cpp b/src/condor_job_router/VanillaToGrid_main.cpp
index 39f812e..56d6762 100644
--- a/src/condor_job_router/VanillaToGrid_main.cpp
+++ b/src/condor_job_router/VanillaToGrid_main.cpp
@@ -26,7 +26,6 @@
 #include "condor_attributes.h"
 #include "basename.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 #include <libgen.h>
diff --git a/src/condor_job_router/set_user_from_ad.cpp b/src/condor_job_router/set_user_from_ad.cpp
index c44f966..f332ce0 100644
--- a/src/condor_job_router/set_user_from_ad.cpp
+++ b/src/condor_job_router/set_user_from_ad.cpp
@@ -27,7 +27,6 @@
 #include "classad_newold.h"
 #include "condor_uid.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 void set_user_from_ad(classad::ClassAd const &ad)
diff --git a/src/condor_job_router/submit_job.cpp b/src/condor_job_router/submit_job.cpp
index 6aa544c..cd82c69 100644
--- a/src/condor_job_router/submit_job.cpp
+++ b/src/condor_job_router/submit_job.cpp
@@ -34,7 +34,6 @@
 #include "format_time.h"
 #include "set_user_priv_from_ad.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 #include "set_user_from_ad.h"
 #include "file_transfer.h"
diff --git a/src/condor_negotiator.V6/matchmaker.cpp b/src/condor_negotiator.V6/matchmaker.cpp
index e4d3a89..cf49d73 100644
--- a/src/condor_negotiator.V6/matchmaker.cpp
+++ b/src/condor_negotiator.V6/matchmaker.cpp
@@ -1272,7 +1272,7 @@ negotiationTime ()
 
                     negotiateWithGroup(untrimmed_num_startds, untrimmedSlotWeightTotal, minSlotWeight,
                                        startdAds, claimIds, *(group->submitterAds), 
-                                       slots, group->usage, group->name.c_str());
+                                       slots, group->name.c_str());
                 }
 
                 // Halt when we have negotiated with full deltas
@@ -1967,7 +1967,7 @@ negotiateWithGroup ( int untrimmed_num_startds,
 					 ClassAdListDoesNotDeleteAds& startdAds,
 					 ClaimIdHash& claimIds, 
 					 ClassAdListDoesNotDeleteAds& scheddAds, 
-					 float groupQuota, float groupusage,const char* groupAccountingName)
+					 float groupQuota, const char* groupName)
 {
     time_t start_time_phase3 = time(NULL);
 	ClassAd		*schedd;
@@ -2006,6 +2006,18 @@ negotiateWithGroup ( int untrimmed_num_startds,
 	do {
 		spin_pie++;
 
+        // On the first spin of the pie we tell the negotiate function to ignore the
+        // submitterLimit w/ respect to jobs which are strictly preferred by resource 
+        // offers (via startd rank).  However, if preemption is not being considered, 
+        // we respect submitter limits on all iterations.
+        const bool ignore_submitter_limit = ((spin_pie == 1) && ConsiderPreemption);
+
+        double groupusage = (NULL != groupName) ? accountant.GetWeightedResourcesUsed(groupName) : 0.0;
+        if (!ignore_submitter_limit && (NULL != groupName) && (groupusage >= groupQuota)) {
+            // If we've met the group quota, and if we are paying attention to submitter limits, halt now
+            dprintf(D_ALWAYS, "Group %s is using its quota %g - halting negotiation\n", groupName, groupQuota);
+            break;
+        }
 			// invalidate the MatchList cache, because even if it is valid
 			// for the next user+auto_cluster being considered, we might
 			// have thrown out matches due to SlotWeight being too high
@@ -2028,7 +2040,7 @@ negotiateWithGroup ( int untrimmed_num_startds,
 
 		calculatePieLeft(
 			scheddAds,
-			groupAccountingName,
+			groupName,
 			groupQuota,
 			groupusage,
 			maxPrioValue,
@@ -2056,6 +2068,11 @@ negotiateWithGroup ( int untrimmed_num_startds,
         // "schedd" seems to be used interchangeably with "submitter" here
 		while( (schedd = scheddAds.Next()) )
 		{
+            if (!ignore_submitter_limit && (NULL != groupName) && (accountant.GetWeightedResourcesUsed(groupName) >= groupQuota)) {
+                // If we met group quota, and if we're respecting submitter limits, halt.
+                // (output message at top of outer loop above)
+                break;
+            }
 			// get the name of the submitter and address of the schedd-daemon it came from
 			if( !schedd->LookupString( ATTR_NAME, scheddName ) ||
 				!schedd->LookupString( ATTR_SCHEDD_IP_ADDR, scheddAddr ) )
@@ -2100,7 +2117,7 @@ negotiateWithGroup ( int untrimmed_num_startds,
 
 			calculateSubmitterLimit(
 				scheddName.Value(),
-				groupAccountingName,
+				groupName,
 				groupQuota,
 				groupusage,
 				maxPrioValue,
@@ -2184,11 +2201,6 @@ negotiateWithGroup ( int untrimmed_num_startds,
 				if ( (submitterLimit <= 0 || pieLeft < minSlotWeight) && spin_pie > 1 ) {
 					result = MM_RESUME;
 				} else {
-					if ( spin_pie == 1 && ConsiderPreemption ) {
-						ignore_schedd_limit = true;
-					} else {
-						ignore_schedd_limit = false;
-					}
 					int numMatched = 0;
 					startTime = time(NULL);
 					double limitUsed = 0.0;
@@ -2247,7 +2259,6 @@ negotiateWithGroup ( int untrimmed_num_startds,
 		scheddAds.Close();
 		dprintf( D_FULLDEBUG, " resources used scheddUsed= %f\n",scheddUsed);
 
-		groupusage = scheddUsed;
 	} while ( ( pieLeft < pieLeftOrig || scheddAds.MyLength() < scheddAdsCountOrig )
 			  && (scheddAds.MyLength() > 0)
 			  && (startdAds.MyLength() > 0) );
@@ -2570,6 +2581,25 @@ obtainAdsFromCollector (
 				// CRUFT: Before 7.3.2, submitter ads had a MyType of
 				//   "Scheduler". The only way to tell the difference
 				//   was that submitter ads didn't have ATTR_NUM_USERS.
+
+            MyString subname;
+            if (!ad->LookupString(ATTR_NAME, subname)) {
+                dprintf(D_ALWAYS, "WARNING: ignoring submitter ad with no name\n");
+                continue;
+            }
+
+            int numidle=0;
+            ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+            int numrunning=0;
+            ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+            int requested = numrunning + numidle;
+
+            // This will avoid some wasted effort in negotiation looping
+            if (requested <= 0) {
+                dprintf(D_FULLDEBUG, "Ignoring submitter %s with no requested jobs\n", subname.Value());
+                continue;
+            }
+
     		ad->Assign(ATTR_TOTAL_TIME_IN_CYCLE, 0);
 			scheddAds.Insert(ad);
 		}
diff --git a/src/condor_negotiator.V6/matchmaker.h b/src/condor_negotiator.V6/matchmaker.h
index e0d647b..2b01ff5 100644
--- a/src/condor_negotiator.V6/matchmaker.h
+++ b/src/condor_negotiator.V6/matchmaker.h
@@ -175,7 +175,7 @@ class Matchmaker : public Service
 								 double minSlotWeight,
 			ClassAdListDoesNotDeleteAds& startdAds, 
 			ClaimIdHash& claimIds, ClassAdListDoesNotDeleteAds& scheddAds, 
-			float groupQuota=INT_MAX, float groupusage=0, const char* groupAccountingName=NULL);
+			float groupQuota=INT_MAX, const char* groupName=NULL);
 
 		
 		ClassAd *matchmakingAlgorithm(const char*,const char*,ClassAd&,ClassAdListDoesNotDeleteAds&,
diff --git a/src/condor_procapi/procapi.cpp b/src/condor_procapi/procapi.cpp
index fcb28fa..bee8e36 100644
--- a/src/condor_procapi/procapi.cpp
+++ b/src/condor_procapi/procapi.cpp
@@ -492,12 +492,6 @@ ProcAPI::getProcInfoRaw( pid_t pid, procInfoRaw& procRaw, int &status )
 		// assume success
 	status = PROCAPI_OK;
 
-		// clear the memory of procRaw
-	initProcInfoRaw(procRaw);
-
-		// set the sample time
-	procRaw.sample_time = secsSinceEpoch();
-
 	// read the entry a certain number of times since it appears that linux
 	// often simply does something stupid while reading.
 	sprintf( path, "/proc/%d/stat", pid );
@@ -508,7 +502,10 @@ ProcAPI::getProcInfoRaw( pid_t pid, procInfoRaw& procRaw, int &status )
 
 		// in case I must restart, assume that everything is ok again...
 		status = PROCAPI_OK;
+		// clear the memory of procRaw
 		initProcInfoRaw(procRaw);
+		// set the sample time
+		procRaw.sample_time = secsSinceEpoch();
 
 		if( (fp = safe_fopen_wrapper(path, "r")) == NULL ) {
 			if( errno == ENOENT ) {
diff --git a/src/condor_rmdir/bprint.h b/src/condor_rmdir/bprint.h
index b7ae97d8..2bb4535 100644
--- a/src/condor_rmdir/bprint.h
+++ b/src/condor_rmdir/bprint.h
@@ -253,10 +253,10 @@ void bprint_Initialize(BPRINT_BUFFER & bp)
    if (bp.cchMax <= 0)
       bp.cchMax = 0x0FFFF;
    if ( ! bp.psz)
-      bp.psz = (LPTSTR) GlobalAllocPtr(GPTR, (bp.cchMax+1) * NUMBYTES(bp.psz[0]));
+      bp.psz = (LPTSTR) malloc((bp.cchMax+1) * NUMBYTES(bp.psz[0]));
   #ifdef UNICODE
    if ( ! bp.pszAscii)
-      bp.pszAscii = (LPSTR) GlobalAllocPtr(GPTR, (bp.cchMax+1) * 2);
+      bp.pszAscii = (LPSTR) malloc((bp.cchMax+1) * 2);
   #endif
    bp.cch = 0;
    bp.CodePage = CP_ACP;
@@ -466,9 +466,9 @@ void bprint_Terminate(BPRINT_BUFFER & bp, bool fFlush)
    if (fFlush)
       bprint_EndLine(bp);
    if (bp.psz)
-      GlobalFreePtr(bp.psz);
+      free(bp.psz);
    if (bp.pszAscii)
-      GlobalFreePtr(bp.pszAscii);
+      free(bp.pszAscii);
    if (bp.hOut && (bp.hOut != GetStdHandle(STD_OUTPUT_HANDLE)))
       CloseHandle(bp.hOut);
    ZeroStruct(&bp);
diff --git a/src/condor_rmdir/harylist.h b/src/condor_rmdir/harylist.h
index d31f71e..f62b326 100644
--- a/src/condor_rmdir/harylist.h
+++ b/src/condor_rmdir/harylist.h
@@ -118,13 +118,13 @@ HRESULT FNEXPORT HaryList_InsertList (
 INLINE LPVOID HaryList_AllocItem(HARYLIST hlst, LONG cbItem) {
 	DASSERT(PCARYLIST_PTR(hlst)->cbItem == sizeof(void*));
 	DASSERT(PCARYLIST_PTR(hlst)->fdwOptions & ARYLIST_OPT_F_GPTRS);
-	return (LPVOID)GlobalAllocPtr(GPTR, cbItem);
+	return (LPVOID)malloc(cbItem);
 }
 
 INLINE void HaryList_FreeItem(HARYLIST hlst, LPVOID pvItem) {
 	DASSERT(PCARYLIST_PTR(hlst)->cbItem == sizeof(void*));
 	DASSERT(PCARYLIST_PTR(hlst)->fdwOptions & ARYLIST_OPT_F_GPTRS);
-	GlobalFreePtr(pvItem);
+	free(pvItem);
 }
 
 INLINE HRESULT HaryList_InsertItemCopy(HARYLIST hlst, LONG ix, LPCVOID pvItem) {
@@ -384,7 +384,7 @@ HRESULT FNEXPORT HaryList_Create (
 	else
 	{
 		*phlst = NULL;
-		plst = (PARYLIST)GlobalAllocPtr(GPTR, sizeof(*plst));
+		plst = (PARYLIST)malloc(sizeof(*plst));
 	}
 	if ( ! plst)
 		return E_OUTOFMEMORY;
@@ -407,7 +407,7 @@ HRESULT FNEXPORT HaryList_Create (
 	plst->cGrowBy    = cGrowBy;
 
     LONG cb = cAllocate * cbItem;
-    plst->pvList = (void**)GlobalAllocPtr(GPTR, cb);
+    plst->pvList = (void**)malloc(cb);
 
 	if (fdwOptions & ARYLIST_OPT_F_EMBEDDED)
 	{
@@ -417,7 +417,7 @@ HRESULT FNEXPORT HaryList_Create (
     DASSERT(plst->pvList);
     if ( ! plst->pvList)
     {
-        GlobalFreePtr(plst);
+        free(plst);
         return E_OUTOFMEMORY;
     }
 
@@ -445,12 +445,12 @@ HRESULT FNEXPORT HaryList_Destroy (HARYLIST hlst)
 				LPVOID pv = ppv[plst->cItems-1];
 				ppv[plst->cItems-1] = NULL;
 				if (pv)
-					GlobalFreePtr(pv);
+					free(pv);
 				--plst->cItems;
 			}
 		}
 
-        GlobalFreePtr(plst->pvList);
+        free(plst->pvList);
         plst->pvList = NULL;
     }
 
@@ -461,7 +461,7 @@ HRESULT FNEXPORT HaryList_Destroy (HARYLIST hlst)
     }
 
 	if ( ! (plst->fdwOptions & ARYLIST_OPT_F_EMBEDDED))
-		GlobalFreePtr(plst);
+		free(plst);
     return S_OK;
 }
 
@@ -485,12 +485,7 @@ HRESULT HaryList_GrowAllocated (
 
     LONG cbNewAlloc = (plst->cAllocated + cDelta) * plst->cbItem;
 
-    // 
-    // GlobalReAllocPtr can fail, will fail so we have to allocate
-    // a whole new buffer and copy the new data to it.
-    //pvNew = (LPVOID)GlobalReAllocPtr(plst->pvList, cb, GMEM_ZEROINIT);
-
-    void** pvNew = (void**)GlobalAllocPtr(GPTR, cbNewAlloc);
+    void** pvNew = (void**)malloc(cbNewAlloc);
     if ( ! pvNew)
     {
         hr = E_OUTOFMEMORY;
@@ -498,7 +493,7 @@ HRESULT HaryList_GrowAllocated (
     }
 
     RtlCopyMemory(pvNew, plst->pvList, plst->cAllocated * plst->cbItem);
-    GlobalFreePtr(plst->pvList);
+    free(plst->pvList);
 
     plst->pvList = pvNew;
     plst->cAllocated += cDelta;
diff --git a/src/condor_rmdir/main.cpp b/src/condor_rmdir/main.cpp
index 19395a2..fc6c89a 100644
--- a/src/condor_rmdir/main.cpp
+++ b/src/condor_rmdir/main.cpp
@@ -745,7 +745,8 @@ HRESULT App_ExecuteCommandLine (
          {
          hr = App_ExecuteArgList (aArgs, ixFirst, cArgs - ixFirst);
          }
-      GlobalFreePtr (aArgs);
+
+      HeapFree(GetProcessHeap(), 0, aArgs);
       }
 
    return hr;
@@ -761,6 +762,12 @@ const TCHAR * _pszModulePath; // global path name
 void App_SetModuleInfo(void)
 {
    TCHAR * pszBase =(TCHAR*)malloc(sizeof(TCHAR) * (MAX_PATH+3));
+   if ( ! pszBase)
+      {
+	  _pszModulePath = _pszModuleName = TEXT("");
+	  return;
+      }
+
    TCHAR * psz = pszBase;
    *psz++ = 0; // so we have room for a "" path if the module filename has no path
    int cch = GetModuleFileName(NULL, psz, MAX_PATH+1);
@@ -798,13 +805,13 @@ void App_SetModuleInfo(void)
       _pszModulePath = pszBase;
    else
       {
-      if (_pszModuleName-1 > _pszModulePath)
+      if (_pszModuleName-2 >= _pszModulePath)
          {
          // we need to be careful not to delete \ folling a drive letter,
          // if that happens, we have to move the name by 1 character
          // so there is room for a null terminator after N:\ and before
          // the name.
-         if (_pszModuleName[-1] == ':' &&
+         if (_pszModuleName[-2] == ':' &&
              _pszModuleName[-1] == '\\')
             {
             RtlMoveMemory((void*)(_pszModuleName+1), (void*)(_pszModuleName),
diff --git a/src/condor_schedd.V6/qmgmt.cpp b/src/condor_schedd.V6/qmgmt.cpp
index c3fbafd..2aad71c 100644
--- a/src/condor_schedd.V6/qmgmt.cpp
+++ b/src/condor_schedd.V6/qmgmt.cpp
@@ -2862,6 +2862,7 @@ CommitTransaction(SetAttributeFlags_t flags /* = 0 */)
 					rewriteSpooledJobAd(procad, cluster_id, proc_id, false);
 					JobQueue->CommitNondurableTransaction();
 					ScheduleJobQueueLogFlush();
+					SpooledJobFiles::createJobSpoolDirectory(procad,PRIV_UNKNOWN);
 				}
 
 				std::string version;
@@ -2871,7 +2872,6 @@ CommitTransaction(SetAttributeFlags_t flags /* = 0 */)
 					// they are responsible for writing the submit event
 					// to the user log.
 					if ( vers.built_since_version( 7, 5, 4 ) ) {
-						SpooledJobFiles::createJobSpoolDirectory(procad,PRIV_UNKNOWN);
 						PROC_ID job_id;
 						job_id.cluster = cluster_id;
 						job_id.proc = proc_id;
@@ -2947,9 +2947,13 @@ GetAttributeFloat(int cluster_id, int proc_id, const char *attr_name, float *val
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		sscanf(attr_val, "%f", val);
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupFloat(attr_name, *val) == 1) {
+			return 0;
+		}
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
@@ -2971,9 +2975,13 @@ GetAttributeInt(int cluster_id, int proc_id, const char *attr_name, int *val)
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		sscanf(attr_val, "%d", val);
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupInteger(attr_name, *val) == 1) {
+			return 0;
+		}
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
@@ -2995,9 +3003,13 @@ GetAttributeBool(int cluster_id, int proc_id, const char *attr_name, int *val)
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		sscanf(attr_val, "%d", val);
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupBool(attr_name, *val) == 1) {
+			return 0;
+		}
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
@@ -3025,15 +3037,13 @@ GetAttributeStringNew( int cluster_id, int proc_id, const char *attr_name,
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		int attr_len = strlen( attr_val );
-		if ( attr_val[0] != '"' || attr_val[attr_len-1] != '"' ) {
-			free( attr_val );
-			return -1;
-		}
-		attr_val[attr_len - 1] = '\0';
-		*val = strdup(&attr_val[1]);
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupString(attr_name, val) == 1) {
+			return 0;
+		}
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
@@ -3060,16 +3070,14 @@ GetAttributeString( int cluster_id, int proc_id, const char *attr_name,
 	IdToStr(cluster_id,proc_id,key);
 
 	if( JobQueue->LookupInTransaction(key, attr_name, attr_val) ) {
-		int attr_len = strlen( attr_val );
-		if ( attr_val[0] != '"' || attr_val[attr_len-1] != '"' ) {
-			free( attr_val );
-			val = "";
-			return -1;
-		}
-		attr_val[attr_len - 1] = '\0';
-		val = attr_val + 1;
+		ClassAd tmp_ad;
+		tmp_ad.AssignExpr(attr_name,attr_val);
 		free( attr_val );
-		return 1;
+		if( tmp_ad.LookupString(attr_name, val) == 1) {
+			return 0;
+		}
+		val = "";
+		return -1;
 	}
 
 	if (!JobQueue->LookupClassAd(key, ad)) {
diff --git a/src/condor_scripts/Condor.pm b/src/condor_scripts/Condor.pm
index 26b0ca8..473ee44 100755
--- a/src/condor_scripts/Condor.pm
+++ b/src/condor_scripts/Condor.pm
@@ -703,7 +703,7 @@ sub Monitor
 	# if this line is for another cluster, ignore
 	if ( $line =~ /^\d+\s+\(0*(\d+)\./ && $1 != $cluster )
 	{
-	    debug( "log line for cluster $1, not $cluster -- ignoring...\n" ,6);
+	    debug( "log line for cluster $1, not $cluster -- ignoring...\n" ,1);
 	    next LINE;
 	}
 	
@@ -713,7 +713,7 @@ sub Monitor
 	    $info{'cluster'} = $1;
 	    $info{'job'} = $2;
 
-	    debug( "Saw job evicted\n" ,5);
+	    debug( "Saw job ($1.$2) evicted\n" ,1);
 
 	    # execute callback if one is registered
 	    &$EvictedCallback( %info )
@@ -738,7 +738,7 @@ sub Monitor
 
 	    if( $line =~ /^\s+\(0\) Job was not checkpointed\./ )
 	    {
-		debug( "job was evicted without ckpt\n" ,5);
+		debug( "job was evicted without ckpt\n" ,1);
 		# execute callback if one is registered
 		&$EvictedWithoutCheckpointCallback( %info )
 		    if defined $EvictedWithoutCheckpointCallback;
@@ -746,14 +746,14 @@ sub Monitor
 	    }
 	    elsif( $line =~ /^\s+\(1\) Job was checkpointed\./ )
 	    {
-		debug( "job was evicted with ckpt\n" ,5);
+		debug( "job was evicted with ckpt\n" ,1);
 		# execute callback if one is registered
 		&$EvictedWithCheckpointCallback( %info )
 		    if defined $EvictedWithCheckpointCallback;
 	    }
 	    elsif( $line =~ /^\s+\(0\) Job terminated and was requeued.*$/ )
 	    {
-		debug( "job was evicted and requeued\n" ,5);
+		debug( "job was evicted and requeued\n" ,1);
 		# execute callback if one is registered
 		&$EvictedWithRequeueCallback( %info )
 		    if defined $EvictedWithRequeueCallback;
@@ -762,7 +762,7 @@ sub Monitor
 	    {
 		debug( "parse error on line $linenum of $info{'log'}:\n" .
 		       "   no checkpoint message found after eviction: " .
-		       "continuing...\n" ,5);
+		       "continuing...\n" ,1);
 		# re-parse line so we don't miss whatever it said
 		goto PARSE;
 	    }
@@ -775,7 +775,7 @@ sub Monitor
 	    $info{'cluster'} = $1;
 	    $info{'job'} = $2;
 
-	    debug( "Saw job terminated\n" ,5);
+	    debug( "Saw job terminated\n" ,1);
 
 	    # decrement # of queued jobs so we will know when to exit monitor
 	    $num_active_jobs--;
@@ -817,11 +817,11 @@ sub Monitor
 	    # abnormal termination
 	    elsif( $line =~ /^\s+\(0\) Abnormal termination \(signal (\d+)\)/ )
 	    {
-		debug( "Loading $1 as info{'signal'}\n" ,5);
+		debug( "Loading $1 as info{'signal'}\n" ,1);
 		$info{'signal'} = $1;
 		#print "keys:".join(" ",keys %info)."\n";
 
-		debug( "checking for core file...\n" ,5);
+		debug( "checking for core file...\n" ,1);
 
 		# read next line to find core file
 		$line = <SUBMIT_LOG>;
@@ -860,7 +860,7 @@ sub Monitor
 	    {
 		debug( "parse error on line $linenum of $info{'log'}:\n" .
 		       "   no termination status message found after " .
-		       "termination: continuing...\n" ,5);
+		       "termination: continuing...\n" ,1);
 		# re-parse line so we don't miss whatever it said
 		goto PARSE;
 	    }
@@ -873,7 +873,7 @@ sub Monitor
 	    $info{'cluster'} = $1;
 	    $info{'job'} = $2;
 
-	    debug( "Saw Shadow Exception\n" ,5);
+	    debug( "Saw Shadow Exception\n" ,1);
 
 		if(! defined $ShadowCallback)
 		{
@@ -916,7 +916,7 @@ sub Monitor
 	    $info{'host'} = $3;
 	    $info{'sinful'} = "<$3>";
 	    
-	    debug( "Saw job executing\n" ,5);
+	    debug( "Saw job executing\n" ,1);
 
 	    # execute callback if one is registered
 	    &$ExecuteCallback( %info )
@@ -934,7 +934,7 @@ sub Monitor
 	    $info{'host'} = $3;
 	    $info{'sinful'} = "<$3>";
 
-	    debug( "Saw job submitted\n" ,5);
+	    debug( "Saw job submitted\n" ,1);
 	    $submit_info{'cluster'} = $1; # squirrel it away for TimedWait
 
 	    # mark that we've seen a submit so we can start watching # of jobs
@@ -955,7 +955,7 @@ sub Monitor
 	    $info{'cluster'} = $1;
 	    $info{'job'} = $2;
 
-	    debug( "Saw job abort cluster $1 job $2\n" ,5);
+	    debug( "Saw job abort cluster $1 job $2\n" ,1);
 
 	    # decrement # of queued jobs so we will know when to exit monitor
 	    $num_active_jobs--;
@@ -989,7 +989,7 @@ sub Monitor
 
 		$info{'holdreason'} = $line;
 
-	    debug( "Saw job held\n" ,5);
+	    debug( "Saw job held\n" ,1);
 
 	    
 	    # execute callback if one is registered
@@ -1005,7 +1005,7 @@ sub Monitor
 	    #$info{'host'} = $3;
 	    #$info{'sinful'} = "<$3:$4>";
 	    
-	    debug( "Saw job released\n" ,5);
+	    debug( "Saw job released\n" ,1);
 
 	    
 	    # execute callback if one is registered
diff --git a/src/condor_scripts/CondorUtils.pm b/src/condor_scripts/CondorUtils.pm
index bdd74f4..a332152 100644
--- a/src/condor_scripts/CondorUtils.pm
+++ b/src/condor_scripts/CondorUtils.pm
@@ -257,7 +257,7 @@ sub runcmd {
 		}
 		$sz = $#errlines;
 		if($sz != -1) {
-			PrintStdOut(\@errlines);
+			PrintStdErr(\@errlines);
 		}
 		PrintFooter();
 	}
diff --git a/src/condor_shadow.V6.1/baseshadow.cpp b/src/condor_shadow.V6.1/baseshadow.cpp
index 5c3ab37..93e720d 100644
--- a/src/condor_shadow.V6.1/baseshadow.cpp
+++ b/src/condor_shadow.V6.1/baseshadow.cpp
@@ -73,6 +73,7 @@ BaseShadow::BaseShadow() {
 	m_lazy_queue_update = true;
 	m_cleanup_retry_tid = -1;
 	m_cleanup_retry_delay = 30;
+	m_RunAsNobody = false;
 }
 
 BaseShadow::~BaseShadow() {
@@ -163,9 +164,30 @@ BaseShadow::baseInit( ClassAd *job_ad, const char* schedd_addr, const char *xfer
 	// handle system calls with Owner's privilege
 // XXX this belong here?  We'll see...
 	if ( !init_user_ids(owner.Value(), domain.Value())) {
-		dprintf(D_ALWAYS, "init_user_ids() failed!\n");
+		dprintf(D_ALWAYS, "init_user_ids() failed as user %s\n",owner.Value() );
 		// uids.C will EXCEPT when we set_user_priv() now
 		// so there's not much we can do at this point
+		
+#if ! defined(WIN32)
+		if ( param_boolean( "SHADOW_RUN_UNKNOWN_USER_JOBS", false ) )
+		{
+			dprintf(D_ALWAYS, "trying init_user_ids() as user nobody\n" );
+			
+			owner="nobody";
+			domain=NULL;
+			if (!init_user_ids(owner.Value(), domain.Value()))
+			{
+				dprintf(D_ALWAYS, "init_user_ids() failed!\n");
+			}
+			else
+			{
+				jobAd->Assign( ATTR_JOB_RUNAS_OWNER, "FALSE" );
+				m_RunAsNobody=true;
+				dprintf(D_ALWAYS, "init_user_ids() now running as user nobody\n");
+			}
+		}
+#endif
+
 	}
 	set_user_priv();
 	daemonCore->Register_Priv_State( PRIV_USER );
@@ -287,6 +309,15 @@ void BaseShadow::config()
 
 
 int BaseShadow::cdToIwd() {
+	int iRet =0;
+	
+#if ! defined(WIN32)
+	priv_state p;
+	
+	if (m_RunAsNobody)
+		p = set_root_priv();
+#endif
+	
 	if (chdir(iwd.Value()) < 0) {
 		int chdir_errno = errno;
 		dprintf(D_ALWAYS, "\n\nPath does not exist.\n"
@@ -297,9 +328,15 @@ int BaseShadow::cdToIwd() {
 		                    iwd.Value(), strerror(chdir_errno));
 		dprintf( D_ALWAYS, "%s\n",hold_reason.Value());
 		holdJob(hold_reason.Value(),CONDOR_HOLD_CODE_IwdError,chdir_errno);
-		return -1;
+		iRet = -1;
 	}
-	return 0;
+	
+#if ! defined(WIN32)
+	if ( m_RunAsNobody )
+		set_priv(p);
+#endif
+	
+	return iRet;
 }
 
 
@@ -773,7 +810,21 @@ void BaseShadow::initUserLog()
 
 	if ( getPathToUserLog(jobAd, logfilename) ) {
 		result = uLog.initialize (owner.Value(), domain.Value(), logfilename.Value(), cluster, proc, 0, gjid);
+		// It is important to NOT ignore a failure to initialize the user log,
+		// since if we fail to initialize here, then all event logging 
+		// in the shadow from this point forward are effectively ignored.
+		// So if we fail to initialize the user log, put this job on hold.
+		// Future work: it would be good to pass use the error stack to 
+		// figure out -why- the initialization failed, allowing the shadow
+		// to retry automatically -vs- go on hold depending upon the details
+		// of the failure.
 		if ( result == false ) {
+			MyString hold_reason;
+			hold_reason.sprintf(
+				"Failed to initialize user log to %s", logfilename.Value());
+			dprintf( D_ALWAYS, "%s\n",hold_reason.Value());
+			holdJob(hold_reason.Value(),CONDOR_HOLD_CODE_UnableToInitUserLog,0);
+			// holdJob() should not return, but just in case it does EXCEPT
 			EXCEPT("Failed to initialize user log to %s",logfilename.Value());
 		}
 		if (jobAd->LookupBool(ATTR_ULOG_USE_XML, use_xml)
diff --git a/src/condor_shadow.V6.1/baseshadow.h b/src/condor_shadow.V6.1/baseshadow.h
index f4053e9..3b5d769 100644
--- a/src/condor_shadow.V6.1/baseshadow.h
+++ b/src/condor_shadow.V6.1/baseshadow.h
@@ -428,6 +428,7 @@ class BaseShadow : public Service
 	char *uidDomain;
 	int reconnect_ceiling;
 	double reconnect_e_factor;
+	bool m_RunAsNobody;
 
 	// job parameters
 	int cluster;
diff --git a/src/condor_startd.V6/ResState.cpp b/src/condor_startd.V6/ResState.cpp
index f303099..54934d9 100644
--- a/src/condor_startd.V6/ResState.cpp
+++ b/src/condor_startd.V6/ResState.cpp
@@ -412,6 +412,25 @@ ResState::eval( void )
 		break;	
 
 	case owner_state:
+			// If the dynamic slot is allocated in the owner state
+			// (e.g. because of START expression contains attributes
+			// of job ClassAd), it may never go back to Unclaimed 
+			// state. So we need to delete the dynmaic slot in owner
+			// state.
+		if( Resource::DYNAMIC_SLOT == rip->get_feature() ) {
+#if HAVE_JOB_HOOKS
+				// If we're currently fetching we can't delete
+				// ourselves. If we do when the hook returns we won't
+				// be around to handle the response.
+			if( rip->isCurrentlyFetching() ) {
+				dprintf(D_ALWAYS, "State change: Owner -> Deleted delayed for outstanding work fetch\n");
+				break;
+			}
+#endif
+			change( delete_state );
+			return TRUE; // XXX: change TRUE
+		}
+
 		if( ! rip->eval_is_owner() ) {
 			dprintf( D_ALWAYS, "State change: IS_OWNER is false\n" );
 			change( unclaimed_state );
diff --git a/src/condor_starter.V6.1/CondorJavaInfo.class b/src/condor_starter.V6.1/CondorJavaInfo.class
index 2f28c3b..893d89c 100644
Binary files a/src/condor_starter.V6.1/CondorJavaInfo.class and b/src/condor_starter.V6.1/CondorJavaInfo.class differ
diff --git a/src/condor_starter.V6.1/CondorJavaInfo.java b/src/condor_starter.V6.1/CondorJavaInfo.java
index 73153e2..71d6f94 100644
--- a/src/condor_starter.V6.1/CondorJavaInfo.java
+++ b/src/condor_starter.V6.1/CondorJavaInfo.java
@@ -98,7 +98,7 @@ public class CondorJavaInfo {
 			// deal with escaped double quotes very well. This might be
 			// revisited in the future.
 			System.out.print( UnDotString(name) + " = \"" + 
-				value.replace('"', '\'') + "\"");
+				value.replace('"', '\'').replace('\n',' ').replace('\r', ' ') + "\"");
 
 			if( newmode ) {
 				System.out.println(";");
diff --git a/src/condor_starter.V6.1/jic_shadow.cpp b/src/condor_starter.V6.1/jic_shadow.cpp
index b17cd6c..04a3cb4 100644
--- a/src/condor_starter.V6.1/jic_shadow.cpp
+++ b/src/condor_starter.V6.1/jic_shadow.cpp
@@ -377,8 +377,10 @@ bool JICShadow::allJobsDone( void )
 
 	r1 = JobInfoCommunicator::allJobsDone();
 
-	publishJobExitAd( &update_ad );
-	r2 = updateShadow( &update_ad, true );
+	if (!m_did_transfer) {
+		publishJobExitAd( &update_ad );
+		r2 = updateShadow( &update_ad, true );
+	}
 
 	return r1;
 }
diff --git a/src/condor_sysapi/CMakeLists.txt b/src/condor_sysapi/CMakeLists.txt
index 2f2fbcf..3690c59 100644
--- a/src/condor_sysapi/CMakeLists.txt
+++ b/src/condor_sysapi/CMakeLists.txt
@@ -16,6 +16,7 @@
  # 
  ############################################################### 
 
+set(BENCH_LINK_LIBS "${TOOL_LINK_LIBS}")
 
 file( GLOB SysApiRmvElements *_t.cpp *.t.* dhry21b* *_main.cpp )
 
@@ -26,5 +27,5 @@ condor_static_lib(sysapi "${SysapiHeaderFiles};${SysapiSourceFiles}")
 
 # there was a test target which was never used.
 # it makes the most sense to hook in a UT here instead of integ test
-condor_exe(condor_kflops "kflops_main.cpp" "${C_LIBEXEC}" "sysapi;condorapi;${TOOL_LINK_LIBS}" OFF)
-condor_exe(condor_mips "mips_main.cpp" "${C_LIBEXEC}" "sysapi;condorapi;${TOOL_LINK_LIBS}" OFF)
+condor_exe(condor_kflops "kflops_main.cpp" ${C_LIBEXEC} "sysapi;condorapi;${BENCH_LINK_LIBS}" OFF)
+condor_exe(condor_mips "mips_main.cpp" ${C_LIBEXEC} "sysapi;condorapi;${BENCH_LINK_LIBS}" OFF)
diff --git a/src/condor_syscall_lib/CMakeLists.txt b/src/condor_syscall_lib/CMakeLists.txt
index 2f96684..7208da6 100644
--- a/src/condor_syscall_lib/CMakeLists.txt
+++ b/src/condor_syscall_lib/CMakeLists.txt
@@ -104,6 +104,20 @@ if( STD_UNIVERSE )
 	# now create the glorious syscall lib from various refs.
 	# behold the birth of frankenstein.
 	condor_static_lib( condorsyscall "senders.cpp;switches.cpp;${SyscallHdrs};${SyscallSrcs};${STDU_OBJS};${CKPT_REFS};${UTIL_REFS};${IO_REFS};${STDIO_REF}")
+	if (DOES_COMPRESS_CKPT)
+		# For condorzsyscall, pull in all the same objects as
+		# condorsyscall except use ZCKPT_REFS in place of
+		# CKPT_REFS
+		src_target_ref( zckpt "^.*$" ZCKPT_REFS)
+
+		# We need to compile condor-malloc.c with special preprocessor
+		# definitions.
+		src_target_ref( zckpt "malloc-condor.c" MALLOC_CONDOR_REF)
+		set_property(SOURCE ${MALLOC_CONDOR_REF} APPEND PROPERTY COMPILE_DEFINITIONS "MORECORE=condor_morecore;HAVE_MMAP=0;malloc_getpagesize=8192")
+
+		condor_static_lib( condorzsyscall "senders.cpp;switches.cpp;${SyscallHdrs};${SyscallSrcs};${STDU_OBJS};${ZCKPT_REFS};${UTIL_REFS};${IO_REFS};${STDIO_REF}")
+	endif()
+
 	# local library which the daemons can link without glibc tainting.
 	condor_static_lib( std_local_ref "senders.cpp;receivers.cpp;${CKPT_LOCAL_REFS};${SYSCALL_LOCAL_REFS}" )
 
@@ -111,7 +125,10 @@ if( STD_UNIVERSE )
 	# part 2:
 	# set dependencies to ensure build dep order for parallel builds
 	##################################################
-	add_dependencies( condorsyscall ckpt utils cedar stdunivio stub_gen )
+	add_dependencies( condorsyscall stub_gen )
+	if (DOES_COMPRESS_CKPT)
+		add_dependencies( condorzsyscall stub_gen )
+	endif()
 	add_dependencies( switches syscall_numbers stub_gen )
 	add_dependencies( senders syscall_numbers stub_gen )
 	add_dependencies( receivers syscall_numbers stub_gen )
@@ -120,6 +137,9 @@ if( STD_UNIVERSE )
 	#################################################
 	# here we begin the install target section
 	install ( TARGETS condorsyscall DESTINATION ${C_LIB} )
+	if (DOES_COMPRESS_CKPT)
+		install ( TARGETS condorzsyscall DESTINATION ${C_LIB} )
+	endif()
 	install ( FILES ${CMAKE_CURRENT_BINARY_DIR}/condor_rt0.o DESTINATION ${C_LIB} )
 	install ( FILES ${LIBGCC} DESTINATION ${C_LIB} RENAME libcomp_libgcc.a )
 	install ( FILES ${LIBGCC_EH} DESTINATION ${C_LIB} RENAME libcomp_libgcc_eh.a )
diff --git a/src/condor_tests/CMakeLists.txt b/src/condor_tests/CMakeLists.txt
index 32e0264..2c746a0 100644
--- a/src/condor_tests/CMakeLists.txt
+++ b/src/condor_tests/CMakeLists.txt
@@ -105,6 +105,7 @@ if (BUILD_TESTS)
 		condor_std_exe_test(job_ckpt_io-async_std "${CMAKE_C_COMPILER}" "job_ckpt_io-async_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_io-buffer-async_std "${CMAKE_C_COMPILER}" "job_ckpt_io-buffer-async_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_stack_std "${CMAKE_C_COMPILER}" "job_ckpt_stack_std.c" "${STDU_LDD_FLAGS}")
+		condor_std_exe_test(job_ckpt_standalone_std "${CMAKE_C_COMPILER}" "job_ckpt_standalone_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_floats_std "${CMAKE_C_COMPILER}" "job_ckpt_floats_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_floats-async_std "${CMAKE_C_COMPILER}" "job_ckpt_floats-async_std.c" "${STDU_LDD_FLAGS}")
 		condor_std_exe_test(job_ckpt_integers_std "${CMAKE_C_COMPILER}" "job_ckpt_integers_std.c" "${STDU_LDD_FLAGS}")
@@ -206,6 +207,7 @@ if (BUILD_TESTS)
 		condor_pl_test(job_ckpt_io-async_std "file I/O during async ckpt signals" "stduniv;quick;full;ckpt")
 		condor_pl_test(job_ckpt_io-buffer-async_std "file buffing during async ckpt/restore" "stduniv;quick;full;ckpt")
 		condor_pl_test(job_ckpt_stack_std "ckpt/restore function call stack" "stduniv;framework;quick;full;ckpt")
+		condor_pl_test(job_ckpt_standalone_std "standalone ckpt/restore function call stack" "stduniv;framework;quick;full;ckpt")
 		condor_pl_test(job_ckpt_floats_std "ckpt/restore floating point registers" "stduniv;framework;quick;full;ckpt")
 		condor_pl_test(job_ckpt_floats-async_std "checks floating point ops with async ckpts" "stduniv;framework;quick;full;ckpt")
 		condor_pl_test(job_ckpt_integers_std "ckpt/restore integer registers" "stduniv;framework;quick;full;ckpt")
@@ -318,12 +320,16 @@ if (BUILD_TESTS)
 	#condor_pl_test(job_stork_file-file "Basic stork Test" "core;quick;full;quicknolink")
 	#condor_pl_test(job_dagman_stork_file-file "Basic stork dag Test" "core;dagman;quick;full;quicknolink")
 	#condor_pl_test(job_dagman_stork-remove "Basic stork dag w/remove Test" "core;dagman;quick;full;quicknolink")
-	condor_pl_test(job_core_err_java "Java Universe: basic error test" "core;quick;full;quicknolink;java")
-	condor_pl_test(job_core_output_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
-	condor_pl_test(job_core_hold_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
-	condor_pl_test(job_core_initialdir_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
-	condor_pl_test(job_core_input_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
-	#condor_pl_test(job_core_plus_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+
+    if ( ENABLE_JAVA_TESTS )
+		condor_pl_test(job_core_err_java "Java Universe: basic error test" "core;quick;full;quicknolink;java")
+		condor_pl_test(job_core_output_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+		condor_pl_test(job_core_hold_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+		condor_pl_test(job_core_initialdir_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+		condor_pl_test(job_core_input_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+		#condor_pl_test(job_core_plus_java "Java Universe: basic output test" "core;quick;full;quicknolink;java")
+    endif ( ENABLE_JAVA_TESTS )
+
 	condor_pl_test(job_filexfer_streamout_van "Vanilla: test for streaming of output when both stream_output is true and false" "core;quick;full;quicknolink")
 	condor_pl_test(job_filexfer_streamerr_van "Vanilla: test for streaming of error when both stream_error is true and false" "core;quick;full;quicknolink")
 	#if !defined( IS_ALPHA_LINUX) && !defined(IS_HPUX10) && !defined(IS_HPUX11) && !defined(IS_IA64_LINUX_RHEL3) 
diff --git a/src/condor_tests/job_ckpt_standalone_std.c b/src/condor_tests/job_ckpt_standalone_std.c
new file mode 100644
index 0000000..4c6a834
--- /dev/null
+++ b/src/condor_tests/job_ckpt_standalone_std.c
@@ -0,0 +1,252 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* This program was originally the job_ckpt_stack_std.c test program.
+	It was repurposed and extended to test standalone checkpointing.
+*/
+
+/* This program analyzes the stack at run time to see if it is ok(i.e.
+	checkpointed and restored at the right boundaries). It does
+	this by calling a recursive function which allocates some
+	memory on the stack, fills it with a known value, checks to see
+	if the previous values were all correct, and then recurses to
+	do the process over again. It continues until it accumulates a
+	target size of the runtime stack(counting only the memory it
+	allocates on the stack). During these calls, it checkpoints and
+	restarts all the way checking the integrity of the run time
+	stack. In fact, when the recursion finishes, it back checks the
+	runtime stack for each frame it falls backwards. */
+
+/* XXX Right now this program only checkpoints at the deepest level and
+	then backchecks all the way. It should checkpoint more often to make
+	sure everything is being saved/restored correctly, but it eats up
+	far too much time to do it ever stack level. I need to fix it so it 
+	does it evey N stack pushes/pops. */
+
+/* This might need adjustment per OS revision */
+#define STACKSIZETARGET (1024*384) /* 384K run time stack */
+
+#define STACKINCREMENT 1024 /* bytes per allocated stack array */
+#define FALSE 0
+#define TRUE 1
+
+#include "x_fake_ckpt.h"
+
+/* This represents an activation record on the run time stack. In fact, this
+	is kept on the runtime stack along with the data it points to to really
+	make this test depend on a working stack. */
+struct Frame
+{
+	/* This represents the number stored in the array */
+	int value;
+	/* This points to a stack allocated array */
+	int *data;
+	/* This size of the stack allocates array */
+	int size;
+	/* This is null at the root of the activation records */
+	struct Frame *previous;
+};
+
+void init_data(int *data, int size, int value);
+int deepen(struct Frame *pf, int old_value);
+int is_stack_valid(struct Frame *f, int value);
+int data_valid(int *data, int size, int value);
+
+/* size of the runtime stack at various intervals */
+int g_sum = 0;
+
+/* pointer to heap allocated just before checkpoint */
+int *g_heap1 = NULL;
+/* pointer to heap allocated just after checkpoint */
+int *g_heap2 = NULL;
+int g_heap_size = (1024 * 1024 * 1); /* actually 4 Megs cause an int type */
+
+int main(void)
+{
+	/* Need to start this process as close to the start of main() as I can */
+	int data[STACKINCREMENT];
+	struct Frame f;
+	int validity;
+	int a, b, c;
+
+	init_data(data, STACKINCREMENT, 0);
+	/* the stopping condition for is_stack_valid()'s search through the
+		previous pointers. It stops when f.value is zero and the data
+		array associated with it is zero. Otherwise during the recursion value
+		increases by one for each deeper stack frame */
+	f.value = 0; 
+	f.data = &data[0];
+	f.size = STACKINCREMENT;
+	f.previous = NULL;
+	g_sum += STACKINCREMENT; /* record the fact I added to the stack */
+
+	a = is_stack_valid(&f, 0);
+	printf("Deepness Level: %d\n", 0);
+	b = deepen(&f, 0);
+	printf("Backchecking %d\n", 0), 
+	c = is_stack_valid(&f, 0);
+	validity = a && b && c;
+	if (validity == FALSE) {
+		printf("Stack failure.\n");
+		printf("FAILED\n");
+		exit(EXIT_FAILURE);
+	}
+
+	printf("Checking allocated memory heaps.\n");
+	if (data_valid(g_heap1, g_heap_size, 0xdeadbeef) == FALSE) {
+		printf("Memory heap 1 failure.\n");
+		printf("FAILED\n");
+		exit(EXIT_FAILURE);
+	}
+	if (data_valid(g_heap2, g_heap_size, 0xbeefdead) == FALSE) {
+		printf("Memory heap 2 failure.\n");
+		printf("FAILED\n");
+		exit(EXIT_FAILURE);
+	}
+
+	free(g_heap1);
+	g_heap1 = NULL;
+	free(g_heap2);
+	g_heap2 = NULL;
+
+	printf("SUCCESS\n");
+	exit(EXIT_SUCCESS);
+}
+
+/* fill the data array with a known value */
+void init_data(int *data, int size, int value)
+{
+	int i;
+	
+	for (i = 0; i < size; i++)
+	{
+		data[i] = value;
+	}
+}
+
+/* keep recursing down until I use up the amount of run time stack space I've
+	been allocated */
+int deepen(struct Frame *pf, int old_value)
+{
+	int test;
+	int data[STACKINCREMENT];
+	struct Frame f;
+	int new_value = old_value + 1;
+	int a, b;
+
+	printf("Deepness Level: %d\n", new_value);
+	init_data(data, STACKINCREMENT, new_value);
+	f.value = new_value;
+	f.data = &data[0];
+	f.size = STACKINCREMENT;
+	f.previous = pf;
+	g_sum += STACKINCREMENT; /* record the fact I added to the stack */
+
+	test = is_stack_valid(&f, new_value);
+
+	if (test == TRUE)
+	{
+		if (g_sum < STACKSIZETARGET)
+		{
+			/* recurse deeper and backcheck the results */
+				a = deepen(&f, new_value);
+				printf("Backchecking %d\n", new_value), 
+				b = is_stack_valid(&f, new_value);
+
+				return a && b;
+		}
+
+		/* allocate a chunk of memory that better be good when I come back from
+			the checkpoint */
+		g_heap1 = malloc(sizeof(int) * g_heap_size);
+		if (g_heap1 == NULL) {
+			printf("Out of memory while allocating heap1! Exiting.\n");
+			exit(EXIT_FAILURE);
+		}
+		init_data(g_heap1, g_heap_size, 0xdeadbeef);
+
+		/* save the big run time stack in a checkpoint */
+		printf("About to checkpoint....\n");
+		fflush(NULL);
+		ckpt_and_exit();
+		fflush(NULL);
+
+		printf("Returning from checkpoint....\n");
+
+		/* This *should* be true because we just checked it earlier, however
+			if it is not, we'll catch the error here. */
+		test = is_stack_valid(&f, new_value);
+
+		/* allocate another chunk of memory that better be good when I come
+			back from the checkpoint */
+		g_heap2 = malloc(sizeof(int) * g_heap_size);
+		if (g_heap2 == NULL) {
+			printf("Out of memory while allocating heap2! Exiting.\n");
+			exit(EXIT_FAILURE);
+		}
+		init_data(g_heap2, g_heap_size, 0xbeefdead);
+
+		return test;
+	}
+
+	return FALSE;
+}
+
+/* check to see of the stack frame and all previous ones are correct given
+	a decrementing value for each previous stack frame */
+int is_stack_valid(struct Frame *f, int value)
+{
+	int check;
+
+	check = data_valid(f->data, f->size, value);
+
+	if (value == 0)
+	{
+		if (check == TRUE)
+		{
+			return TRUE;
+		}
+		return FALSE;
+	}
+
+	/* check until the value is zero */
+	return is_stack_valid(f->previous, value - 1);
+}
+
+
+/* Check the data with a known value */
+int data_valid(int *data, int size, int value)
+{
+	int i;
+	
+	for (i = 0; i < size; i++)
+	{
+		if (data[i] != value)
+		{
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+
diff --git a/src/condor_tests/job_ckpt_standalone_std.run b/src/condor_tests/job_ckpt_standalone_std.run
new file mode 100755
index 0000000..94fad66
--- /dev/null
+++ b/src/condor_tests/job_ckpt_standalone_std.run
@@ -0,0 +1,131 @@
+#!/usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+# This program runs a standalone checkpointing job and ensures that it
+# both checkpointed and resumed correctly.
+
+use CondorUtils;
+use strict;
+use warnings;
+
+my $testdesc =  'Standalone Checkpointing Stack Test';
+my $testname = "job_ckpt_standalone_std.cndr.exe";
+my $ckptfile = "job_ckpt_standalone_std.cndr.exe.ckpt.$$";
+my $ret;
+my $last;
+
+# I need to do a little work to figure out the right arguments to pass to
+# setarch.
+my $pers = `uname -m`;
+my $pers_fix;
+my $pers_token;
+
+# We need to have the right base personality to run the stduniv program
+if ($pers =~ m/i\d86/) {
+	$pers_token = "i386";
+} else {
+	$pers_token = "x86_64";
+}
+
+# Now, we need to see if we're using a setarch that accepts the pile of
+# arguments we need, or an old crusty one which doesn't take any arguments.
+# This is a heuristic. We'll assume the most modern interface first.
+$pers_fix = "setarch $pers_token -L -B -R";
+
+# Sadly setarch just fails with no output and return value 1 when it can't
+# accept command line arguments it doesn't understand. So we test it with
+# something we KNOW to return true and if this fails, setarch is borken.
+$ret = system("$pers_fix /bin/true");
+
+if ($ret == -1 || $ret & 127) {
+	print "ERROR: Something went very wrong trying to figure out setarch.\n";
+	exit 1;
+}
+if (($ret >> 8) != 0) {
+	# use old style setarch instead
+	$pers_fix = "setarch $pers_token";
+}
+
+# Now that we're done with setarch detection, get to the test itself.
+
+print "Description: $testdesc\n";
+print "Running: $testname\n";
+
+# run the test, which will self checkpoint itself.
+
+# The program better exit with SIGUSR2!
+print "Starting standalone checkpointing test. Will checkpoint to $ckptfile.\n";
+$ret = runcmd("$pers_fix ./$testname -_condor_aggravate_bugs -_condor_D_CKPT " .
+			"-_condor_D_FULLDEBUG -_condor_D_ALWAYS " .
+			"-_condor_ckpt ./$ckptfile",
+		{expect_result => SIGNAL(12)});
+
+# Check the stderr, which contains the checkpoint debug output.
+$last = pop @{$ret->{'stderr'}};
+chomp $last;
+if ($last !~ m/Ckpt exit/) {
+	print "ERROR: The last line of the checkpointing job's stderr should " .
+		"have been 'Ckpt exit', but it wasn't! Fail.\n";
+	print "FAILURE\n";
+	exit 1;
+}
+
+# Check the stdout, which contains "About to checkpoint...."
+$last = pop @{$ret->{'stdout'}};
+chomp $last;
+if ($last !~ m/About to checkpoint\.\.\.\./) {
+	print "ERROR: The last line of the checkpointing job's stdout should " .
+		"have been 'About to checkpoint....', but it wasn't! Fail.\n";
+	print "FAILURE\n";
+	exit 1;
+}
+
+# The resuming program better exit with 0!
+print "Resuming standalone checkpointing test. Will resume from $ckptfile.\n";
+$ret = runcmd("$pers_fix ./$testname -_condor_aggravate_bugs -_condor_D_CKPT " .
+			"-_condor_D_FULLDEBUG -_condor_D_ALWAYS " .
+			"-_condor_restart ./$ckptfile");
+
+# Check the stderr, which contains the resumed job debug output.
+$last = pop @{$ret->{'stderr'}};
+chomp $last;
+if ($last !~ m/About to return to user code/) {
+	print "ERROR: The last line of the resuming job's stderr should have " .
+		"been 'About to return to user code', but it wasn't! Fail.\n";
+	print "FAILURE\n";
+	exit 1;
+}
+
+# Process the stdout which contains the output of the resumed job.
+$last = pop @{$ret->{'stdout'}};
+chomp $last;
+if ($last !~ m/SUCCESS/) {
+	print "ERROR: The last line of the resuming job should have " .
+		"been 'SUCCESS', but it wasn't!. Fail.\n";
+	print "FAILURE\n";
+	exit 1;
+}
+
+print "SUCCESS\n";
+
+exit 0;
+
+
+
diff --git a/src/condor_tools/config_val.cpp b/src/condor_tools/config_val.cpp
index 92ee0ee..09b84ee 100644
--- a/src/condor_tools/config_val.cpp
+++ b/src/condor_tools/config_val.cpp
@@ -398,6 +398,12 @@ main( int argc, char* argv[] )
 				while (collectors->next (collector)) {
 					if (collector->locate() &&
 					    sock.connect((char*) collector->addr(), 0)) {
+						// Do something with the connection, 
+						// such that we won't end up with 
+						// noise in the collector log
+						collector->startCommand( DC_NOP, &sock, 30 );
+						sock.encode();
+						sock.end_of_message();
 						// If we can connect to the
 						// collector, then we accept
 						// it as valid
diff --git a/src/condor_unit_tests/OTEST_Directory.cpp b/src/condor_unit_tests/OTEST_Directory.cpp
index eaab0ad..3843bad 100644
--- a/src/condor_unit_tests/OTEST_Directory.cpp
+++ b/src/condor_unit_tests/OTEST_Directory.cpp
@@ -167,8 +167,6 @@ static MyString
 static const char
 	*readme = "README";
 
-static time_t current_time;
-
 bool OTEST_Directory(void) {
 	emit_object("Directory");
 	emit_comment("Class to iterate filenames in a subdirectory.  Given a "
@@ -417,10 +415,6 @@ static void setup() {
 
 	// Close FILE* that was written to
 	cut_assert_z( fclose(file_1) );
-	
-	// Get the current time
-	current_time = time(NULL);
-
 }
 
 static void cleanup() {
@@ -1082,10 +1076,10 @@ static bool test_get_access_time_before() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	Directory dir(original_dir.Value());
-	time_t ret_val = dir.GetAccessTime();
+	time_t atime = dir.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", atime);
+	if(atime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1101,10 +1095,10 @@ static bool test_get_access_time_empty() {
 	emit_retval("%d", 0);
 	Directory dir(empty_dir.Value());
 	dir.Next();
-	time_t ret_val = dir.GetAccessTime();
+	time_t atime = dir.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", atime);
+	if(atime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1118,28 +1112,33 @@ static bool test_get_access_time_valid() {
 	Directory dir(original_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetAccessTime();
+	time_t atime = dir.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val == 0) {
+	emit_retval("%d", atime);
+	if(atime == 0) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_close() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a file that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a "
+		"file that was just created.");
 	emit_input_header();
 	emit_param("Directory", "%s", tmp_dir.Value());
 	Directory dir(tmp_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetAccessTime();
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, next);
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
+	time_t atime = dir.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - ret_val) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
@@ -1153,10 +1152,10 @@ static bool test_get_modify_time_before() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	Directory dir(original_dir.Value());
-	time_t ret_val = dir.GetModifyTime();
+	time_t mtime = dir.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", mtime);
+	if(mtime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1172,10 +1171,10 @@ static bool test_get_modify_time_empty() {
 	emit_retval("%d", 0);
 	Directory dir(empty_dir.Value());
 	dir.Next();
-	time_t ret_val = dir.GetModifyTime();
+	time_t mtime = dir.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", mtime);
+	if(mtime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1189,10 +1188,10 @@ static bool test_get_modify_time_valid() {
 	Directory dir(original_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetModifyTime();
+	time_t mtime = dir.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val == 0) {
+	emit_retval("%d", mtime);
+	if(mtime == 0) {
 		FAIL;
 	}
 	PASS;
@@ -1206,11 +1205,16 @@ static bool test_get_modify_time_close() {
 	Directory dir(tmp_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetModifyTime();
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, next);
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
+	time_t mtime = dir.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - ret_val) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
@@ -1224,10 +1228,10 @@ static bool test_get_create_time_before() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	Directory dir(original_dir.Value());
-	time_t ret_val = dir.GetCreateTime();
+	time_t ctime = dir.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", ctime);
+	if(ctime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1243,10 +1247,10 @@ static bool test_get_create_time_empty() {
 	emit_retval("%d", 0);
 	Directory dir(empty_dir.Value());
 	dir.Next();
-	time_t ret_val = dir.GetCreateTime();
+	time_t ctime = dir.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val != 0) {
+	emit_retval("%d", ctime);
+	if(ctime != 0) {
 		FAIL;
 	}
 	PASS;
@@ -1260,10 +1264,10 @@ static bool test_get_create_time_valid() {
 	Directory dir(original_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetCreateTime();
+	time_t ctime = dir.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	if(ret_val == 0) {
+	emit_retval("%d", ctime);
+	if(ctime == 0) {
 		FAIL;
 	}
 	PASS;
@@ -1277,11 +1281,16 @@ static bool test_get_create_time_close() {
 	Directory dir(tmp_dir.Value());
 	const char* next = dir.Next();
 	emit_param("Current File", "%s", next);
-	time_t ret_val = dir.GetCreateTime();
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, next);
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
+	time_t ctime = dir.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", ret_val);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - ret_val) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
diff --git a/src/condor_unit_tests/OTEST_StatInfo.cpp b/src/condor_unit_tests/OTEST_StatInfo.cpp
index 7f62e3a..5052829 100644
--- a/src/condor_unit_tests/OTEST_StatInfo.cpp
+++ b/src/condor_unit_tests/OTEST_StatInfo.cpp
@@ -133,8 +133,6 @@ static MyString
 static const char
 	*readme = "README";
 
-static time_t current_time;
-
 static int fd;
 
 bool OTEST_StatInfo(void) {
@@ -254,18 +252,18 @@ bool OTEST_StatInfo(void) {
 static void setup() {
 	int tmp_fd;
 
-	//Get the current working directory
+	// Get the current working directory
 	cut_assert_true( condor_getcwd(original_dir) );
 	original_dir += DIR_DELIM_CHAR;
 	
-	//Directory strings
+	// Directory strings
 	cut_assert_true( tmp.sprintf("testtmp%d", getpid()) );
 	
-	//Make a temporary directory to test
+	// Make a temporary directory to test
 	cut_assert_z( mkdir(tmp.Value(), 0700) );
 	cut_assert_z( chdir(tmp.Value()) );
 	
-	//Store some directories
+	// Store some directories
 	cut_assert_true( condor_getcwd(tmp_dir) );
 	tmp_dir += DIR_DELIM_CHAR;
 	cut_assert_true( empty_dir.sprintf("%s%s%c", tmp_dir.Value(), "empty_dir",
@@ -277,11 +275,11 @@ static void setup() {
 	cut_assert_true( file_dir.sprintf("%s%s%c", full_dir.Value(), "full_file",
 					 DIR_DELIM_CHAR) );
 	
-	//Put some files/directories in there
+	// Put some files/directories in there
 	cut_assert_z( mkdir("empty_dir", 0700) );
 	cut_assert_z( mkdir("full_dir", 0700) );
 	
-	//Create some symbolic links
+	// Create some symbolic links
 #ifndef WIN32
 	MyString link;
 	cut_assert_true( link.sprintf("%s%s", full_dir.Value(), "full_file") );
@@ -301,24 +299,21 @@ static void setup() {
 	cut_assert_z( mkdir("link_dir", 0700) );
 	fd = cut_assert_gez( safe_open_wrapper("empty_file", O_RDWR | O_CREAT) );
 
-	//Add some text
+	// Add some text
 	FILE* file_1 = safe_fopen_wrapper("full_file", "w+");
 	cut_assert_not_null( file_1 );
 	cut_assert_gz( fprintf(file_1, "This is some text!") );
 	cut_assert_z( chdir("..") );
 	
-	//Get back to original directory
+	// Get back to original directory
 	cut_assert_z( chdir("..") );
 
-	//Close FILE* that were written to
+	// Close FILE* that were written to
 	cut_assert_z( fclose(file_1) );
-	
-	//Get the current time
-	current_time = time(NULL);
 }
 
 static void cleanup() {
-	//Remove the created files/directories/symlinks
+	// Remove the created files/directories/symlinks
 	cut_assert_z( chdir(tmp.Value()) );
 	cut_assert_z( rmdir("empty_dir") );
 	cut_assert_z( remove("symlink_file") );
@@ -326,7 +321,7 @@ static void cleanup() {
 	cut_assert_z( chdir("full_dir") );
 	cut_assert_z( rmdir("link_dir") );
 	
-	//Just in case any of these weren't removed...
+	// Just in case any of these weren't removed...
 	remove("empty_file");
 	remove("full_file");
 	remove("executable_file");
@@ -863,27 +858,32 @@ static bool test_get_access_time_not_exist() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	StatInfo info("DoesNotExist", "DoesNotExist");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != 0) {
+	emit_retval("%d", atime);
+	if(atime != 0) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_file() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a file that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a "
+		"file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", full_dir.Value());
 	emit_param("File Name", "empty_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", full_dir.Value(), DIR_DELIM_CHAR, "empty_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
 	StatInfo info(full_dir.Value(), "empty_file");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
@@ -902,61 +902,76 @@ static bool test_get_access_time_file_old() {
 	emit_output_expected_header();
 	emit_retval("%d", st.st_atime);
 	StatInfo info(original_dir.Value(), readme);
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != st.st_atime) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_dir() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a directory that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a"
+		" directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "full_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "full_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
 	StatInfo info(tmp_dir.Value(), "full_dir");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_symlink_file() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a symlink to a file that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a "
+		"symlink to a file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
 	StatInfo info(tmp_dir.Value(), "symlink_file");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_access_time_symlink_dir() {
-	emit_test("Test that GetAccessTime() returns a time close to the current "
-		"time for a symlink to a directory that was just created.");
+	emit_test("Test that GetAccessTime() returns the same time as stat() for a "
+		"symlink to a directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_atime);
 	StatInfo info(tmp_dir.Value(), "symlink_dir");
-	time_t time = info.GetAccessTime();
+	time_t atime = info.GetAccessTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", atime);
+	if(atime != st.st_atime) {
 		FAIL;
 	}
 	PASS;
@@ -971,27 +986,32 @@ static bool test_get_modify_time_not_exist() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	StatInfo info("DoesNotExist", "DoesNotExist");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != 0) {
+	emit_retval("%d", mtime);
+	if(mtime != 0) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_modify_time_file() {
-	emit_test("Test that GetModifyTime() returns a time close to the current "
-		"time for a file that was just created.");
+	emit_test("Test that GetModifyTime() returns the same time as stat() for a "
+		"file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", full_dir.Value());
 	emit_param("File Name", "empty_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", full_dir.Value(), DIR_DELIM_CHAR, "empty_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
 	StatInfo info(full_dir.Value(), "empty_file");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
@@ -1010,61 +1030,76 @@ static bool test_get_modify_time_file_old() {
 	emit_output_expected_header();
 	emit_retval("%d", st.st_mtime);
 	StatInfo info(original_dir.Value(), readme);
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != st.st_mtime) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_modify_time_dir() {
-	emit_test("Test that GetModifyTime() returns a time close to the current "
-		"time for a directory that was just created.");
+	emit_test("Test that GetModifyTime() returns the same time as stat() for a "
+		"directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "full_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "full_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
 	StatInfo info(tmp_dir.Value(), "full_dir");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_modify_time_symlink_file() {
-	emit_test("Test that GetModifyTime() returns a time close to the current "
-		"time for a symlink to a file that was just created.");
+	emit_test("Test that GetModifyTime() returns the same time as stat() for a "
+		"symlink to a file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
 	StatInfo info(tmp_dir.Value(), "symlink_file");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_modify_time_symlink_dir() {
-	emit_test("Test that GetModifyTime() returns a time close to the current "
-		"time for a symlink to a directory that was just created.");
+	emit_test("Test that GetModifyTime() returns the same time as stat() for a "
+		"symlink to a directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_mtime);
 	StatInfo info(tmp_dir.Value(), "symlink_dir");
-	time_t time = info.GetModifyTime();
+	time_t mtime = info.GetModifyTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", mtime);
+	if(mtime != st.st_mtime) {
 		FAIL;
 	}
 	PASS;
@@ -1079,27 +1114,32 @@ static bool test_get_create_time_not_exist() {
 	emit_output_expected_header();
 	emit_retval("%d", 0);
 	StatInfo info("DoesNotExist", "DoesNotExist");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != 0) {
+	emit_retval("%d", ctime);
+	if(ctime != 0) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_create_time_file() {
-	emit_test("Test that GetCreateTime() returns a time close to the current "
-		"time for a file that was just created.");
+	emit_test("Test that GetCreateTime() returns the same time as stat() for a "
+		"file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", full_dir.Value());
 	emit_param("File Name", "empty_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", full_dir.Value(), DIR_DELIM_CHAR, "empty_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
 	StatInfo info(full_dir.Value(), "empty_file");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
@@ -1118,61 +1158,76 @@ static bool test_get_create_time_file_old() {
 	emit_output_expected_header();
 	emit_retval("%d", st.st_ctime);
 	StatInfo info(original_dir.Value(), readme);
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	if(time != st.st_ctime) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_create_time_dir() {
-	emit_test("Test that GetCreateTime() returns a time close to the current "
-		"time for a directory that was just created.");
+	emit_test("Test that GetCreateTime() returns the same time as stat() for a "
+		"directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "full_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "full_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
 	StatInfo info(tmp_dir.Value(), "full_dir");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_create_time_symlink_file() {
-	emit_test("Test that GetCreateTime() returns a time close to the current "
-		"time for a symlink to a file that was just created.");
+	emit_test("Test that GetCreateTime() returns the same time as stat() for a "
+		"symlink to a file that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_file");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_file");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
 	StatInfo info(tmp_dir.Value(), "symlink_file");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
 }
 
 static bool test_get_create_time_symlink_dir() {
-	emit_test("Test that GetCreateTime() returns a time close to the current "
-		"time for a symlink to a directory that was just created.");
+	emit_test("Test that GetCreateTime() returns the same time as stat() for a "
+		"symlink to a directory that was just created.");
 	emit_input_header();
 	emit_param("Directory Path", "%s", tmp_dir.Value());
 	emit_param("File Name", "symlink_dir");
+	struct stat st;
+	MyString file;
+	file.sprintf("%s%c%s", tmp_dir.Value(), DIR_DELIM_CHAR, "symlink_dir");
+	stat(file.Value(), &st);
+	emit_output_expected_header();
+	emit_retval("%d", st.st_ctime);
 	StatInfo info(tmp_dir.Value(), "symlink_dir");
-	time_t time = info.GetCreateTime();
+	time_t ctime = info.GetCreateTime();
 	emit_output_actual_header();
-	emit_retval("%d", time);
-	emit_param("Current Time", "%d", current_time);
-	if(abs(current_time - time) > 10) {
+	emit_retval("%d", ctime);
+	if(ctime != st.st_ctime) {
 		FAIL;
 	}
 	PASS;
diff --git a/src/condor_unit_tests/emit.cpp b/src/condor_unit_tests/emit.cpp
index c79c0a2..9e6559e 100644
--- a/src/condor_unit_tests/emit.cpp
+++ b/src/condor_unit_tests/emit.cpp
@@ -55,6 +55,7 @@ void Emitter::init(bool failures_printed, bool successes_printed) {
 	set_debug_flags("D_ALWAYS");
 	set_debug_flags("D_NOHEADER");
 	config();
+	global_start = time(0);
 }
 
 /* Formats and prints a parameter and its value as a sub-point of input,
@@ -78,7 +79,9 @@ void Emitter::emit_retval(const char* format, va_list args) {
 /* Emits a heading and the function string.
  */
 void Emitter::emit_function(const char* function) {
-	test_buf->sprintf("---------------------\nFUNCTION:  %s\n", function);
+	test_buf->sprintf("\n\n------------------------------------------------------"
+		"--------------------------\nFUNCTION:  %s\n---------------------------"
+		"-----------------------------------------------------\n", function);
 	if(print_failures && print_successes) {
 		dprintf(D_ALWAYS, "%s", test_buf->Value());
 		test_buf->setChar(0, '\0');
@@ -88,7 +91,9 @@ void Emitter::emit_function(const char* function) {
 /* Emits a heading and the object string.
  */
 void Emitter::emit_object(const char* object) {
-	test_buf->sprintf("---------------------\nOBJECT:  %s\n", object);
+	test_buf->sprintf("\n------------------------------------------------------"
+		"--------------------------\nOBJECT:  %s\n-----------------------------"
+		"---------------------------------------------------\n", object);
 	if(print_failures && print_successes) {
 		dprintf(D_ALWAYS, "%s", test_buf->Value());
 		test_buf->setChar(0, '\0');
@@ -146,7 +151,7 @@ void Emitter::emit_output_actual_header() {
  * be called via the PASS macro."
  */
 void Emitter::emit_result_success(int line) {
-	buf->sprintf_cat("RESULT:  SUCCESS, test passed at line %d (%ld seconds)\n", 
+	buf->sprintf_cat("RESULT:  SUCCESS, test passed at line %d (%ld seconds)\n",
 		line, time(0) - start);
 	print_now_if_possible();
 	if(print_successes && !print_failures) {
@@ -210,14 +215,15 @@ void Emitter::emit_test_break() {
 }
 
 void Emitter::emit_summary() {
-	dprintf(D_ALWAYS, "\n---------------------\nSUMMARY:\n");
-	dprintf(D_ALWAYS, "========\n");
+	dprintf(D_ALWAYS, "\n========\nSUMMARY:\n========\n");
 	dprintf(D_ALWAYS, "    Total Tested Objects:  %d\n", object_tests);
 	dprintf(D_ALWAYS, "    Total Unit Tests:      %d\n", function_tests);
 	dprintf(D_ALWAYS, "    Passed Unit Tests:     %d\n", passed_tests);
 	dprintf(D_ALWAYS, "    Failed Unit Tests:     %d\n", failed_tests);
 	dprintf(D_ALWAYS, "    Aborted Unit Tests:    %d\n", aborted_tests);
 	dprintf(D_ALWAYS, "    Skipped Unit Tests:    %d\n", skipped_tests);
+	dprintf(D_ALWAYS, "    Total Time Taken:      %ld seconds\n",
+			time(0) - global_start);
 }
 
 void Emitter::print_result_failure() {
diff --git a/src/condor_unit_tests/emit.h b/src/condor_unit_tests/emit.h
index 193642f..514e843 100644
--- a/src/condor_unit_tests/emit.h
+++ b/src/condor_unit_tests/emit.h
@@ -52,7 +52,7 @@ private:
 
 	MyString *buf, *test_buf;
 
-	time_t start;
+	time_t start, global_start;
 
 	void print_result_failure(void);
 	
diff --git a/src/condor_unit_tests/unit_test_utils.h b/src/condor_unit_tests/unit_test_utils.h
index 6dde910..2a3591a 100644
--- a/src/condor_unit_tests/unit_test_utils.h
+++ b/src/condor_unit_tests/unit_test_utils.h
@@ -210,4 +210,4 @@ struct timezone
 };
 
 int gettimeofday(struct timeval *tv, struct timezone *tz);
-#endif
\ No newline at end of file
+#endif
diff --git a/src/condor_utils/CMakeLists.txt b/src/condor_utils/CMakeLists.txt
index a9b6322..8e94ea9 100644
--- a/src/condor_utils/CMakeLists.txt
+++ b/src/condor_utils/CMakeLists.txt
@@ -47,7 +47,7 @@ endif()
 condor_static_lib( condorapi "${ApiSrcs}" )
 add_dependencies( condorapi utils )
 
-if (NOT WINDOWS)
+if (HAVE_LIBDL)
 	set(APILIBDEP dl)
 endif()
 
diff --git a/src/condor_utils/access_desktop.WINDOWS.cpp b/src/condor_utils/access_desktop.WINDOWS.cpp
index c192332..6b4a328 100644
--- a/src/condor_utils/access_desktop.WINDOWS.cpp
+++ b/src/condor_utils/access_desktop.WINDOWS.cpp
@@ -341,7 +341,7 @@ void RemoveSid(PSID *psid)
 BOOL AddTheAceWindowStation(HWINSTA hwinsta, PSID psid)
 {
 
-	ACCESS_ALLOWED_ACE   *pace;
+	ACCESS_ALLOWED_ACE  *pace      = NULL;
 	ACL_SIZE_INFORMATION aclSizeInfo;
 	BOOL                 bDaclExist;
 	BOOL                 bDaclPresent;
@@ -351,7 +351,7 @@ BOOL AddTheAceWindowStation(HWINSTA hwinsta, PSID psid)
 	DWORD                dwSidSize = 0;
 	DWORD                dwSdSizeNeeded;
 	PACL                 pacl;
-	PACL                 pNewAcl;
+	PACL                 pNewAcl   = NULL;
 	PSECURITY_DESCRIPTOR psd       = NULL;
 	PSECURITY_DESCRIPTOR psdNew    = NULL;
 	PVOID                pTempAce;
@@ -805,7 +805,7 @@ BOOL AddTheAceDesktop(HDESK hdesk, PSID psid)
 	DWORD                dwSidSize = 0;
 	DWORD                dwSdSizeNeeded;
 	PACL                 pacl;
-	PACL                 pNewAcl;
+	PACL                 pNewAcl   = NULL;
 	PSECURITY_DESCRIPTOR psd       = NULL;
 	PSECURITY_DESCRIPTOR psdNew    = NULL;
 	PVOID                pTempAce;
diff --git a/src/condor_utils/classad_log.cpp b/src/condor_utils/classad_log.cpp
index 90c4893..6872a63 100644
--- a/src/condor_utils/classad_log.cpp
+++ b/src/condor_utils/classad_log.cpp
@@ -28,11 +28,9 @@
 #include "util_lib_proto.h"
 #include "classad_merge.h"
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 #include "ClassAdLogPlugin.h"
 #endif
-#endif
 
 // explicitly instantiate the HashTable template
 
@@ -721,11 +719,9 @@ LogNewClassAd::Play(void *data_structure)
 	ad->SetTargetTypeName(targettype);
 	result = table->insert(HashKey(key), ad);
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 	ClassAdLogPluginManager::NewClassAd(key);
 #endif
-#endif
 
 	return result;
 }
@@ -791,11 +787,9 @@ LogDestroyClassAd::Play(void *data_structure)
 		return -1;
 	}
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 	ClassAdLogPluginManager::DestroyClassAd(key);
 #endif
-#endif
 
 	delete ad;
 	return table->remove(hkey);
@@ -841,11 +835,9 @@ LogSetAttribute::Play(void *data_structure)
 	rval = ad->AssignExpr(name, value);
 	ad->SetDirtyFlag(name, is_dirty);
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 	ClassAdLogPluginManager::SetAttribute(key, name, value);
 #endif
-#endif
 
 	return rval;
 }
@@ -940,11 +932,9 @@ LogDeleteAttribute::Play(void *data_structure)
 	if (table->lookup(HashKey(key), ad) < 0)
 		return -1;
 
-#if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
 	ClassAdLogPluginManager::DeleteAttribute(key, name);
 #endif
-#endif
 
 	return ad->Delete(name);
 }
diff --git a/src/condor_utils/classad_newold.cpp b/src/condor_utils/classad_newold.cpp
index 7edd7fc..4f43e1c 100644
--- a/src/condor_utils/classad_newold.cpp
+++ b/src/condor_utils/classad_newold.cpp
@@ -23,7 +23,6 @@
 #include "classad_newold.h"
 #include "condor_new_classads.h"
 #define WANT_CLASSAD_NAMESPACE
-#undef open
 #include "classad/classad_distribution.h"
 
 bool new_to_old(classad::ClassAd & src, ClassAd & dst)
diff --git a/src/condor_utils/compat_classad.cpp b/src/condor_utils/compat_classad.cpp
index 203be06..c6c48e4 100644
--- a/src/condor_utils/compat_classad.cpp
+++ b/src/condor_utils/compat_classad.cpp
@@ -2172,8 +2172,19 @@ _GetReferences(classad::ExprTree *tree,
 	classad::References ext_refs_set;
 	classad::References int_refs_set;
 	classad::References::iterator set_itr;
-	GetExternalReferences(tree, ext_refs_set, true);
-	GetInternalReferences(tree, int_refs_set, true);
+
+	bool ok = true;
+	if( !GetExternalReferences(tree, ext_refs_set, true) ) {
+		ok = false;
+	}
+	if( !GetInternalReferences(tree, int_refs_set, true) ) {
+		ok = false;
+	}
+	if( !ok ) {
+		dprintf(D_FULLDEBUG,"warning: failed to get all attribute references in ClassAd (perhaps caused by circular reference).\n");
+		dPrint(D_FULLDEBUG);
+		dprintf(D_FULLDEBUG,"End of offending ad.\n");
+	}
 
 		// We first process the references and save results in
 		// final_*_refs_set.  The processing may hit duplicates that
diff --git a/src/condor_utils/directory.WINDOWS.cpp b/src/condor_utils/directory.WINDOWS.cpp
index e3e7058..6c9a54a 100644
--- a/src/condor_utils/directory.WINDOWS.cpp
+++ b/src/condor_utils/directory.WINDOWS.cpp
@@ -2300,7 +2300,7 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
         }
 
         if ( acl ) {
-             GlobalFree ( acl );
+             delete[] acl;
         }
 
     }
diff --git a/src/condor_utils/directory.cpp b/src/condor_utils/directory.cpp
index f07e538..c6b08f9 100644
--- a/src/condor_utils/directory.cpp
+++ b/src/condor_utils/directory.cpp
@@ -50,6 +50,20 @@
 	return i;
 // -----------------------------------------------
 
+DeleteFileLater::DeleteFileLater (const char * _name)
+{
+    filename = _name?strdup(_name):NULL;
+}
+
+DeleteFileLater::~DeleteFileLater ()
+{
+	if (filename) {
+        if (unlink(filename)) {  // conditional to defeat prefast warning.
+            dprintf(D_ALWAYS, "DeleteFileLater of %s failed err=%d", filename, errno);
+        }
+		free (filename);
+	}
+}
 
 
 #ifndef WIN32
@@ -616,8 +630,7 @@ Directory::setOwnerPriv( const char* path, si_error_t &err)
 			if (err == SINoFile) {
 				dprintf(D_FULLDEBUG, "Directory::setOwnerPriv() -- path %s does not exist (yet).\n", path);
 			} else {
-				dprintf( D_ALWAYS, "Directory::setOwnerPriv() -- failed to "
-					 "find owner of %s\n", path );
+				dprintf( D_ALWAYS, "Directory::setOwnerPriv() -- failed to find owner of %s\n", path );
 			}
 			return PRIV_UNKNOWN;
 		}
diff --git a/src/condor_utils/directory.h b/src/condor_utils/directory.h
index ddc46f3..8114ad2 100644
--- a/src/condor_utils/directory.h
+++ b/src/condor_utils/directory.h
@@ -255,16 +255,8 @@ private:
 // when the class instance is deleted
 class DeleteFileLater {
  public:
-	DeleteFileLater (const char * _name) {
-		filename = _name?strdup(_name):NULL;
-	}
-
-	~DeleteFileLater () {
-		if (filename) {
-			unlink(filename);
-			free (filename);
-		}
-	}
+	DeleteFileLater (const char * _name);
+	~DeleteFileLater ();
  protected:
 	char * filename;
 };
diff --git a/src/condor_utils/dprintf.cpp b/src/condor_utils/dprintf.cpp
index fa9749e..a1bc148 100644
--- a/src/condor_utils/dprintf.cpp
+++ b/src/condor_utils/dprintf.cpp
@@ -1328,6 +1328,11 @@ lock_or_mutex_file(int fd, LOCK_TYPE type, int do_block)
 	char *ptr = NULL;
 	char mutex_name[MAX_PATH];
 
+		// If we're trying to lock NUL, just return success early
+	if (strcasecmp(DebugLock, "NUL") == 0) {
+		return 0;
+	}
+
 	if ( use_kernel_mutex == FALSE ) {
 			// use a filesystem lock
 		return lock_file_plain(fd,type,do_block);
@@ -1341,10 +1346,6 @@ lock_or_mutex_file(int fd, LOCK_TYPE type, int do_block)
 		// starving to get the lock.  The Win32 mutex object,
 		// on the other hand, is FIFO --- thus starvation is avoided.
 
-		// If we're trying to lock NUL, just return success early
-	if (strcasecmp(DebugLock, "NUL") == 0) {
-		return 0;
-	}
 
 		// first, open a handle to the mutex if we haven't already
 	if ( debug_win32_mutex == NULL && DebugLock ) {
diff --git a/src/condor_utils/file_lock.cpp b/src/condor_utils/file_lock.cpp
index d2ac4ea..b2a013e 100644
--- a/src/condor_utils/file_lock.cpp
+++ b/src/condor_utils/file_lock.cpp
@@ -513,6 +513,7 @@ FileLock::obtain( LOCK_TYPE t )
 // their current position.  The lesson here is don't use fseeks and lseeks
 // interchangeably...
 	int		status = -1;
+	int saved_errno;
 
 	if ( m_use_kernel_mutex == -1 ) {
 		m_use_kernel_mutex = param_boolean_int("FILE_LOCK_VIA_MUTEX", TRUE);
@@ -538,6 +539,7 @@ FileLock::obtain( LOCK_TYPE t )
 			// This will help narrow down where the delay is coming from.
 		time_t before = time(NULL);
 		status = lock_file( m_fd, t, m_blocking );
+		saved_errno = errno;
 		time_t after = time(NULL);
 		if ( (after - before) > 5 ) {
 			dprintf( D_FULLDEBUG,
@@ -594,7 +596,7 @@ FileLock::obtain( LOCK_TYPE t )
 	}
 	if ( status != 0 ) {
 		dprintf( D_ALWAYS, "FileLock::obtain(%d) failed - errno %d (%s)\n",
-	                t, errno, strerror(errno) );
+	                t, saved_errno, strerror(saved_errno) );
 	}
 	else {
 		UtcTime	now( true );
@@ -688,8 +690,8 @@ FileLock::CreateHashName(const char *orig, bool useDefault)
 	char *temp_filename;
 	int c;
 	
-#if defined(_POSIX_PATH_MAX) && !defined(WIN32)
-	char *buffer = new char[_POSIX_PATH_MAX];
+#if defined(PATH_MAX) && !defined(WIN32)
+	char *buffer = new char[PATH_MAX];
 	temp_filename = realpath(orig, buffer);
 	if (temp_filename == NULL) {
 		temp_filename = new char[strlen(orig)+1];
diff --git a/src/condor_utils/lock_file.unix.cpp b/src/condor_utils/lock_file.unix.cpp
index e38291a..d2c7b4a 100644
--- a/src/condor_utils/lock_file.unix.cpp
+++ b/src/condor_utils/lock_file.unix.cpp
@@ -21,6 +21,16 @@
 #include "condor_config.h"
 #include "condor_debug.h"
 #include "file_lock.h"
+#include "condor_random_num.h"
+
+/* Declare some static variables here that are initialized by lock_file() and
+ * used by lock_file_plain(). We do this song and dance because we want to 
+ * initialize these variables by invoking various Condor library functions,
+ * like our randomization functions, and invoking those functions from
+ * lock_file_plain() is not permitted due to deadlock and/or threading reasons
+ */
+static unsigned int _lock_file_usleep_time = 0;
+static unsigned int _lock_file_num_retries = 0;
 
 /*
   Lock a file. This version is used for all unices. The windows version
@@ -35,6 +45,8 @@ lock_file_plain( int fd, LOCK_TYPE type, int do_block )
 {
 	struct flock	f;
 	int				cmd;
+	int rc, saved_errno;
+	unsigned int num_retries = 0;
 
 	if( do_block ) {
 		cmd = F_SETLKW;		/* blocking */
@@ -64,33 +76,95 @@ lock_file_plain( int fd, LOCK_TYPE type, int do_block )
 		return -1;
 	}
 
-		/* be signal safe */
-	while( fcntl(fd,cmd,&f) < 0 ) {
-		switch (errno) {
+		/* Call fcntl */
+	rc =  fcntl(fd,cmd,&f);
+	saved_errno = errno;
+
+		/* Deal with EINTR by retrying if in non-blocking mode */
+	while ( !do_block && rc < 0  && saved_errno == EINTR ) 
+	{
+		rc =  fcntl(fd,cmd,&f);
+		saved_errno = errno;
+	}
+
+		/* Deal w/ temporary errors by retrying if in blocking mode */
+	while ( do_block && rc < 0 && num_retries < _lock_file_num_retries ) 
+	{
+		struct timeval timer;
+		timer.tv_sec = 0;
+		timer.tv_usec = _lock_file_usleep_time;
+		switch (saved_errno) {
+				// for these errors, just retry the system call 
+				// immediately, don't increment number of retries.
 			case EINTR:
-				// this just means we were interrupted, not
-				// necessarily that we failed.
 				break;
+
+				// for these errors, retry the system call a limited
+				// number of times, and after waiting a 
+				// fraction of a second.
+			case ENOLCK:
+			case EACCES:
+			case EAGAIN:
+				num_retries++;
+				// do a platform independent usleep via select()
+				select(0,NULL,NULL,NULL,&timer);
+				break;
+
+				// anything else is not an errno indicative
+				// of a temporary condition, so break out of the 
+				// while loop.
 			default:
-				return -1;
+				num_retries = _lock_file_num_retries;
+				continue;
 		}
+		
+		rc =  fcntl(fd,cmd,&f);
+		saved_errno = errno;
+	}
+
+	if ( rc < 0 ) {
+		errno = saved_errno;
+		return -1;
+	} else {
+		return 0;
 	}
-	return 0;
 }
 
 int
 lock_file( int fd, LOCK_TYPE type, int do_block )
 {
 	int rc;
+	int saved_errno;
+	static bool initialized = false;
+
+	if ( !initialized ) {
+		initialized = true;
+		char *subsys = param("SUBSYSTEM");
+		if ( subsys && strcmp(subsys,"SCHEDD")==0 ) {
+			// If we are the schedd, retry early and often.
+			// usleep time averages to 1/20 of a second, and
+			// keep trying on average for 20 seconds.
+			_lock_file_usleep_time = get_random_uint() % 100000;
+			_lock_file_num_retries = 20 * 20;
+		} else {
+			// If we are not the schedd (eg we are the shadow), we
+			// can be less agressive. usleep an average of a second, try
+			// for 5 minutes.
+			_lock_file_usleep_time = get_random_uint() % 2000000;
+			_lock_file_num_retries = 60 * 5;
+		}
+		if (subsys) free(subsys);
+	}
 
 	rc = lock_file_plain( fd, type, do_block );
+	saved_errno = errno;
 
 	/* now, fcntl should work accross nfs.  but, due to bugs in some
 	   implementations (*cough* linux *cough*) it sometimes fails with
 	   errno 37 (ENOLCK).  if this happens we check the config to see
 	   if we should report this as an error.   -zmiller  07/15/02
 	   */
-	if ( rc == -1 && errno == ENOLCK ) {
+	if ( rc == -1 && saved_errno == ENOLCK ) {
 		char* p = param("IGNORE_NFS_LOCK_ERRORS");
 		char  val = 'N';
 
@@ -103,11 +177,20 @@ lock_file( int fd, LOCK_TYPE type, int do_block )
 				// pretend there was no error.
 			dprintf ( D_FULLDEBUG, "Ignoring error ENOLCK on fd %i\n", fd );
 			return 0;
-		} else {
-			errno = ENOLCK;
-			return rc;
 		}
 	}
 
+	if ( rc == -1 )
+	{
+		dprintf( D_ALWAYS, "lock_file returning ERROR, errno=%d (%s)\n",
+				saved_errno, strerror(saved_errno) );
+#if 0  // in v7.6.0, we cannot risk EXCEPTing, but do so in v7.7.0
+		if (saved_errno == EDEADLK || saved_errno == EFAULT) {
+			EXCEPT("lock_file failed with errno %d, should never happen!",saved_errno);
+		}
+#endif
+		errno = saved_errno;
+	}
+
 	return rc;
 }
diff --git a/src/condor_utils/param_info.in b/src/condor_utils/param_info.in
index 6a0f573..1a06e61 100644
--- a/src/condor_utils/param_info.in
+++ b/src/condor_utils/param_info.in
@@ -596,7 +596,7 @@ id=559
 
 [GSI_DAEMON_DIRECTORY]
 aliases=
-default=/etc/grid-security/
+default=
 version=0.0.0
 range=.*
 state=default
@@ -3558,7 +3558,7 @@ id=189
 
 [CREATE_CORE_FILES]
 aliases=
-default=false
+default=
 version=0.0.0
 range=.*
 state=default
@@ -9481,7 +9481,7 @@ id=555
 
 [GRIDMAP]
 aliases=
-default=$(GSI_DAEMON_DIRECTORY)/grid-mapfile
+default=
 version=0.0.0
 range=.*
 state=default
@@ -9497,7 +9497,7 @@ id=555
 
 [GSI_DAEMON_TRUSTED_CA_DIR]
 aliases=
-default=$(GSI_DAEMON_DIRECTORY)/certificates
+default=
 version=0.0.0
 range=.*
 state=default
@@ -10151,3 +10151,20 @@ usage=
 url=
 tags=
 id=601
+
+[SHADOW_RUN_UNKNOWN_USER_JOBS]
+aliases=
+default=false
+version=0.0.0
+range=.*
+state=default
+type=bool
+is_macro=false
+reconfig=false
+customization=seldom
+friendly_name=Shadow Run Unknown User Jobs
+usage=
+url=
+tags=shadow
+id=602
+
diff --git a/src/condor_utils/perm.WINDOWS.cpp b/src/condor_utils/perm.WINDOWS.cpp
index fd545ea..4dec99c 100644
--- a/src/condor_utils/perm.WINDOWS.cpp
+++ b/src/condor_utils/perm.WINDOWS.cpp
@@ -102,7 +102,7 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 		&pSD_length_needed			// address of required size of buffer
 		) ) {
 		dprintf(D_ALWAYS, "perm::GetFileSecurity(%s) failed (err=%d)\n", file_name, GetLastError());
-		delete pSD;
+		delete[] pSD;
 		return -1;
 	}
 	
@@ -114,7 +114,7 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 		&acl_defaulted					// address of flag for default disc. ACL
 		) ) {
 		dprintf(D_ALWAYS, "perm::GetSecurityDescriptorDacl failed (file=%s err=%d)\n", file_name, GetLastError());
-		delete pSD;
+		delete[] pSD;
 		return -1;
 	}
 	
@@ -134,7 +134,7 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 	// first get the number of ACEs in the ACL
 		if (! GetAclInformation( pacl,		// acl to get info from
 								acl_info,	// buffer to receive info
-								24,			// size in bytes of buffer
+								sizeof(acl_info),  // size in bytes of buffer
 								AclSizeInformation // class of info to retrieve
 								) ) {
 			dprintf(D_ALWAYS, "Perm::GetAclInformation failed with error %d\n", GetLastError() );
@@ -439,10 +439,8 @@ int perm::userInAce ( const LPVOID cur_ace, const char *account, const char *dom
 		char* builtin = getBuiltinDomainName();
 		char* nt_authority = getNTAuthorityDomainName();
 
-		
-		int success = GetComputerName( computerName, &nameLength );
-		
-		if (! success ) {
+		BOOL bSuccess = GetComputerName( computerName, &nameLength );
+		if ( ! bSuccess ) {
 			// this should never happen
 			dprintf(D_ALWAYS, "perm::GetComputerName failed: (Err: %d)", GetLastError());
 			result = -1; // failure
diff --git a/src/condor_utils/stl_string_utils.cpp b/src/condor_utils/stl_string_utils.cpp
index 230796a..237bb6d 100644
--- a/src/condor_utils/stl_string_utils.cpp
+++ b/src/condor_utils/stl_string_utils.cpp
@@ -44,7 +44,7 @@ bool operator>=(const MyString& L, const std::string& R) { return R <= L.Value()
 bool operator>=(const std::string& L, const MyString& R) { return L >= R.Value(); }
 
 
-int sprintf(std::string& s, const char* format, va_list pargs) {
+int vsprintf(std::string& s, const char* format, va_list pargs) {
     char fixbuf[STL_STRING_UTILS_FIXBUF];
     const int fixlen = sizeof(fixbuf)/sizeof(fixbuf[0]);
 	int n;
@@ -105,7 +105,7 @@ int sprintf(std::string& s, const char* format, va_list pargs) {
 int sprintf(std::string& s, const char* format, ...) {
     va_list args;
     va_start(args, format);
-    int r = sprintf(s, format, args);
+    int r = vsprintf(s, format, args);
     va_end(args);
     return r;
 }
@@ -115,7 +115,7 @@ int sprintf(MyString& s, const char* format, ...) {
     std::string t;
     va_start(args, format);
     // this gets me the sprintf-standard return value (# chars printed)
-    int r = sprintf(t, format, args);
+    int r = vsprintf(t, format, args);
     va_end(args);
     assign(s, t);
     return r;
@@ -125,7 +125,7 @@ int sprintf_cat(std::string& s, const char* format, ...) {
     va_list args;
     std::string t;
     va_start(args, format);
-    int r = sprintf(t, format, args);
+    int r = vsprintf(t, format, args);
     va_end(args);
     s += t;
     return r;
@@ -135,7 +135,7 @@ int sprintf_cat(MyString& s, const char* format, ...) {
     va_list args;
     std::string t;
     va_start(args, format);
-    int r = sprintf(t, format, args);
+    int r = vsprintf(t, format, args);
     va_end(args);
     s += t.c_str();
     return r;
diff --git a/src/condor_utils/store_cred.cpp b/src/condor_utils/store_cred.cpp
index 0bc7711..162d6ae 100644
--- a/src/condor_utils/store_cred.cpp
+++ b/src/condor_utils/store_cred.cpp
@@ -282,7 +282,7 @@ char* getStoredCredential(const char *username, const char *domain)
 		return NULL;
 	}
 
-	if ( _snprintf(pw, 511, "%S", w_pw) < 0 ) {
+	if ( _snprintf(pw, sizeof(pw), "%S", w_pw) < 0 ) {
 		return NULL;
 	}
 
@@ -922,7 +922,7 @@ read_from_keyboard(char* buf, int maxlength, bool echo) {
 	//Down convert the input into ASCII.
 	int converted = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, wbuffer, -1, buf, maxlength, NULL, NULL);
 
-	delete wbuffer;
+	delete[] wbuffer;
 #endif
 
 	return TRUE;
diff --git a/src/cream_gahp/cream_gahp_server.cpp b/src/cream_gahp/cream_gahp_server.cpp
index a09186e..b35d914 100644
--- a/src/cream_gahp/cream_gahp_server.cpp
+++ b/src/cream_gahp/cream_gahp_server.cpp
@@ -1348,7 +1348,7 @@ int thread_cream_job_status( Request **reqlist )
 			 it != reqids.end(); it++ ) {
 
 			char *msg = escape_spaces(ex.what());
-			enqueue_result( (*it) + " CREAM_Job_Start\\ Error:\\ " + msg );
+			enqueue_result( (*it) + " CREAM_Job_Status\\ Error:\\ " + msg );
 			free(msg);
 		}
 		return 1;
